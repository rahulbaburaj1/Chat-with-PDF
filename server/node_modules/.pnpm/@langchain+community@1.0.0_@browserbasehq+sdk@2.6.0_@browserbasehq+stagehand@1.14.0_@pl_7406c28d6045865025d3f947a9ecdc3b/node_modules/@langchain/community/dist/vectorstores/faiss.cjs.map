{"version":3,"file":"faiss.cjs","names":["SaveableVectorStore","embeddings: EmbeddingsInterface","args: FaissLibArgs","SynchronousInMemoryDocstore","documents: Document[]","options?: { ids?: string[] }","index: IndexFlatL2","vectors: number[][]","query: number[]","k: number","uuid","directory: string","params: { ids: string[] }","targetIndex: FaissStore","directory","Document","store","texts: string[]","metadatas: object[] | object","dbConfig?: {\n      docstore?: SynchronousInMemoryDocstore;\n    }","docs: Document[]","err: any"],"sources":["../../src/vectorstores/faiss.ts"],"sourcesContent":["import type { IndexFlatL2 } from \"faiss-node\";\nimport type { NameRegistry, Parser } from \"pickleparser\";\nimport * as uuid from \"uuid\";\nimport type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { SaveableVectorStore } from \"@langchain/core/vectorstores\";\nimport { Document } from \"@langchain/core/documents\";\nimport { SynchronousInMemoryDocstore } from \"@langchain/classic/stores/doc/in_memory\";\n\n/**\n * Interface for the arguments required to initialize a FaissStore\n * instance.\n */\nexport interface FaissLibArgs {\n  docstore?: SynchronousInMemoryDocstore;\n  index?: IndexFlatL2;\n  mapping?: Record<number, string>;\n}\n\n/**\n * A class that wraps the FAISS (Facebook AI Similarity Search) vector\n * database for efficient similarity search and clustering of dense\n * vectors.\n */\nexport class FaissStore extends SaveableVectorStore {\n  _index?: IndexFlatL2;\n\n  _mapping: Record<number, string>;\n\n  docstore: SynchronousInMemoryDocstore;\n\n  args: FaissLibArgs;\n\n  _vectorstoreType(): string {\n    return \"faiss\";\n  }\n\n  getMapping(): Record<number, string> {\n    return this._mapping;\n  }\n\n  getDocstore(): SynchronousInMemoryDocstore {\n    return this.docstore;\n  }\n\n  constructor(embeddings: EmbeddingsInterface, args: FaissLibArgs) {\n    super(embeddings, args);\n    this.args = args;\n    this._index = args.index;\n    this._mapping = args.mapping ?? {};\n    this.embeddings = embeddings;\n    this.docstore = args?.docstore ?? new SynchronousInMemoryDocstore();\n  }\n\n  /**\n   * Adds an array of Document objects to the store.\n   * @param documents An array of Document objects.\n   * @returns A Promise that resolves when the documents have been added.\n   */\n  async addDocuments(documents: Document[], options?: { ids?: string[] }) {\n    const texts = documents.map(({ pageContent }) => pageContent);\n    return this.addVectors(\n      await this.embeddings.embedDocuments(texts),\n      documents,\n      options\n    );\n  }\n\n  public get index(): IndexFlatL2 {\n    if (!this._index) {\n      throw new Error(\n        \"Vector store not initialised yet. Try calling `fromTexts`, `fromDocuments` or `fromIndex` first.\"\n      );\n    }\n    return this._index;\n  }\n\n  private set index(index: IndexFlatL2) {\n    this._index = index;\n  }\n\n  /**\n   * Adds an array of vectors and their corresponding Document objects to\n   * the store.\n   * @param vectors An array of vectors.\n   * @param documents An array of Document objects corresponding to the vectors.\n   * @returns A Promise that resolves with an array of document IDs when the vectors and documents have been added.\n   */\n  async addVectors(\n    vectors: number[][],\n    documents: Document[],\n    options?: { ids?: string[] }\n  ) {\n    if (vectors.length === 0) {\n      return [];\n    }\n    if (vectors.length !== documents.length) {\n      throw new Error(`Vectors and documents must have the same length`);\n    }\n    const dv = vectors[0].length;\n    if (!this._index) {\n      const { IndexFlatL2 } = await FaissStore.importFaiss();\n      this._index = new IndexFlatL2(dv);\n    }\n    const d = this.index.getDimension();\n    if (dv !== d) {\n      throw new Error(\n        `Vectors must have the same length as the number of dimensions (${d})`\n      );\n    }\n\n    const docstoreSize = this.index.ntotal();\n    const documentIds = options?.ids ?? documents.map(() => uuid.v4());\n    for (let i = 0; i < vectors.length; i += 1) {\n      const documentId = documentIds[i];\n      const id = docstoreSize + i;\n      this.index.add(vectors[i]);\n      this._mapping[id] = documentId;\n      this.docstore.add({ [documentId]: documents[i] });\n    }\n    return documentIds;\n  }\n\n  /**\n   * Performs a similarity search in the vector store using a query vector\n   * and returns the top k results along with their scores.\n   * @param query A query vector.\n   * @param k The number of top results to return.\n   * @returns A Promise that resolves with an array of tuples, each containing a Document and its corresponding score.\n   */\n  async similaritySearchVectorWithScore(query: number[], k: number) {\n    const d = this.index.getDimension();\n    if (query.length !== d) {\n      throw new Error(\n        `Query vector must have the same length as the number of dimensions (${d})`\n      );\n    }\n    if (k > this.index.ntotal()) {\n      const total = this.index.ntotal();\n      console.warn(\n        `k (${k}) is greater than the number of elements in the index (${total}), setting k to ${total}`\n      );\n      // eslint-disable-next-line no-param-reassign\n      k = total;\n    }\n    const result = this.index.search(query, k);\n    return result.labels.map((id, index) => {\n      const uuid = this._mapping[id];\n      return [this.docstore.search(uuid), result.distances[index]] as [\n        Document,\n        number\n      ];\n    });\n  }\n\n  /**\n   * Saves the current state of the FaissStore to a specified directory.\n   * @param directory The directory to save the state to.\n   * @returns A Promise that resolves when the state has been saved.\n   */\n  async save(directory: string) {\n    const fs = await import(\"node:fs/promises\");\n    const path = await import(\"node:path\");\n    await fs.mkdir(directory, { recursive: true });\n    await Promise.all([\n      this.index.write(path.join(directory, \"faiss.index\")),\n      await fs.writeFile(\n        path.join(directory, \"docstore.json\"),\n        JSON.stringify([\n          Array.from(this.docstore._docs.entries()),\n          this._mapping,\n        ])\n      ),\n    ]);\n  }\n\n  /**\n   * Method to delete documents.\n   * @param params Object containing the IDs of the documents to delete.\n   * @returns A promise that resolves when the deletion is complete.\n   */\n  async delete(params: { ids: string[] }) {\n    const documentIds = params.ids;\n    if (documentIds == null) {\n      throw new Error(\"No documentIds provided to delete.\");\n    }\n\n    const mappings = new Map(\n      Object.entries(this._mapping).map(([key, value]) => [\n        parseInt(key, 10),\n        value,\n      ])\n    );\n    const reversedMappings = new Map(\n      Array.from(mappings, (entry) => [entry[1], entry[0]])\n    );\n\n    const missingIds = new Set(\n      documentIds.filter((id) => !reversedMappings.has(id))\n    );\n    if (missingIds.size > 0) {\n      throw new Error(\n        `Some specified documentIds do not exist in the current store. DocumentIds not found: ${Array.from(\n          missingIds\n        ).join(\", \")}`\n      );\n    }\n\n    const indexIdToDelete = documentIds.map((id) => reversedMappings.get(id)!);\n\n    // remove from index\n    this.index.removeIds(indexIdToDelete);\n    // remove from docstore\n    documentIds.forEach((id) => {\n      this.docstore._docs.delete(id);\n    });\n    // remove from mappings\n    indexIdToDelete.forEach((id) => {\n      mappings.delete(id);\n    });\n\n    this._mapping = { ...Array.from(mappings.values()) };\n  }\n\n  /**\n   * Merges the current FaissStore with another FaissStore.\n   * @param targetIndex The FaissStore to merge with.\n   * @returns A Promise that resolves with an array of document IDs when the merge is complete.\n   */\n  async mergeFrom(targetIndex: FaissStore) {\n    const targetIndexDimensions = targetIndex.index.getDimension();\n    if (!this._index) {\n      const { IndexFlatL2 } = await FaissStore.importFaiss();\n      this._index = new IndexFlatL2(targetIndexDimensions);\n    }\n    const d = this.index.getDimension();\n    if (targetIndexDimensions !== d) {\n      throw new Error(\"Cannot merge indexes with different dimensions.\");\n    }\n    const targetMapping = targetIndex.getMapping();\n    const targetDocstore = targetIndex.getDocstore();\n    const targetSize = targetIndex.index.ntotal();\n    const documentIds = [];\n    const currentDocstoreSize = this.index.ntotal();\n    for (let i = 0; i < targetSize; i += 1) {\n      const targetId = targetMapping[i];\n      documentIds.push(targetId);\n      const targetDocument = targetDocstore.search(targetId);\n      const id = currentDocstoreSize + i;\n      this._mapping[id] = targetId;\n      this.docstore.add({ [targetId]: targetDocument });\n    }\n    this.index.mergeFrom(targetIndex.index);\n    return documentIds;\n  }\n\n  /**\n   * Loads a FaissStore from a specified directory.\n   * @param directory The directory to load the FaissStore from.\n   * @param embeddings An Embeddings object.\n   * @returns A Promise that resolves with a new FaissStore instance.\n   */\n  static async load(directory: string, embeddings: EmbeddingsInterface) {\n    const fs = await import(\"node:fs/promises\");\n    const path = await import(\"node:path\");\n    const readStore = (directory: string) =>\n      fs\n        .readFile(path.join(directory, \"docstore.json\"), \"utf8\")\n        .then(JSON.parse) as Promise<\n        [Map<string, Document>, Record<number, string>]\n      >;\n    const readIndex = async (directory: string) => {\n      const { IndexFlatL2 } = await this.importFaiss();\n      return IndexFlatL2.read(path.join(directory, \"faiss.index\"));\n    };\n    const [[docstoreFiles, mapping], index] = await Promise.all([\n      readStore(directory),\n      readIndex(directory),\n    ]);\n    const docstore = new SynchronousInMemoryDocstore(new Map(docstoreFiles));\n    return new this(embeddings, { docstore, index, mapping });\n  }\n\n  static async loadFromPython(\n    directory: string,\n    embeddings: EmbeddingsInterface\n  ) {\n    const fs = await import(\"node:fs/promises\");\n    const path = await import(\"node:path\");\n    const { Parser, NameRegistry } = await this.importPickleparser();\n\n    class PyDocument extends Map {\n      toDocument(): Document {\n        return new Document({\n          pageContent: this.get(\"page_content\"),\n          metadata: this.get(\"metadata\"),\n        });\n      }\n    }\n\n    class PyInMemoryDocstore {\n      _dict: Map<string, PyDocument>;\n\n      toInMemoryDocstore(): SynchronousInMemoryDocstore {\n        const s = new SynchronousInMemoryDocstore();\n        for (const [key, value] of Object.entries(this._dict)) {\n          s._docs.set(key, value.toDocument());\n        }\n        return s;\n      }\n    }\n\n    const readStore = async (directory: string) => {\n      const pkl = await fs.readFile(\n        path.join(directory, \"index.pkl\"),\n        \"binary\"\n      );\n      const buffer = Buffer.from(pkl, \"binary\");\n\n      const registry = new NameRegistry()\n        .register(\n          \"langchain.docstore.in_memory\",\n          \"InMemoryDocstore\",\n          PyInMemoryDocstore\n        )\n        .register(\n          \"langchain_community.docstore.in_memory\",\n          \"InMemoryDocstore\",\n          PyInMemoryDocstore\n        )\n        .register(\"langchain.schema\", \"Document\", PyDocument)\n        .register(\"langchain.docstore.document\", \"Document\", PyDocument)\n        .register(\"langchain.schema.document\", \"Document\", PyDocument)\n        .register(\"langchain_core.documents.base\", \"Document\", PyDocument)\n        .register(\"pathlib\", \"WindowsPath\", (...args) => args.join(\"\\\\\"))\n        .register(\"pathlib\", \"PosixPath\", (...args) => args.join(\"/\"));\n\n      const pickleparser = new Parser({\n        nameResolver: registry,\n      });\n      const [rawStore, mapping] =\n        pickleparser.parse<[PyInMemoryDocstore, Record<number, string>]>(\n          buffer\n        );\n      const store = rawStore.toInMemoryDocstore();\n      return { store, mapping };\n    };\n    const readIndex = async (directory: string) => {\n      const { IndexFlatL2 } = await this.importFaiss();\n      return IndexFlatL2.read(path.join(directory, \"index.faiss\"));\n    };\n    const [store, index] = await Promise.all([\n      readStore(directory),\n      readIndex(directory),\n    ]);\n    return new this(embeddings, {\n      docstore: store.store,\n      index,\n      mapping: store.mapping,\n    });\n  }\n\n  /**\n   * Creates a new FaissStore from an array of texts, their corresponding\n   * metadata, and an Embeddings object.\n   * @param texts An array of texts.\n   * @param metadatas An array of metadata corresponding to the texts, or a single metadata object to be used for all texts.\n   * @param embeddings An Embeddings object.\n   * @param dbConfig An optional configuration object for the document store.\n   * @returns A Promise that resolves with a new FaissStore instance.\n   */\n  static async fromTexts(\n    texts: string[],\n    metadatas: object[] | object,\n    embeddings: EmbeddingsInterface,\n    dbConfig?: {\n      docstore?: SynchronousInMemoryDocstore;\n    }\n  ): Promise<FaissStore> {\n    const docs: Document[] = [];\n    for (let i = 0; i < texts.length; i += 1) {\n      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;\n      const newDoc = new Document({\n        pageContent: texts[i],\n        metadata,\n      });\n      docs.push(newDoc);\n    }\n    return this.fromDocuments(docs, embeddings, dbConfig);\n  }\n\n  /**\n   * Creates a new FaissStore from an array of Document objects and an\n   * Embeddings object.\n   * @param docs An array of Document objects.\n   * @param embeddings An Embeddings object.\n   * @param dbConfig An optional configuration object for the document store.\n   * @returns A Promise that resolves with a new FaissStore instance.\n   */\n  static async fromDocuments(\n    docs: Document[],\n    embeddings: EmbeddingsInterface,\n    dbConfig?: {\n      docstore?: SynchronousInMemoryDocstore;\n    }\n  ): Promise<FaissStore> {\n    const args: FaissLibArgs = {\n      docstore: dbConfig?.docstore,\n    };\n    const instance = new this(embeddings, args);\n    await instance.addDocuments(docs);\n    return instance;\n  }\n\n  /**\n   * Creates a new FaissStore from an existing FaissStore and an Embeddings\n   * object.\n   * @param targetIndex An existing FaissStore.\n   * @param embeddings An Embeddings object.\n   * @param dbConfig An optional configuration object for the document store.\n   * @returns A Promise that resolves with a new FaissStore instance.\n   */\n  static async fromIndex(\n    targetIndex: FaissStore,\n    embeddings: EmbeddingsInterface,\n    dbConfig?: {\n      docstore?: SynchronousInMemoryDocstore;\n    }\n  ): Promise<FaissStore> {\n    const args: FaissLibArgs = {\n      docstore: dbConfig?.docstore,\n    };\n    const instance = new this(embeddings, args);\n    await instance.mergeFrom(targetIndex);\n    return instance;\n  }\n\n  static async importFaiss(): Promise<{ IndexFlatL2: typeof IndexFlatL2 }> {\n    try {\n      const {\n        default: { IndexFlatL2 },\n      } = await import(\"faiss-node\");\n\n      return { IndexFlatL2 };\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (err: any) {\n      throw new Error(\n        `Could not import faiss-node. Please install faiss-node as a dependency with, e.g. \\`npm install -S faiss-node\\`.\\n\\nError: ${err?.message}`\n      );\n    }\n  }\n\n  static async importPickleparser(): Promise<{\n    Parser: typeof Parser;\n    NameRegistry: typeof NameRegistry;\n  }> {\n    try {\n      const {\n        default: { Parser, NameRegistry },\n      } = await import(\"pickleparser\");\n\n      return { Parser, NameRegistry };\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (err: any) {\n      throw new Error(\n        `Could not import pickleparser. Please install pickleparser as a dependency with, e.g. \\`npm install -S pickleparser\\`.\\n\\nError: ${err?.message}`\n      );\n    }\n  }\n}\n"],"mappings":"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"}