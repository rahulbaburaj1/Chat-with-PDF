{"version":3,"file":"viewindexmanager.cjs","names":[],"sources":["../../../../../../../../../node_modules/.pnpm/couchbase@4.5.0/node_modules/couchbase/dist/viewindexmanager.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ViewIndexManager = exports.DesignDocument = exports.DesignDocumentView = void 0;\nconst utilities_1 = require(\"./utilities\");\nconst viewtypes_1 = require(\"./viewtypes\");\nconst bindingutilities_1 = require(\"./bindingutilities\");\n/**\n * Contains information about a view in a design document.\n *\n * @category Management\n */\nclass DesignDocumentView {\n    /**\n     * @internal\n     */\n    constructor(...args) {\n        let data;\n        if (typeof args[0] === 'string' || typeof args[0] === 'function') {\n            data = {\n                map: args[0],\n                reduce: args[1],\n            };\n        }\n        else {\n            data = args[0];\n        }\n        this.map = data.map;\n        this.reduce = data.reduce;\n    }\n    /**\n     * @internal\n     */\n    static _toCppData(name, data) {\n        return {\n            name: name,\n            map: data.map,\n            reduce: data.reduce,\n        };\n    }\n    /**\n     * @internal\n     */\n    static _fromCppData(data) {\n        return new DesignDocumentView({\n            map: data.map,\n            reduce: data.reduce,\n        });\n    }\n}\nexports.DesignDocumentView = DesignDocumentView;\n/**\n * Contains information about a design document.\n *\n * @category Management\n */\nclass DesignDocument {\n    /**\n     * Same as {@link DesignDocumentView}.\n     *\n     * @deprecated Use {@link DesignDocumentView} directly.\n     */\n    static get View() {\n        return DesignDocumentView;\n    }\n    /**\n     * @internal\n     */\n    constructor(...args) {\n        let data;\n        if (typeof args[0] === 'string') {\n            data = {\n                name: args[0],\n                views: args[1],\n            };\n        }\n        else {\n            data = args[0];\n        }\n        this.name = data.name;\n        this.views = data.views || {};\n        this.namespace = data.namespace || viewtypes_1.DesignDocumentNamespace.Production;\n        this.rev = data.rev;\n    }\n    /**\n     * @internal\n     */\n    static _fromNsData(ddocName, ddocData) {\n        const views = {};\n        for (const viewName in ddocData.views) {\n            const viewData = ddocData.views[viewName];\n            views[viewName] = new DesignDocumentView({\n                map: viewData.map,\n                reduce: viewData.reduce,\n            });\n        }\n        return new DesignDocument({ name: ddocName, views: views });\n    }\n    /**\n     * @internal\n     */\n    static _toCppData(data, namespace) {\n        const cppView = {};\n        for (const [k, v] of Object.entries(data.views)) {\n            cppView[k] = DesignDocumentView._toCppData(k, v);\n        }\n        return {\n            rev: data.rev,\n            name: data.name,\n            ns: (0, bindingutilities_1.designDocumentNamespaceToCpp)(namespace),\n            views: cppView,\n        };\n    }\n    /**\n     * @internal\n     */\n    static _fromCppData(ddoc) {\n        const views = {};\n        for (const [viewName, viewData] of Object.entries(ddoc.views)) {\n            views[viewName] = DesignDocumentView._fromCppData(viewData);\n        }\n        return new DesignDocument({\n            name: ddoc.name,\n            views: views,\n            namespace: (0, bindingutilities_1.designDocumentNamespaceFromCpp)(ddoc.ns),\n            rev: ddoc.rev,\n        });\n    }\n}\nexports.DesignDocument = DesignDocument;\n/**\n * ViewIndexManager is an interface which enables the management\n * of view indexes on the cluster.\n *\n * @category Management\n */\nclass ViewIndexManager {\n    /**\n     * @internal\n     */\n    constructor(bucket) {\n        this._bucket = bucket;\n    }\n    /**\n     * @internal\n     */\n    get _cluster() {\n        return this._bucket.cluster;\n    }\n    /**\n     * @internal\n     */\n    async getAllDesignDocuments() {\n        let namespace;\n        let options;\n        let callback;\n        // deprecated path: options and maybe callback passed in\n        if (typeof arguments[0] === 'object') {\n            namespace = undefined;\n            options = arguments[0];\n            callback = arguments[1];\n        }\n        else if (arguments[0] instanceof Function) {\n            // deprecated path: no options, only callback passed in\n            namespace = undefined;\n            options = undefined;\n            callback = arguments[0];\n        }\n        else {\n            // either no args passed in or desired path (namespace is 1st arg)\n            namespace = arguments[0];\n            // still need to handle possible no options, but callback passed in\n            if (arguments[1] instanceof Function) {\n                callback = arguments[1];\n                options = undefined;\n            }\n            else {\n                options = arguments[1];\n                callback = arguments[2];\n            }\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        const ns = namespace !== null && namespace !== void 0 ? namespace : viewtypes_1.DesignDocumentNamespace.Production;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementViewIndexGetAll({\n                bucket_name: this._bucket.name,\n                ns: (0, bindingutilities_1.designDocumentNamespaceToCpp)(ns),\n                timeout: timeout,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                const ddocs = [];\n                for (const ddoc of resp.design_documents) {\n                    ddocs.push(DesignDocument._fromCppData(ddoc));\n                }\n                wrapCallback(null, ddocs);\n            });\n        }, callback);\n    }\n    /**\n     * @internal\n     */\n    async getDesignDocument() {\n        let designDocName = arguments[0];\n        let namespace;\n        let options;\n        let callback;\n        // deprecated path: options and maybe callback passed in\n        if (typeof arguments[1] === 'object') {\n            namespace = undefined;\n            options = arguments[1];\n            callback = arguments[2];\n        }\n        else if (arguments[1] instanceof Function) {\n            // deprecated path: no options, only callback passed in\n            namespace = undefined;\n            options = undefined;\n            callback = arguments[1];\n        }\n        else {\n            // either no other args passed in or desired path (namespace is 2nd arg)\n            namespace = arguments[1];\n            // still need to handle possible no options, but callback passed in\n            if (arguments[2] instanceof Function) {\n                callback = arguments[2];\n                options = undefined;\n            }\n            else {\n                options = arguments[2];\n                callback = arguments[3];\n            }\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        // for compatibility with older SDK versions (i.e. deprecated getDesignDocument())\n        if (designDocName.startsWith('dev_')) {\n            namespace = viewtypes_1.DesignDocumentNamespace.Development;\n            designDocName = designDocName.substring(4);\n        }\n        const ns = namespace !== null && namespace !== void 0 ? namespace : viewtypes_1.DesignDocumentNamespace.Production;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementViewIndexGet({\n                bucket_name: this._bucket.name,\n                document_name: designDocName,\n                ns: (0, bindingutilities_1.designDocumentNamespaceToCpp)(ns),\n                timeout: timeout,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                const ddoc = DesignDocument._fromCppData(resp.document);\n                wrapCallback(null, ddoc);\n            });\n        }, callback);\n    }\n    /**\n     * @internal\n     */\n    async upsertDesignDocument() {\n        const designDoc = arguments[0];\n        let namespace;\n        let options;\n        let callback;\n        // deprecated path: options and maybe callback passed in\n        if (typeof arguments[1] === 'object') {\n            namespace = undefined;\n            options = arguments[1];\n            callback = arguments[2];\n        }\n        else if (arguments[1] instanceof Function) {\n            // deprecated path: no options, only callback passed in\n            namespace = undefined;\n            options = undefined;\n            callback = arguments[1];\n        }\n        else {\n            // either no other args passed in or desired path (namespace is 2nd arg)\n            namespace = arguments[1];\n            // still need to handle possible no options, but callback passed in\n            if (arguments[2] instanceof Function) {\n                callback = arguments[2];\n                options = undefined;\n            }\n            else {\n                options = arguments[2];\n                callback = arguments[3];\n            }\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        // for compatibility with older SDK versions (i.e. deprecated upsertDesignDocument())\n        if (designDoc.name.startsWith('dev_')) {\n            namespace = viewtypes_1.DesignDocumentNamespace.Development;\n            designDoc.name = designDoc.name.substring(4);\n        }\n        const ns = namespace !== null && namespace !== void 0 ? namespace : viewtypes_1.DesignDocumentNamespace.Production;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementViewIndexUpsert({\n                bucket_name: this._bucket.name,\n                document: DesignDocument._toCppData(designDoc, ns),\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * @internal\n     */\n    async dropDesignDocument() {\n        let designDocName = arguments[0];\n        let namespace;\n        let options;\n        let callback;\n        // deprecated path: options and maybe callback passed in\n        if (typeof arguments[1] === 'object') {\n            namespace = undefined;\n            options = arguments[1];\n            callback = arguments[2];\n        }\n        else if (arguments[1] instanceof Function) {\n            // deprecated path: no options, only callback passed in\n            namespace = undefined;\n            options = undefined;\n            callback = arguments[1];\n        }\n        else {\n            // either no other args passed in or desired path (namespace is 2nd arg)\n            namespace = arguments[1];\n            // still need to handle possible no options, but callback passed in\n            if (arguments[2] instanceof Function) {\n                callback = arguments[2];\n                options = undefined;\n            }\n            else {\n                options = arguments[2];\n                callback = arguments[3];\n            }\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        // for compatibility with older SDK versions (i.e. deprecated dropDesignDocument())\n        if (designDocName.startsWith('dev_')) {\n            namespace = viewtypes_1.DesignDocumentNamespace.Development;\n            designDocName = designDocName.substring(4);\n        }\n        const ns = namespace !== null && namespace !== void 0 ? namespace : viewtypes_1.DesignDocumentNamespace.Production;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementViewIndexDrop({\n                bucket_name: this._bucket.name,\n                document_name: designDocName,\n                ns: (0, bindingutilities_1.designDocumentNamespaceToCpp)(ns),\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Publishes a development design document to be a production design document.\n     * It does this by fetching the design document by the passed name with `dev_`\n     * appended, and then performs an upsert of the production name (no `dev_`)\n     * with the data which was just fetched.\n     *\n     * @param designDocName The name of the design document to publish.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async publishDesignDocument(designDocName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        const timer = new utilities_1.CompoundTimeout(timeout);\n        return utilities_1.PromiseHelper.wrapAsync(async () => {\n            const designDoc = await this.getDesignDocument(designDocName, viewtypes_1.DesignDocumentNamespace.Development, {\n                timeout: timer.left(),\n            });\n            await this.upsertDesignDocument(designDoc, viewtypes_1.DesignDocumentNamespace.Production, {\n                timeout: timer.left(),\n            });\n        }, callback);\n    }\n}\nexports.ViewIndexManager = ViewIndexManager;\n"],"x_google_ignoreList":[0],"mappings":"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"}