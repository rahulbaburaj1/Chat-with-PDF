{"version":3,"file":"scopesearchindexmanager.cjs","names":[],"sources":["../../../../../../../../../node_modules/.pnpm/couchbase@4.5.0/node_modules/couchbase/dist/scopesearchindexmanager.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ScopeSearchIndexManager = void 0;\nconst utilities_1 = require(\"./utilities\");\nconst bindingutilities_1 = require(\"./bindingutilities\");\nconst searchindexmanager_1 = require(\"./searchindexmanager\");\n/**\n * SearchIndexManager provides an interface for managing the\n * search indexes on the cluster.\n *\n * @category Management\n */\nclass ScopeSearchIndexManager {\n    /**\n     * @internal\n     */\n    constructor(cluster, bucketName, scopeName) {\n        this._cluster = cluster;\n        this._bucketName = bucketName;\n        this._scopeName = scopeName;\n    }\n    /**\n     * Returns an index by it's name.\n     *\n     * @param indexName The index to retrieve.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async getIndex(indexName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexGet({\n                index_name: indexName,\n                timeout: timeout,\n                bucket_name: this._bucketName,\n                scope_name: this._scopeName,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                const index = searchindexmanager_1.SearchIndex._fromCppData(resp.index);\n                wrapCallback(null, index);\n            });\n        }, callback);\n    }\n    /**\n     * Returns a list of all existing indexes.\n     *\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async getAllIndexes(options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[0];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexGetAll({\n                timeout: timeout,\n                bucket_name: this._bucketName,\n                scope_name: this._scopeName,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                const indexes = resp.indexes.map((indexData) => searchindexmanager_1.SearchIndex._fromCppData(indexData));\n                wrapCallback(null, indexes);\n            });\n        }, callback);\n    }\n    /**\n     * Creates or updates an existing index.\n     *\n     * @param indexDefinition The index to update.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async upsertIndex(indexDefinition, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexUpsert({\n                index: searchindexmanager_1.SearchIndex._toCppData(indexDefinition),\n                timeout: timeout,\n                bucket_name: this._bucketName,\n                scope_name: this._scopeName,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Drops an index.\n     *\n     * @param indexName The name of the index to drop.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async dropIndex(indexName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexDrop({\n                index_name: indexName,\n                timeout: timeout,\n                bucket_name: this._bucketName,\n                scope_name: this._scopeName,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Returns the number of documents that have been indexed.\n     *\n     * @param indexName The name of the index to return the count for.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async getIndexedDocumentsCount(indexName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexGetDocumentsCount({\n                index_name: indexName,\n                timeout: timeout,\n                bucket_name: this._bucketName,\n                scope_name: this._scopeName,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(null, resp.count);\n            });\n        }, callback);\n    }\n    /**\n     * Pauses the ingestion of documents into an index.\n     *\n     * @param indexName The name of the index to pause.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async pauseIngest(indexName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexControlIngest({\n                index_name: indexName,\n                pause: true,\n                timeout: timeout,\n                bucket_name: this._bucketName,\n                scope_name: this._scopeName,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Resumes the ingestion of documents into an index.\n     *\n     * @param indexName The name of the index to resume.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async resumeIngest(indexName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexControlIngest({\n                index_name: indexName,\n                pause: false,\n                timeout: timeout,\n                bucket_name: this._bucketName,\n                scope_name: this._scopeName,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Enables querying of an index.\n     *\n     * @param indexName The name of the index to enable querying for.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async allowQuerying(indexName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexControlQuery({\n                index_name: indexName,\n                allow: true,\n                timeout: timeout,\n                bucket_name: this._bucketName,\n                scope_name: this._scopeName,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Disables querying of an index.\n     *\n     * @param indexName The name of the index to disable querying for.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async disallowQuerying(indexName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexControlQuery({\n                index_name: indexName,\n                allow: false,\n                timeout: timeout,\n                bucket_name: this._bucketName,\n                scope_name: this._scopeName,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Freezes the indexing plan for execution of queries.\n     *\n     * @param indexName The name of the index to freeze the plan of.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async freezePlan(indexName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexControlPlanFreeze({\n                index_name: indexName,\n                freeze: true,\n                timeout: timeout,\n                bucket_name: this._bucketName,\n                scope_name: this._scopeName,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Unfreezes the indexing plan for execution of queries.\n     *\n     * @param indexName The name of the index to freeze the plan of.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async unfreezePlan(indexName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexControlPlanFreeze({\n                index_name: indexName,\n                freeze: false,\n                timeout: timeout,\n                bucket_name: this._bucketName,\n                scope_name: this._scopeName,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Performs analysis of a specific document by an index.\n     *\n     * @param indexName The name of the index to use for the analysis.\n     * @param document The document to analyze.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async analyzeDocument(indexName, document, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[2];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexAnalyzeDocument({\n                index_name: indexName,\n                encoded_document: JSON.stringify(document),\n                timeout: timeout,\n                bucket_name: this._bucketName,\n                scope_name: this._scopeName,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                const result = JSON.parse(resp.analysis);\n                wrapCallback(result, null);\n            });\n        }, callback);\n    }\n}\nexports.ScopeSearchIndexManager = ScopeSearchIndexManager;\n"],"x_google_ignoreList":[0],"mappings":"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"}