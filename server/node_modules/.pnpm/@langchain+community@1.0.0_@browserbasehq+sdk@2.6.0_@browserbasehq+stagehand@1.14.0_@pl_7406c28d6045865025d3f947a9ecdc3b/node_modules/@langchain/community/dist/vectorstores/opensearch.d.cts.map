{"version":3,"file":"opensearch.d.cts","names":["Client","EmbeddingsInterface","VectorStore","Document","OpenSearchEngine","OpenSearchSpaceType","VectorSearchOptions","OpenSearchClientArgs","OpenSearchFilter","FilterTypeValue","Record","OpenSearchVectorStore","Promise"],"sources":["../../src/vectorstores/opensearch.d.ts"],"sourcesContent":["import { Client } from \"@opensearch-project/opensearch\";\nimport type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { VectorStore } from \"@langchain/core/vectorstores\";\nimport { Document } from \"@langchain/core/documents\";\ntype OpenSearchEngine = \"nmslib\" | \"hnsw\";\ntype OpenSearchSpaceType = \"l2\" | \"cosinesimil\" | \"ip\";\n/**\n * Interface defining the options for vector search in OpenSearch. It\n * includes the engine type, space type, and parameters for the HNSW\n * algorithm.\n */\ninterface VectorSearchOptions {\n    readonly engine?: OpenSearchEngine;\n    readonly spaceType?: OpenSearchSpaceType;\n    readonly m?: number;\n    readonly efConstruction?: number;\n    readonly efSearch?: number;\n    readonly numberOfShards?: number;\n    readonly numberOfReplicas?: number;\n}\n/**\n * Interface defining the arguments required to create an instance of the\n * OpenSearchVectorStore class. It includes the OpenSearch client, index\n * name, and vector search options.\n */\nexport interface OpenSearchClientArgs {\n    readonly client: Client;\n    readonly vectorFieldName?: string;\n    readonly textFieldName?: string;\n    readonly metadataFieldName?: string;\n    readonly service?: \"es\" | \"aoss\";\n    readonly indexName?: string;\n    readonly vectorSearchOptions?: VectorSearchOptions;\n}\n/**\n * Type alias for an object. It's used to define filters for OpenSearch\n * queries.\n */\ntype OpenSearchFilter = {\n    [key: string]: FilterTypeValue | (string | number)[] | string | number;\n};\n/**\n * FilterTypeValue for OpenSearch queries.\n */\ninterface FilterTypeValue {\n    exists?: boolean;\n    fuzzy?: string;\n    ids?: string[];\n    prefix?: string;\n    gte?: number;\n    gt?: number;\n    lte?: number;\n    lt?: number;\n    regexp?: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    terms_set?: Record<string, any>;\n    wildcard?: string;\n}\n/**\n * Class that provides a wrapper around the OpenSearch service for vector\n * search. It provides methods for adding documents and vectors to the\n * OpenSearch index, searching for similar vectors, and managing the\n * OpenSearch index.\n */\nexport declare class OpenSearchVectorStore extends VectorStore {\n    FilterType: OpenSearchFilter;\n    private readonly client;\n    private readonly indexName;\n    // if true, use the Amazon OpenSearch Serverless service instead of es\n    private readonly isAoss;\n    private readonly engine;\n    private readonly spaceType;\n    private readonly efConstruction;\n    private readonly efSearch;\n    private readonly numberOfShards;\n    private readonly numberOfReplicas;\n    private readonly m;\n    private readonly vectorFieldName;\n    private readonly textFieldName;\n    private readonly metadataFieldName;\n    _vectorstoreType(): string;\n    constructor(embeddings: EmbeddingsInterface, args: OpenSearchClientArgs);\n    /**\n     * Method to add documents to the OpenSearch index. It first converts the\n     * documents to vectors using the embeddings, then adds the vectors to the\n     * index.\n     * @param documents The documents to be added to the OpenSearch index.\n     * @returns Promise resolving to void.\n     */\n    addDocuments(documents: Document[]): Promise<void>;\n    /**\n     * Method to add vectors to the OpenSearch index. It ensures the index\n     * exists, then adds the vectors and associated documents to the index.\n     * @param vectors The vectors to be added to the OpenSearch index.\n     * @param documents The documents associated with the vectors.\n     * @param options Optional parameter that can contain the IDs for the documents.\n     * @returns Promise resolving to void.\n     */\n    addVectors(vectors: number[][], documents: Document[], options?: {\n        ids?: string[];\n    }): Promise<void>;\n    /**\n     * Method to perform a similarity search on the OpenSearch index using a\n     * query vector. It returns the k most similar documents and their scores.\n     * @param query The query vector.\n     * @param k The number of similar documents to return.\n     * @param filter Optional filter for the OpenSearch query.\n     * @returns Promise resolving to an array of tuples, each containing a Document and its score.\n     */\n    similaritySearchVectorWithScore(query: number[], k: number, filter?: OpenSearchFilter | undefined): Promise<[Document, number][]>;\n    /**\n     * Static method to create a new OpenSearchVectorStore from an array of\n     * texts, their metadata, embeddings, and OpenSearch client arguments.\n     * @param texts The texts to be converted into documents and added to the OpenSearch index.\n     * @param metadatas The metadata associated with the texts. Can be an array of objects or a single object.\n     * @param embeddings The embeddings used to convert the texts into vectors.\n     * @param args The OpenSearch client arguments.\n     * @returns Promise resolving to a new instance of OpenSearchVectorStore.\n     */\n    static fromTexts(texts: string[], metadatas: object[] | object, embeddings: EmbeddingsInterface, args: OpenSearchClientArgs): Promise<OpenSearchVectorStore>;\n    /**\n     * Static method to create a new OpenSearchVectorStore from an array of\n     * Documents, embeddings, and OpenSearch client arguments.\n     * @param docs The documents to be added to the OpenSearch index.\n     * @param embeddings The embeddings used to convert the documents into vectors.\n     * @param dbConfig The OpenSearch client arguments.\n     * @returns Promise resolving to a new instance of OpenSearchVectorStore.\n     */\n    static fromDocuments(docs: Document[], embeddings: EmbeddingsInterface, dbConfig: OpenSearchClientArgs): Promise<OpenSearchVectorStore>;\n    /**\n     * Static method to create a new OpenSearchVectorStore from an existing\n     * OpenSearch index, embeddings, and OpenSearch client arguments.\n     * @param embeddings The embeddings used to convert the documents into vectors.\n     * @param dbConfig The OpenSearch client arguments.\n     * @returns Promise resolving to a new instance of OpenSearchVectorStore.\n     */\n    static fromExistingIndex(embeddings: EmbeddingsInterface, dbConfig: OpenSearchClientArgs): Promise<OpenSearchVectorStore>;\n    private ensureIndexExists;\n    /**\n     * Builds metadata terms for OpenSearch queries.\n     *\n     * This function takes a filter object and constructs an array of query terms\n     * compatible with OpenSearch 2.x. It supports a variety of query types including\n     * term, terms, terms_set, ids, range, prefix, exists, fuzzy, wildcard, and regexp.\n     * Reference: https://opensearch.org/docs/latest/query-dsl/term/index/\n     *\n     * @param {Filter | null} filter - The filter object used to construct query terms.\n     * Each key represents a field, and the value specifies the type of query and its parameters.\n     *\n     * @returns {Array<Record<string, any>>} An array of OpenSearch query terms.\n     *\n     * @example\n     * // Example filter:\n     * const filter = {\n     *   status: { \"exists\": true },\n     *   age: { \"gte\": 30, \"lte\": 40 },\n     *   tags: [\"tag1\", \"tag2\"],\n     *   description: { \"wildcard\": \"*test*\" },\n     *\n     * };\n     *\n     * // Resulting query terms:\n     * const queryTerms = buildMetadataTerms(filter);\n     * // queryTerms would be an array of OpenSearch query objects.\n     */\n    buildMetadataTerms(filter: OpenSearchFilter | undefined): object;\n    /**\n     * Method to check if the OpenSearch index exists.\n     * @returns Promise resolving to a boolean indicating whether the index exists.\n     */\n    doesIndexExist(): Promise<boolean>;\n    /**\n     * Method to delete the OpenSearch index if it exists.\n     * @returns Promise resolving to void.\n     */\n    deleteIfExists(): Promise<void>;\n}\nexport {};\n"],"mappings":";;;;;;;;;KAIKI,gBAAAA;KACAC,mBAAAA;;;;;;UAMKC,mBAAAA;EAPLF,SAAAA,MAAAA,CAAAA,EAQiBA,gBARD;EAChBC,SAAAA,SAAAA,CAAAA,EAQoBA,mBARD;EAMdC,SAAAA,CAAAA,CAAAA,EAAAA,MAAAA;EAAmB,SAAA,cAAA,CAAA,EAAA,MAAA;EAAA,SACPF,QAAAA,CAAAA,EAAAA,MAAAA;EAAgB,SACbC,cAAAA,CAAAA,EAAAA,MAAAA;EAAmB,SAAA,gBAAA,CAAA,EAAA,MAAA;AAY5C;;;;AAOsD;AACrD;AAWSI,UAnBOF,oBAAAA,CA8BDG;EASKC,SAAAA,MAAAA,EAtCAX,MAsCAW;EAAqB,SAAA,eAAA,CAAA,EAAA,MAAA;EAAA,SAC1BH,aAAAA,CAAAA,EAAAA,MAAAA;EAAgB,SAgBJP,iBAAAA,CAAAA,EAAAA,MAAAA;EAAmB,SAAQM,OAAAA,CAAAA,EAAAA,IAAAA,GAAAA,MAAAA;EAAoB,SAQ/CJ,SAAAA,CAAAA,EAAAA,MAAAA;EAAQ,SAAKS,mBAAAA,CAAAA,EAzDNN,mBAyDMM;;;;;;KAnDpCJ,gBAAAA,GAiF2EP;EAAmB,CAAA,GAAQM,EAAAA,MAAAA,CAAAA,EAhFxFE,eAgFwFF,GAAAA,CAAAA,MAAAA,GAAAA,MAAAA,CAAAA,EAAAA,GAAAA,MAAAA,GAAAA,MAAAA;CAAoB;;;;UA3ErHE,eAAAA,CAoF4EF;EAAoB,MAAWI,CAAAA,EAAAA,OAAAA;EAAqB,KAA7BC,CAAAA,EAAAA,MAAAA;EAAO,GAQ3EX,CAAAA,EAAAA,MAAAA,EAAAA;EAAmB,MAAYM,CAAAA,EAAAA,MAAAA;EAAoB,GAAWI,CAAAA,EAAAA,MAAAA;EAAqB,EAAA,CAA7BC,EAAAA,MAAAA;EAAO,GA6BvEJ,CAAAA,EAAAA,MAAAA;EAAgB,EAAA,CAKzBI,EAAAA,MAAAA;EAAO,MAKPA,CAAAA,EAAAA,MAAAA;EAAO;EA/GiC,SAAA,CAAA,EAT9CF,MAS8C,CAAA,MAAA,EAAA,GAAA,CAAA;;;;;;;;;cAAzCC,qBAAAA,SAA8BT,WAAAA;cACnCM;;;;;;;;;;;;;;;;0BAgBYP,2BAA2BM;;;;;;;;0BAQ3BJ,aAAaS;;;;;;;;;6CASMT;;MAEvCS;;;;;;;;;uEASiEJ,+BAA+BI,SAAST;;;;;;;;;;8EAUjCF,2BAA2BM,uBAAuBK,QAAQD;;;;;;;;;6BAS3GR,wBAAwBF,+BAA+BM,uBAAuBK,QAAQD;;;;;;;;uCAQ5EV,+BAA+BM,uBAAuBK,QAAQD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BA6BxEH;;;;;oBAKTI;;;;;oBAKAA"}