{"version":3,"file":"tensorflow.js","names":["fields?: TensorFlowEmbeddingsParams","texts: string[]","document: string","documents: string[]"],"sources":["../../src/embeddings/tensorflow.ts"],"sourcesContent":["import { load } from \"@tensorflow-models/universal-sentence-encoder\";\nimport * as tf from \"@tensorflow/tfjs-core\";\n\nimport { Embeddings, type EmbeddingsParams } from \"@langchain/core/embeddings\";\n\n/**\n * Interface that extends EmbeddingsParams and defines additional\n * parameters specific to the TensorFlowEmbeddings class.\n */\nexport interface TensorFlowEmbeddingsParams extends EmbeddingsParams {}\n\n/**\n * Class that extends the Embeddings class and provides methods for\n * generating embeddings using the Universal Sentence Encoder model from\n * TensorFlow.js.\n * @example\n * ```typescript\n * const embeddings = new TensorFlowEmbeddings();\n * const store = new MemoryVectorStore(embeddings);\n *\n * const documents = [\n *   \"A document\",\n *   \"Some other piece of text\",\n *   \"One more\",\n *   \"And another\",\n * ];\n *\n * await store.addDocuments(\n *   documents.map((pageContent) => new Document({ pageContent }))\n * );\n * ```\n */\nexport class TensorFlowEmbeddings extends Embeddings {\n  constructor(fields?: TensorFlowEmbeddingsParams) {\n    super(fields ?? {});\n\n    try {\n      tf.backend();\n    } catch {\n      throw new Error(\"No TensorFlow backend found, see instructions at ...\");\n    }\n  }\n\n  _cached: ReturnType<typeof load>;\n\n  /**\n   * Private method that loads the Universal Sentence Encoder model if it\n   * hasn't been loaded already. It returns a promise that resolves to the\n   * loaded model.\n   * @returns Promise that resolves to the loaded Universal Sentence Encoder model.\n   */\n  private async load() {\n    if (this._cached === undefined) {\n      this._cached = load();\n    }\n    return this._cached;\n  }\n\n  private _embed(texts: string[]) {\n    return this.caller.call(async () => {\n      const model = await this.load();\n      return model.embed(texts);\n    });\n  }\n\n  /**\n   * Method that takes a document as input and returns a promise that\n   * resolves to an embedding for the document. It calls the _embed method\n   * with the document as the input and processes the result to return a\n   * single embedding.\n   * @param document Document to generate an embedding for.\n   * @returns Promise that resolves to an embedding for the input document.\n   */\n  embedQuery(document: string): Promise<number[]> {\n    return this._embed([document])\n      .then((embeddings) => embeddings.array())\n      .then((embeddings) => embeddings[0]);\n  }\n\n  /**\n   * Method that takes an array of documents as input and returns a promise\n   * that resolves to a 2D array of embeddings for each document. It calls\n   * the _embed method with the documents as the input and processes the\n   * result to return the embeddings.\n   * @param documents Array of documents to generate embeddings for.\n   * @returns Promise that resolves to a 2D array of embeddings for each input document.\n   */\n  embedDocuments(documents: string[]): Promise<number[][]> {\n    return this._embed(documents).then((embeddings) => embeddings.array());\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA,IAAa,uBAAb,cAA0C,WAAW;CACnD,YAAYA,QAAqC;EAC/C,MAAM,UAAU,CAAE,EAAC;AAEnB,MAAI;GACF,GAAG,SAAS;EACb,QAAO;AACN,SAAM,IAAI,MAAM;EACjB;CACF;CAED;;;;;;;CAQA,MAAc,OAAO;AACnB,MAAI,KAAK,YAAY,QACnB,KAAK,UAAU,MAAM;AAEvB,SAAO,KAAK;CACb;CAED,AAAQ,OAAOC,OAAiB;AAC9B,SAAO,KAAK,OAAO,KAAK,YAAY;GAClC,MAAM,QAAQ,MAAM,KAAK,MAAM;AAC/B,UAAO,MAAM,MAAM,MAAM;EAC1B,EAAC;CACH;;;;;;;;;CAUD,WAAWC,UAAqC;AAC9C,SAAO,KAAK,OAAO,CAAC,QAAS,EAAC,CAC3B,KAAK,CAAC,eAAe,WAAW,OAAO,CAAC,CACxC,KAAK,CAAC,eAAe,WAAW,GAAG;CACvC;;;;;;;;;CAUD,eAAeC,WAA0C;AACvD,SAAO,KAAK,OAAO,UAAU,CAAC,KAAK,CAAC,eAAe,WAAW,OAAO,CAAC;CACvE;AACF"}