{"version":3,"file":"queryindexmanager.js","names":[],"sources":["../../../../../../../../../node_modules/.pnpm/couchbase@4.5.0/node_modules/couchbase/dist/queryindexmanager.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueryIndexManager = exports.CollectionQueryIndexManager = exports.QueryIndex = void 0;\nconst bindingutilities_1 = require(\"./bindingutilities\");\nconst errors_1 = require(\"./errors\");\nconst utilities_1 = require(\"./utilities\");\n/**\n * Contains a specific index configuration for the query service.\n *\n * @category Management\n */\nclass QueryIndex {\n    /**\n     * @internal\n     */\n    constructor(data) {\n        this.name = data.name;\n        this.isPrimary = data.isPrimary;\n        this.type = data.type;\n        this.state = data.state;\n        this.indexKey = data.indexKey;\n        this.condition = data.condition;\n        this.partition = data.partition;\n        this.collectionName = data.collectionName;\n        this.scopeName = data.scopeName;\n        this.bucketName = data.bucketName;\n    }\n}\nexports.QueryIndex = QueryIndex;\n/**\n * @internal\n */\nclass InternalQueryIndexManager {\n    /**\n     * @internal\n     */\n    constructor(cluster) {\n        this._cluster = cluster;\n        this._queryContext = {\n            bucket_name: '',\n            scope_name: '',\n        };\n    }\n    /**\n     * @internal\n     */\n    async createIndex(bucketName, isPrimary, options, callback) {\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementQueryIndexCreate({\n                bucket_name: bucketName,\n                scope_name: options.scopeName || '',\n                collection_name: options.collectionName || '',\n                index_name: options.name || '',\n                keys: options.keys || [],\n                query_ctx: options.queryContext || this._queryContext,\n                is_primary: isPrimary,\n                ignore_if_exists: options.ignoreIfExists || false,\n                deferred: options.deferred,\n                num_replicas: options.numReplicas,\n                timeout: timeout,\n                condition: undefined,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * @internal\n     */\n    async dropIndex(bucketName, isPrimary, options, callback) {\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        // BUG(JSCBC-1066): We need to use a normal drop index for named primary indexes.\n        if (options.name) {\n            isPrimary = false;\n        }\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementQueryIndexDrop({\n                bucket_name: bucketName,\n                scope_name: options.scopeName || '',\n                collection_name: options.collectionName || '',\n                index_name: options.name || '',\n                query_ctx: options.queryContext || this._queryContext,\n                is_primary: isPrimary,\n                ignore_if_does_not_exist: options.ignoreIfNotExists || false,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * @internal\n     */\n    async getAllIndexes(bucketName, options, callback) {\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementQueryIndexGetAll({\n                bucket_name: bucketName,\n                scope_name: options.scopeName || '',\n                collection_name: options.collectionName || '',\n                query_ctx: options.queryContext || this._queryContext,\n                timeout: timeout,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                const indexes = resp.indexes.map((row) => new QueryIndex({\n                    isPrimary: row.is_primary,\n                    name: row.name,\n                    state: row.state,\n                    type: row.type,\n                    indexKey: row.index_key,\n                    partition: row.partition,\n                    condition: row.condition,\n                    bucketName: row.bucket_name,\n                    scopeName: row.scope_name,\n                    collectionName: row.collection_name,\n                }));\n                wrapCallback(null, indexes);\n            });\n        }, callback);\n    }\n    /**\n     * @internal\n     */\n    async buildDeferredIndexes(bucketName, options, callback) {\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementQueryIndexBuildDeferred({\n                bucket_name: bucketName,\n                scope_name: options.scopeName || '',\n                collection_name: options.collectionName || '',\n                query_ctx: options.queryContext || this._queryContext,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(null, null);\n            });\n        }, callback);\n    }\n    /**\n     * @internal\n     */\n    async watchIndexes(bucketName, indexNames, timeout, options, callback) {\n        if (options.watchPrimary) {\n            indexNames = [...indexNames, '#primary'];\n        }\n        const timer = new utilities_1.CompoundTimeout(timeout);\n        return utilities_1.PromiseHelper.wrapAsync(async () => {\n            let curInterval = 50;\n            for (;;) {\n                // Get all the indexes that are currently registered\n                const foundIdxs = await this.getAllIndexes(bucketName, {\n                    timeout: timer.left(),\n                });\n                const foundIndexNames = foundIdxs.map((idx) => idx.name);\n                const onlineIdxs = foundIdxs.filter((idx) => idx.state === 'online');\n                const onlineIdxNames = onlineIdxs.map((idx) => idx.name);\n                // Check if all the indexes we want are online\n                let allOnline = true;\n                indexNames.forEach((indexName) => {\n                    if (!foundIndexNames.includes(indexName)) {\n                        throw new errors_1.IndexNotFoundError(new Error(`Cannot find index with name ${indexName}`));\n                    }\n                    allOnline = allOnline && onlineIdxNames.indexOf(indexName) !== -1;\n                });\n                // If all the indexes are online, we've succeeded\n                if (allOnline) {\n                    break;\n                }\n                // Add 500 to our interval to a max of 1000\n                curInterval = Math.min(1000, curInterval + 500);\n                // Make sure we don't go past our user-specified duration\n                const userTimeLeft = timer.left();\n                if (userTimeLeft !== undefined) {\n                    curInterval = Math.min(curInterval, userTimeLeft);\n                }\n                if (curInterval <= 0) {\n                    throw new errors_1.CouchbaseError('Failed to find all indexes online within the alloted time.');\n                }\n                // Wait until curInterval expires\n                await new Promise((resolve) => setTimeout(() => resolve(true), curInterval));\n            }\n        }, callback);\n    }\n}\n/**\n * CollectionQueryIndexManager provides an interface for managing the\n * query indexes on the collection.\n *\n * @category Management\n */\nclass CollectionQueryIndexManager {\n    /**\n     * @internal\n     */\n    constructor(collection) {\n        this._bucketName = collection.scope.bucket.name;\n        this._collectionName = collection.name;\n        this._scopeName = collection.scope.name;\n        this._manager = new InternalQueryIndexManager(collection.cluster);\n    }\n    /**\n     * Creates a new query index.\n     *\n     * @param indexName The name of the new index.\n     * @param keys The keys which this index should cover.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async createIndex(indexName, keys, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[2];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        return this._manager.createIndex(this._bucketName, false, {\n            collectionName: this._collectionName,\n            scopeName: this._scopeName,\n            name: indexName,\n            keys: keys,\n            ignoreIfExists: options.ignoreIfExists,\n            numReplicas: options.numReplicas,\n            deferred: options.deferred,\n            timeout: options.timeout,\n        }, callback);\n    }\n    /**\n     * Creates a new primary query index.\n     *\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async createPrimaryIndex(options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[0];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        return this._manager.createIndex(this._bucketName, true, {\n            collectionName: this._collectionName,\n            scopeName: this._scopeName,\n            name: options.name,\n            ignoreIfExists: options.ignoreIfExists,\n            deferred: options.deferred,\n            timeout: options.timeout,\n        }, callback);\n    }\n    /**\n     * Drops an existing query index.\n     *\n     * @param indexName The name of the index to drop.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async dropIndex(indexName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        return this._manager.dropIndex(this._bucketName, false, {\n            collectionName: this._collectionName,\n            scopeName: this._scopeName,\n            name: indexName,\n            ignoreIfNotExists: options.ignoreIfNotExists,\n            timeout: options.timeout,\n        }, callback);\n    }\n    /**\n     * Drops an existing primary index.\n     *\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async dropPrimaryIndex(options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[0];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        return this._manager.dropIndex(this._bucketName, true, {\n            collectionName: this._collectionName,\n            scopeName: this._scopeName,\n            name: options.name,\n            ignoreIfNotExists: options.ignoreIfNotExists,\n            timeout: options.timeout,\n        }, callback);\n    }\n    /**\n     * Returns a list of indexes for a specific bucket.\n     *\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async getAllIndexes(options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[0];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        return this._manager.getAllIndexes(this._bucketName, {\n            collectionName: this._collectionName,\n            scopeName: this._scopeName,\n            timeout: options.timeout,\n        }, callback);\n    }\n    /**\n     * Starts building any indexes which were previously created with deferred=true.\n     *\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async buildDeferredIndexes(options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[0];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        return this._manager.buildDeferredIndexes(this._bucketName, {\n            collectionName: this._collectionName,\n            scopeName: this._scopeName,\n            timeout: options.timeout,\n        }, callback);\n    }\n    /**\n     * Waits for a number of indexes to finish creation and be ready to use.\n     *\n     * @param indexNames The names of the indexes to watch.\n     * @param timeout The maximum time to wait for the index, expressed in milliseconds.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async watchIndexes(indexNames, timeout, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[2];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        return this._manager.watchIndexes(this._bucketName, indexNames, timeout, {\n            collectionName: this._collectionName,\n            scopeName: this._scopeName,\n            watchPrimary: options.watchPrimary,\n        }, callback);\n    }\n}\nexports.CollectionQueryIndexManager = CollectionQueryIndexManager;\n/**\n * QueryIndexManager provides an interface for managing the\n * query indexes on the cluster.\n *\n * @category Management\n */\nclass QueryIndexManager {\n    /**\n     * @internal\n     */\n    constructor(cluster) {\n        this._manager = new InternalQueryIndexManager(cluster);\n    }\n    /**\n     * Creates a new query index.\n     *\n     * @param bucketName The name of the bucket this index is for.\n     * @param indexName The name of the new index.\n     * @param keys The keys which this index should cover.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async createIndex(bucketName, indexName, keys, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[3];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        return this._manager.createIndex(bucketName, false, {\n            collectionName: options.collectionName,\n            scopeName: options.scopeName,\n            name: indexName,\n            keys: keys,\n            ignoreIfExists: options.ignoreIfExists,\n            numReplicas: options.numReplicas,\n            deferred: options.deferred,\n            timeout: options.timeout,\n        }, callback);\n    }\n    /**\n     * Creates a new primary query index.\n     *\n     * @param bucketName The name of the bucket this index is for.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async createPrimaryIndex(bucketName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        return this._manager.createIndex(bucketName, true, {\n            collectionName: options.collectionName,\n            scopeName: options.scopeName,\n            name: options.name,\n            ignoreIfExists: options.ignoreIfExists,\n            deferred: options.deferred,\n            timeout: options.timeout,\n        }, callback);\n    }\n    /**\n     * Drops an existing query index.\n     *\n     * @param bucketName The name of the bucket containing the index to drop.\n     * @param indexName The name of the index to drop.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async dropIndex(bucketName, indexName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[2];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        return this._manager.dropIndex(bucketName, false, {\n            collectionName: options.collectionName,\n            scopeName: options.scopeName,\n            name: indexName,\n            ignoreIfNotExists: options.ignoreIfNotExists,\n            timeout: options.timeout,\n        }, callback);\n    }\n    /**\n     * Drops an existing primary index.\n     *\n     * @param bucketName The name of the bucket containing the primary index to drop.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async dropPrimaryIndex(bucketName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        return this._manager.dropIndex(bucketName, true, {\n            collectionName: options.collectionName,\n            scopeName: options.scopeName,\n            name: options.name,\n            ignoreIfNotExists: options.ignoreIfNotExists,\n            timeout: options.timeout,\n        }, callback);\n    }\n    /**\n     * Returns a list of indexes for a specific bucket.\n     *\n     * @param bucketName The name of the bucket to fetch indexes for.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async getAllIndexes(bucketName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        return this._manager.getAllIndexes(bucketName, {\n            collectionName: options.collectionName,\n            scopeName: options.scopeName,\n            timeout: options.timeout,\n        }, callback);\n    }\n    /**\n     * Starts building any indexes which were previously created with deferred=true.\n     *\n     * @param bucketName The name of the bucket to perform the build on.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async buildDeferredIndexes(bucketName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        return this._manager.buildDeferredIndexes(bucketName, {\n            collectionName: options.collectionName,\n            scopeName: options.scopeName,\n            timeout: options.timeout,\n        }, callback);\n    }\n    /**\n     * Waits for a number of indexes to finish creation and be ready to use.\n     *\n     * @param bucketName The name of the bucket to watch for indexes on.\n     * @param indexNames The names of the indexes to watch.\n     * @param timeout The maximum time to wait for the index, expressed in milliseconds.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async watchIndexes(bucketName, indexNames, timeout, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[3];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        return this._manager.watchIndexes(bucketName, indexNames, timeout, {\n            collectionName: options.collectionName,\n            scopeName: options.scopeName,\n            watchPrimary: options.watchPrimary,\n        }, callback);\n    }\n}\nexports.QueryIndexManager = QueryIndexManager;\n"],"x_google_ignoreList":[0],"mappings":"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"}