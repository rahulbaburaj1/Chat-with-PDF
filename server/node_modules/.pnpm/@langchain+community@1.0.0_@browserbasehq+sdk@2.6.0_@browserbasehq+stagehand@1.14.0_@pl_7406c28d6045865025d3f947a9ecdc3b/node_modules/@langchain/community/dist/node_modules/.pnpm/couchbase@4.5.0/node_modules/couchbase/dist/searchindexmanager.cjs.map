{"version":3,"file":"searchindexmanager.cjs","names":[],"sources":["../../../../../../../../../node_modules/.pnpm/couchbase@4.5.0/node_modules/couchbase/dist/searchindexmanager.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SearchIndexManager = exports.SearchIndex = void 0;\nconst utilities_1 = require(\"./utilities\");\nconst bindingutilities_1 = require(\"./bindingutilities\");\n/**\n * This class is currently incomplete and must be casted to `any` in\n * TypeScript to be used.\n *\n * @category Management\n */\nclass SearchIndex {\n    /**\n     * @internal\n     */\n    constructor(data) {\n        this.uuid = data.uuid;\n        this.name = data.name;\n        this.sourceName = data.sourceName;\n        this.type = data.type;\n        this.params = data.params;\n        this.sourceUuid = data.sourceUuid;\n        this.sourceParams = data.sourceParams;\n        this.sourceType = data.sourceType;\n        this.planParams = data.planParams;\n    }\n    /**\n     * @internal\n     */\n    static _toCppData(data) {\n        return {\n            uuid: data.uuid,\n            name: data.name,\n            type: data.type,\n            params_json: JSON.stringify(data.params),\n            source_uuid: data.sourceUuid,\n            source_name: data.sourceName,\n            source_type: data.sourceType,\n            source_params_json: JSON.stringify(data.sourceParams),\n            plan_params_json: JSON.stringify(data.planParams),\n        };\n    }\n    /**\n     * @internal\n     */\n    static _fromCppData(data) {\n        const idx = new SearchIndex({\n            uuid: data.uuid,\n            name: data.name,\n            type: data.type,\n            params: {},\n            sourceUuid: data.source_uuid,\n            sourceName: data.source_name,\n            sourceType: data.source_type,\n            sourceParams: {},\n            planParams: {},\n        });\n        if (data.params_json) {\n            idx.params = JSON.parse(data.params_json);\n        }\n        if (data.source_params_json) {\n            idx.sourceParams = JSON.parse(data.source_params_json);\n        }\n        if (data.plan_params_json) {\n            idx.planParams = JSON.parse(data.plan_params_json);\n        }\n        return idx;\n    }\n}\nexports.SearchIndex = SearchIndex;\n/**\n * SearchIndexManager provides an interface for managing the\n * search indexes on the cluster.\n *\n * @category Management\n */\nclass SearchIndexManager {\n    /**\n     * @internal\n     */\n    constructor(cluster) {\n        this._cluster = cluster;\n    }\n    /**\n     * Returns an index by it's name.\n     *\n     * @param indexName The index to retrieve.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async getIndex(indexName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexGet({\n                index_name: indexName,\n                timeout: timeout,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                const index = SearchIndex._fromCppData(resp.index);\n                wrapCallback(null, index);\n            });\n        }, callback);\n    }\n    /**\n     * Returns a list of all existing indexes.\n     *\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async getAllIndexes(options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[0];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexGetAll({\n                timeout: timeout,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                const indexes = resp.indexes.map((indexData) => SearchIndex._fromCppData(indexData));\n                wrapCallback(null, indexes);\n            });\n        }, callback);\n    }\n    /**\n     * Creates or updates an existing index.\n     *\n     * @param indexDefinition The index to update.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async upsertIndex(indexDefinition, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexUpsert({\n                index: SearchIndex._toCppData(indexDefinition),\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Drops an index.\n     *\n     * @param indexName The name of the index to drop.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async dropIndex(indexName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexDrop({\n                index_name: indexName,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Returns the number of documents that have been indexed.\n     *\n     * @param indexName The name of the index to return the count for.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async getIndexedDocumentsCount(indexName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexGetDocumentsCount({\n                index_name: indexName,\n                timeout: timeout,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(null, resp.count);\n            });\n        }, callback);\n    }\n    /**\n     * Pauses the ingestion of documents into an index.\n     *\n     * @param indexName The name of the index to pause.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async pauseIngest(indexName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexControlIngest({\n                index_name: indexName,\n                pause: true,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Resumes the ingestion of documents into an index.\n     *\n     * @param indexName The name of the index to resume.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async resumeIngest(indexName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexControlIngest({\n                index_name: indexName,\n                pause: false,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Enables querying of an index.\n     *\n     * @param indexName The name of the index to enable querying for.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async allowQuerying(indexName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexControlQuery({\n                index_name: indexName,\n                allow: true,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Disables querying of an index.\n     *\n     * @param indexName The name of the index to disable querying for.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async disallowQuerying(indexName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexControlQuery({\n                index_name: indexName,\n                allow: false,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Freezes the indexing plan for execution of queries.\n     *\n     * @param indexName The name of the index to freeze the plan of.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async freezePlan(indexName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexControlPlanFreeze({\n                index_name: indexName,\n                freeze: true,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Unfreezes the indexing plan for execution of queries.\n     *\n     * @param indexName The name of the index to freeze the plan of.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async unfreezePlan(indexName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexControlPlanFreeze({\n                index_name: indexName,\n                freeze: false,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Performs analysis of a specific document by an index.\n     *\n     * @param indexName The name of the index to use for the analysis.\n     * @param document The document to analyze.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async analyzeDocument(indexName, document, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[2];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementSearchIndexAnalyzeDocument({\n                index_name: indexName,\n                encoded_document: JSON.stringify(document),\n                timeout: timeout,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                const result = JSON.parse(resp.analysis);\n                wrapCallback(result, null);\n            });\n        }, callback);\n    }\n}\nexports.SearchIndexManager = SearchIndexManager;\n"],"x_google_ignoreList":[0],"mappings":"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"}