{"version":3,"file":"base.cjs","names":["StructuredTool","auth","google","payload: gmail_v1.Schema$MessagePart | undefined","body: string"],"sources":["../../../src/tools/gmail/base.ts"],"sourcesContent":["import { gmail_v1, google } from \"googleapis\";\nimport { StructuredTool } from \"@langchain/core/tools\";\nimport { getEnvironmentVariable } from \"@langchain/core/utils/env\";\n\nexport interface GmailBaseToolParams {\n  credentials?: {\n    clientEmail?: string;\n    privateKey?: string;\n    keyfile?: string;\n    subject?: string;\n    // support string and async function to handle token validation and expiration\n    accessToken?: string | (() => Promise<string>);\n  };\n  scopes?: string[];\n}\n\nexport abstract class GmailBaseTool extends StructuredTool {\n  name = \"Gmail\";\n\n  description = \"A tool to send and view emails through Gmail\";\n\n  protected params: GmailBaseToolParams;\n\n  protected gmail?: gmail_v1.Gmail;\n\n  constructor(\n    { credentials, scopes }: GmailBaseToolParams = {\n      credentials: {\n        clientEmail: getEnvironmentVariable(\"GMAIL_CLIENT_EMAIL\"),\n        privateKey: getEnvironmentVariable(\"GMAIL_PRIVATE_KEY\"),\n        keyfile: getEnvironmentVariable(\"GMAIL_KEYFILE\"),\n        subject: getEnvironmentVariable(\"GMAIL_SUBJECT\"),\n      },\n      scopes: [\"https://mail.google.com/\"],\n    }\n  ) {\n    super(...arguments);\n\n    if (!credentials) {\n      throw new Error(\"Missing credentials to authenticate to Gmail\");\n    }\n\n    if (!credentials.accessToken) {\n      if (!credentials.clientEmail) {\n        throw new Error(\"Missing GMAIL_CLIENT_EMAIL to interact with Gmail\");\n      }\n\n      if (!credentials.privateKey && !credentials.keyfile) {\n        throw new Error(\n          \"Missing GMAIL_PRIVATE_KEY or GMAIL_KEYFILE or accessToken to interact with Gmail\"\n        );\n      }\n    }\n\n    this.params = { credentials, scopes };\n  }\n\n  async getGmailClient() {\n    const { credentials, scopes } = this.params;\n\n    if (credentials?.accessToken) {\n      // always return a new instance so that we don't end up using expired access tokens\n      const auth = new google.auth.OAuth2();\n      const accessToken =\n        typeof credentials.accessToken === \"function\"\n          ? await credentials.accessToken()\n          : credentials.accessToken;\n\n      auth.setCredentials({\n        // get fresh access token if a function is provided\n        access_token: accessToken,\n      });\n      return google.gmail({ version: \"v1\", auth });\n    }\n\n    // when not using access token its ok to use singleton instance\n    if (this.gmail) {\n      return this.gmail;\n    }\n\n    const auth = new google.auth.JWT(\n      credentials?.clientEmail,\n      credentials?.keyfile,\n      credentials?.privateKey,\n      scopes,\n      credentials?.subject\n    );\n\n    this.gmail = google.gmail({ version: \"v1\", auth });\n    return this.gmail;\n  }\n\n  parseHeaderAndBody(payload: gmail_v1.Schema$MessagePart | undefined) {\n    if (!payload) {\n      return { body: \"\" };\n    }\n\n    const headers = payload.headers || [];\n\n    const subject = headers.find((header) => header.name === \"Subject\");\n    const sender = headers.find((header) => header.name === \"From\");\n\n    let body = \"\";\n    if (payload.parts) {\n      body = payload.parts\n        .map((part) =>\n          part.mimeType === \"text/plain\"\n            ? this.decodeBody(part.body?.data ?? \"\")\n            : \"\"\n        )\n        .join(\"\");\n    } else if (payload.body?.data) {\n      body = this.decodeBody(payload.body.data);\n    }\n\n    return { subject, sender, body };\n  }\n\n  decodeBody(body: string) {\n    if (body) {\n      try {\n        // Gmail uses URL-safe base64 encoding, so we need to handle it properly\n        // Replace URL-safe characters and decode\n        return atob(body.replace(/-/g, \"+\").replace(/_/g, \"/\"));\n      } catch {\n        // Keep the original encoded body if decoding fails\n        return body;\n      }\n    }\n    return \"\";\n  }\n}\n"],"mappings":";;;;;;AAgBA,IAAsB,gBAAtB,cAA4CA,sCAAe;CACzD,OAAO;CAEP,cAAc;CAEd,AAAU;CAEV,AAAU;CAEV,YACE,EAAE,aAAa,QAA6B,GAAG;EAC7C,aAAa;GACX,oEAAoC,qBAAqB;GACzD,mEAAmC,oBAAoB;GACvD,gEAAgC,gBAAgB;GAChD,gEAAgC,gBAAgB;EACjD;EACD,QAAQ,CAAC,0BAA2B;CACrC,GACD;EACA,MAAM,GAAG,UAAU;AAEnB,MAAI,CAAC,YACH,OAAM,IAAI,MAAM;AAGlB,MAAI,CAAC,YAAY,aAAa;AAC5B,OAAI,CAAC,YAAY,YACf,OAAM,IAAI,MAAM;AAGlB,OAAI,CAAC,YAAY,cAAc,CAAC,YAAY,QAC1C,OAAM,IAAI,MACR;EAGL;EAED,KAAK,SAAS;GAAE;GAAa;EAAQ;CACtC;CAED,MAAM,iBAAiB;EACrB,MAAM,EAAE,aAAa,QAAQ,GAAG,KAAK;AAErC,MAAI,aAAa,aAAa;GAE5B,MAAMC,SAAO,IAAIC,kBAAO,KAAK;GAC7B,MAAM,cACJ,OAAO,YAAY,gBAAgB,aAC/B,MAAM,YAAY,aAAa,GAC/B,YAAY;GAElBD,OAAK,eAAe,EAElB,cAAc,YACf,EAAC;AACF,UAAOC,kBAAO,MAAM;IAAE,SAAS;IAAM;GAAM,EAAC;EAC7C;AAGD,MAAI,KAAK,MACP,QAAO,KAAK;EAGd,MAAM,OAAO,IAAIA,kBAAO,KAAK,IAC3B,aAAa,aACb,aAAa,SACb,aAAa,YACb,QACA,aAAa;EAGf,KAAK,QAAQA,kBAAO,MAAM;GAAE,SAAS;GAAM;EAAM,EAAC;AAClD,SAAO,KAAK;CACb;CAED,mBAAmBC,SAAkD;AACnE,MAAI,CAAC,QACH,QAAO,EAAE,MAAM,GAAI;EAGrB,MAAM,UAAU,QAAQ,WAAW,CAAE;EAErC,MAAM,UAAU,QAAQ,KAAK,CAAC,WAAW,OAAO,SAAS,UAAU;EACnE,MAAM,SAAS,QAAQ,KAAK,CAAC,WAAW,OAAO,SAAS,OAAO;EAE/D,IAAI,OAAO;AACX,MAAI,QAAQ,OACV,OAAO,QAAQ,MACZ,IAAI,CAAC,SACJ,KAAK,aAAa,eACd,KAAK,WAAW,KAAK,MAAM,QAAQ,GAAG,GACtC,GACL,CACA,KAAK,GAAG;WACF,QAAQ,MAAM,MACvB,OAAO,KAAK,WAAW,QAAQ,KAAK,KAAK;AAG3C,SAAO;GAAE;GAAS;GAAQ;EAAM;CACjC;CAED,WAAWC,MAAc;AACvB,MAAI,KACF,KAAI;AAGF,UAAO,KAAK,KAAK,QAAQ,MAAM,IAAI,CAAC,QAAQ,MAAM,IAAI,CAAC;EACxD,QAAO;AAEN,UAAO;EACR;AAEH,SAAO;CACR;AACF"}