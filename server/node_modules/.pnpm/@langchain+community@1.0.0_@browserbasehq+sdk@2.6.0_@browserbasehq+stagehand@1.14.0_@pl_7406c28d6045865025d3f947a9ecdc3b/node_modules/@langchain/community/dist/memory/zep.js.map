{"version":3,"file":"zep.js","names":["memory: ZepMemoryData","messages: BaseMessage[]","BaseChatMemory","fields: ZepMemoryInput","values: InputValues","memory: BaseMemory | null","memoryData: ZepMemoryData","msg: Message","inputValues: InputValues","outputValues: OutputValues","BaseMemory"],"sources":["../../src/memory/zep.ts"],"sourcesContent":["import {\n  Memory as BaseMemory,\n  Message,\n  NotFoundError,\n  ZepClient,\n} from \"@getzep/zep-js\";\nimport {\n  InputValues,\n  OutputValues,\n  MemoryVariables,\n  getInputValue,\n  getOutputValue,\n} from \"@langchain/core/memory\";\nimport {\n  getBufferString,\n  AIMessage,\n  BaseMessage,\n  ChatMessage,\n  HumanMessage,\n  SystemMessage,\n} from \"@langchain/core/messages\";\nimport { BaseChatMemory, BaseChatMemoryInput } from \"./chat_memory.js\";\n\n// Simple type for processed Zep memory data\ninterface ZepMemoryData {\n  messages: Array<{\n    role: string;\n    content: string;\n  }>;\n  summary?: {\n    content?: string;\n  };\n}\n\n/**\n * Extracts summary from Zep memory and composes a system prompt.\n * @param memory - The memory object containing potential summary.\n * @returns A string containing the summary as a system prompt.\n */\nexport const zepMemoryContextToSystemPrompt = (memory: ZepMemoryData) => {\n  let systemPrompt = \"\";\n\n  // Extract summary, if present\n  if (memory.summary && memory.summary?.content) {\n    systemPrompt += memory.summary.content;\n  }\n\n  return systemPrompt;\n};\n\n/**\n * Condenses Zep memory context into a single HumanMessage.\n * This is particularly useful for models like Claude that have limitations with system messages\n * (e.g., Anthropic's Claude only supports one system message and doesn't support multiple user messages in a row).\n *\n * @param memory - The memory object containing conversation history.\n * @param humanPrefix - The prefix to use for human messages (default: \"Human\").\n * @param aiPrefix - The prefix to use for AI messages (default: \"AI\").\n * @returns A HumanMessage containing the condensed memory context.\n */\nexport const condenseZepMemoryIntoHumanMessage = (memory: ZepMemoryData) => {\n  const systemPrompt = zepMemoryContextToSystemPrompt(memory);\n\n  let concatMessages = \"\";\n\n  // Add message history to the prompt, if present\n  if (memory.messages) {\n    concatMessages = memory.messages\n      .map((msg) => `${msg.role}: ${msg.content}`)\n      .join(\"\\n\");\n  }\n\n  return new HumanMessage(\n    `${systemPrompt ? `${systemPrompt}\\n` : \"\"}${concatMessages}`\n  );\n};\n\n/**\n * Converts Zep Memory to a list of BaseMessages, preserving the structure.\n * Creates a SystemMessage from summary and facts, and converts the rest of the messages\n * to their corresponding message types.\n *\n * @param memory - The memory object containing conversation history.\n * @param humanPrefix - The prefix to use for human messages (default: \"Human\").\n * @param aiPrefix - The prefix to use for AI messages (default: \"AI\").\n * @returns An array of BaseMessage objects representing the conversation history.\n */\nexport const zepMemoryToMessages = (\n  memory: ZepMemoryData,\n  humanPrefix = \"Human\",\n  aiPrefix = \"AI\"\n) => {\n  const systemPrompt = zepMemoryContextToSystemPrompt(memory);\n\n  let messages: BaseMessage[] = systemPrompt\n    ? [new SystemMessage(systemPrompt)]\n    : [];\n\n  if (memory && memory.messages) {\n    messages = messages.concat(\n      memory.messages\n        .filter((m) => m.content)\n        .map((message) => {\n          const { content, role } = message;\n          if (role === humanPrefix) {\n            return new HumanMessage(content);\n          } else if (role === aiPrefix) {\n            return new AIMessage(content);\n          } else {\n            // default to generic ChatMessage\n            return new ChatMessage(content, role);\n          }\n        })\n    );\n  }\n\n  return messages;\n};\n\n/**\n * Interface defining the structure of the input data for the ZepMemory\n * class. It includes properties like humanPrefix, aiPrefix, memoryKey,\n * baseURL, sessionId, apiKey, and separateMessages.\n */\nexport interface ZepMemoryInput extends BaseChatMemoryInput {\n  humanPrefix?: string;\n\n  aiPrefix?: string;\n\n  memoryKey?: string;\n\n  baseURL: string;\n\n  sessionId: string;\n\n  // apiKey is optional.\n  apiKey?: string;\n\n  /**\n   * Whether to return separate messages for chat history with a SystemMessage containing facts and summary,\n   * or return a single HumanMessage with the entire memory context.\n   * Defaults to true (preserving message types) for backward compatibility.\n   *\n   * Keep as true for models that fully support system messages.\n   * Set to false for models like Claude that have limitations with system messages.\n   */\n  separateMessages?: boolean;\n}\n\n/**\n * Class used to manage the memory of a chat session, including loading\n * and saving the chat history, and clearing the memory when needed. It\n * uses the ZepClient to interact with the Zep service for managing the\n * chat session's memory.\n *\n * The class provides options for handling different LLM requirements:\n * - Use separateMessages=true (default) for models that fully support system messages\n * - Use separateMessages=false for models like Claude that have limitations with system messages\n *\n * @example\n * ```typescript\n * const sessionId = randomUUID();\n * const zepURL = \"http://your-zep-url\";\n *\n * // Initialize ZepMemory with session ID, base URL, and API key\n * const memory = new ZepMemory({\n *   sessionId,\n *   baseURL: zepURL,\n *   apiKey: \"change_this_key\",\n *   // Set to false for models like Claude that have limitations with system messages\n *   // Defaults to true for backward compatibility\n *   separateMessages: false,\n * });\n *\n * // Create a ChatOpenAI model instance with specific parameters\n * const model = new ChatOpenAI({\n *   model: \"gpt-3.5-turbo\",\n *   temperature: 0,\n * });\n *\n * // Create a ConversationChain with the model and memory\n * const chain = new ConversationChain({ llm: model, memory });\n *\n * // Example of calling the chain with an input\n * const res1 = await chain.call({ input: \"Hi! I'm Jim.\" });\n * console.log({ res1 });\n *\n * // Follow-up call to the chain to demonstrate memory usage\n * const res2 = await chain.call({ input: \"What did I just say my name was?\" });\n * console.log({ res2 });\n *\n * // Output the session ID and the current state of memory\n * console.log(\"Session ID: \", sessionId);\n * console.log(\"Memory: \", await memory.loadMemoryVariables({}));\n *\n * ```\n */\nexport class ZepMemory extends BaseChatMemory implements ZepMemoryInput {\n  humanPrefix = \"Human\";\n\n  aiPrefix = \"AI\";\n\n  memoryKey = \"history\";\n\n  baseURL: string;\n\n  sessionId: string;\n\n  zepClientPromise: Promise<ZepClient>;\n\n  private readonly zepInitFailMsg = \"ZepClient is not initialized\";\n\n  /**\n   * Whether to return separate messages for chat history with a SystemMessage containing facts and summary,\n   * or return a single HumanMessage with the entire memory context.\n   * Defaults to true (preserving message types) for backward compatibility.\n   *\n   * Keep as true for models that fully support system messages.\n   * Set to false for models like Claude that have limitations with system messages.\n   */\n  separateMessages: boolean;\n\n  constructor(fields: ZepMemoryInput) {\n    super({\n      returnMessages: fields?.returnMessages ?? false,\n      inputKey: fields?.inputKey,\n      outputKey: fields?.outputKey,\n    });\n\n    this.humanPrefix = fields.humanPrefix ?? this.humanPrefix;\n    this.aiPrefix = fields.aiPrefix ?? this.aiPrefix;\n    this.memoryKey = fields.memoryKey ?? this.memoryKey;\n    this.baseURL = fields.baseURL;\n    this.sessionId = fields.sessionId;\n    this.separateMessages = fields.separateMessages ?? true;\n    this.zepClientPromise = ZepClient.init(this.baseURL, fields.apiKey);\n  }\n\n  get memoryKeys() {\n    return [this.memoryKey];\n  }\n\n  /**\n   * Method that retrieves the chat history from the Zep service and formats\n   * it into a list of messages.\n   * @param values Input values for the method.\n   * @returns Promise that resolves with the chat history formatted into a list of messages.\n   */\n  async loadMemoryVariables(values: InputValues): Promise<MemoryVariables> {\n    // use either lastN provided by developer or undefined to use the\n    // server preset.\n\n    // Wait for ZepClient to be initialized\n    const zepClient = await this.zepClientPromise;\n    if (!zepClient) {\n      throw new Error(this.zepInitFailMsg);\n    }\n\n    const lastN = values.lastN ?? undefined;\n\n    let memory: BaseMemory | null = null;\n    try {\n      memory = await zepClient.memory.getMemory(this.sessionId, lastN);\n    } catch (error) {\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      if (error instanceof NotFoundError) {\n        const result = this.returnMessages\n          ? { [this.memoryKey]: [] }\n          : { [this.memoryKey]: \"\" };\n        return result;\n      } else {\n        throw error;\n      }\n    }\n\n    // Convert BaseMemory to ZepMemoryData\n    const memoryData: ZepMemoryData = {\n      messages:\n        memory?.messages.map((msg: Message) => ({\n          role: msg.role,\n          content: msg.content,\n        })) || [],\n      summary: memory?.summary,\n    };\n\n    if (this.returnMessages) {\n      return {\n        [this.memoryKey]: this.separateMessages\n          ? zepMemoryToMessages(memoryData, this.humanPrefix, this.aiPrefix)\n          : [condenseZepMemoryIntoHumanMessage(memoryData)],\n      };\n    }\n    return {\n      [this.memoryKey]: this.separateMessages\n        ? getBufferString(\n            zepMemoryToMessages(memoryData, this.humanPrefix, this.aiPrefix),\n            this.humanPrefix,\n            this.aiPrefix\n          )\n        : condenseZepMemoryIntoHumanMessage(memoryData).content,\n    };\n  }\n\n  /**\n   * Method that saves the input and output messages to the Zep service.\n   * @param inputValues Input messages to be saved.\n   * @param outputValues Output messages to be saved.\n   * @returns Promise that resolves when the messages have been saved.\n   */\n  async saveContext(\n    inputValues: InputValues,\n    outputValues: OutputValues\n  ): Promise<void> {\n    const input = getInputValue(inputValues, this.inputKey);\n    const output = getOutputValue(outputValues, this.outputKey);\n\n    // Create new Memory and Message instances\n    const memory = new BaseMemory({\n      messages: [\n        new Message({\n          role: this.humanPrefix,\n          content: `${input}`,\n        }),\n        new Message({\n          role: this.aiPrefix,\n          content: `${output}`,\n        }),\n      ],\n    });\n\n    // Wait for ZepClient to be initialized\n    const zepClient = await this.zepClientPromise;\n    if (!zepClient) {\n      throw new Error(this.zepInitFailMsg);\n    }\n\n    // Add the new memory to the session using the ZepClient\n    if (this.sessionId) {\n      try {\n        await zepClient.memory.addMemory(this.sessionId, memory);\n      } catch (error) {\n        console.error(\"Error adding memory: \", error);\n      }\n    }\n\n    // Call the superclass's saveContext method\n    await super.saveContext(inputValues, outputValues);\n  }\n\n  /**\n   * Method that deletes the chat history from the Zep service.\n   * @returns Promise that resolves when the chat history has been deleted.\n   */\n  async clear(): Promise<void> {\n    // Wait for ZepClient to be initialized\n    const zepClient = await this.zepClientPromise;\n    if (!zepClient) {\n      throw new Error(this.zepInitFailMsg);\n    }\n\n    try {\n      await zepClient.memory.deleteMemory(this.sessionId);\n    } catch (error) {\n      console.error(\"Error deleting session: \", error);\n    }\n\n    // Clear the superclass's chat history\n    await super.clear();\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAuCA,MAAa,iCAAiC,CAACA,WAA0B;CACvE,IAAI,eAAe;AAGnB,KAAI,OAAO,WAAW,OAAO,SAAS,SACpC,gBAAgB,OAAO,QAAQ;AAGjC,QAAO;AACR;;;;;;;;;;;AAYD,MAAa,oCAAoC,CAACA,WAA0B;CAC1E,MAAM,eAAe,+BAA+B,OAAO;CAE3D,IAAI,iBAAiB;AAGrB,KAAI,OAAO,UACT,iBAAiB,OAAO,SACrB,IAAI,CAAC,QAAQ,GAAG,IAAI,KAAK,EAAE,EAAE,IAAI,SAAS,CAAC,CAC3C,KAAK,KAAK;AAGf,QAAO,IAAI,aACT,GAAG,eAAe,GAAG,aAAa,EAAE,CAAC,GAAG,KAAK,gBAAgB;AAEhE;;;;;;;;;;;AAYD,MAAa,sBAAsB,CACjCA,QACA,cAAc,SACd,WAAW,SACR;CACH,MAAM,eAAe,+BAA+B,OAAO;CAE3D,IAAIC,WAA0B,eAC1B,CAAC,IAAI,cAAc,aAAc,IACjC,CAAE;AAEN,KAAI,UAAU,OAAO,UACnB,WAAW,SAAS,OAClB,OAAO,SACJ,OAAO,CAAC,MAAM,EAAE,QAAQ,CACxB,IAAI,CAAC,YAAY;EAChB,MAAM,EAAE,SAAS,MAAM,GAAG;AAC1B,MAAI,SAAS,YACX,QAAO,IAAI,aAAa;WACf,SAAS,SAClB,QAAO,IAAI,UAAU;MAGrB,QAAO,IAAI,YAAY,SAAS;CAEnC,EAAC,CACL;AAGH,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgFD,IAAa,YAAb,cAA+BC,mCAAyC;CACtE,cAAc;CAEd,WAAW;CAEX,YAAY;CAEZ;CAEA;CAEA;CAEA,AAAiB,iBAAiB;;;;;;;;;CAUlC;CAEA,YAAYC,QAAwB;EAClC,MAAM;GACJ,gBAAgB,QAAQ,kBAAkB;GAC1C,UAAU,QAAQ;GAClB,WAAW,QAAQ;EACpB,EAAC;EAEF,KAAK,cAAc,OAAO,eAAe,KAAK;EAC9C,KAAK,WAAW,OAAO,YAAY,KAAK;EACxC,KAAK,YAAY,OAAO,aAAa,KAAK;EAC1C,KAAK,UAAU,OAAO;EACtB,KAAK,YAAY,OAAO;EACxB,KAAK,mBAAmB,OAAO,oBAAoB;EACnD,KAAK,mBAAmB,UAAU,KAAK,KAAK,SAAS,OAAO,OAAO;CACpE;CAED,IAAI,aAAa;AACf,SAAO,CAAC,KAAK,SAAU;CACxB;;;;;;;CAQD,MAAM,oBAAoBC,QAA+C;EAKvE,MAAM,YAAY,MAAM,KAAK;AAC7B,MAAI,CAAC,UACH,OAAM,IAAI,MAAM,KAAK;EAGvB,MAAM,QAAQ,OAAO,SAAS;EAE9B,IAAIC,SAA4B;AAChC,MAAI;GACF,SAAS,MAAM,UAAU,OAAO,UAAU,KAAK,WAAW,MAAM;EACjE,SAAQ,OAAO;AAEd,OAAI,iBAAiB,eAAe;IAClC,MAAM,SAAS,KAAK,iBAChB,GAAG,KAAK,YAAY,CAAE,EAAE,IACxB,GAAG,KAAK,YAAY,GAAI;AAC5B,WAAO;GACR,MACC,OAAM;EAET;EAGD,MAAMC,aAA4B;GAChC,UACE,QAAQ,SAAS,IAAI,CAACC,SAAkB;IACtC,MAAM,IAAI;IACV,SAAS,IAAI;GACd,GAAE,IAAI,CAAE;GACX,SAAS,QAAQ;EAClB;AAED,MAAI,KAAK,eACP,QAAO,GACJ,KAAK,YAAY,KAAK,mBACnB,oBAAoB,YAAY,KAAK,aAAa,KAAK,SAAS,GAChE,CAAC,kCAAkC,WAAW,AAAC,EACpD;AAEH,SAAO,GACJ,KAAK,YAAY,KAAK,mBACnB,gBACE,oBAAoB,YAAY,KAAK,aAAa,KAAK,SAAS,EAChE,KAAK,aACL,KAAK,SACN,GACD,kCAAkC,WAAW,CAAC,QACnD;CACF;;;;;;;CAQD,MAAM,YACJC,aACAC,cACe;EACf,MAAM,QAAQ,cAAc,aAAa,KAAK,SAAS;EACvD,MAAM,SAAS,eAAe,cAAc,KAAK,UAAU;EAG3D,MAAM,SAAS,IAAIC,OAAW,EAC5B,UAAU,CACR,IAAI,QAAQ;GACV,MAAM,KAAK;GACX,SAAS,GAAG,OAAO;EACpB,IACD,IAAI,QAAQ;GACV,MAAM,KAAK;GACX,SAAS,GAAG,QAAQ;EACrB,EACF,EACF;EAGD,MAAM,YAAY,MAAM,KAAK;AAC7B,MAAI,CAAC,UACH,OAAM,IAAI,MAAM,KAAK;AAIvB,MAAI,KAAK,UACP,KAAI;GACF,MAAM,UAAU,OAAO,UAAU,KAAK,WAAW,OAAO;EACzD,SAAQ,OAAO;GACd,QAAQ,MAAM,yBAAyB,MAAM;EAC9C;EAIH,MAAM,MAAM,YAAY,aAAa,aAAa;CACnD;;;;;CAMD,MAAM,QAAuB;EAE3B,MAAM,YAAY,MAAM,KAAK;AAC7B,MAAI,CAAC,UACH,OAAM,IAAI,MAAM,KAAK;AAGvB,MAAI;GACF,MAAM,UAAU,OAAO,aAAa,KAAK,UAAU;EACpD,SAAQ,OAAO;GACd,QAAQ,MAAM,4BAA4B,MAAM;EACjD;EAGD,MAAM,MAAM,OAAO;CACpB;AACF"}