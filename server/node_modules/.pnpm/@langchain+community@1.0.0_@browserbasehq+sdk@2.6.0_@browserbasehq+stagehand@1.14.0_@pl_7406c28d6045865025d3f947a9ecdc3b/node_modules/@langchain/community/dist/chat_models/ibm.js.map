{"version":3,"file":"ibm.js","names":["model: string","tool_call_id: string","tools: ChatWatsonxToolType[]","messages: BaseMessage[]","model?: string","role: MessageType","message: BaseMessage","choice: TextChatResultChoice","rawDataId: string","usage?: TextChatUsage","rawToolCalls: TextChatToolCall[]","e: unknown","additional_kwargs: Record<string, unknown>","delta: WatsonxDeltaStream","rawData: TextChatResponse","defaultRole?: TextChatMessagesTextChatMessageAssistant.Constants.Role","toolCallChunks: ToolCallChunk[]","toolChoice: TextChatParameterTools | string | \"auto\" | \"any\"","options: this[\"ParsedCallOptions\"]","fields: (ChatWatsonxInput | ChatWatsonxDeployedInput) & WatsonxAuth","kwargs?: Partial<CallOptions>","callback: () => T","options?: this[\"ParsedCallOptions\"]","runManager?: CallbackManagerForLLMRun","finalChunks: Record<number, ChatGenerationChunk>","tokenUsage: UsageMetadata","tokenUsages: UsageMetadata[]","generations: ChatGeneration[]","generation: ChatGeneration","_runManager?: CallbackManagerForLLMRun","usage: TextChatUsage | undefined","generationChunk","outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>","config?: StructuredOutputMethodOptions<boolean>","schema: InteropZodType<RunOutput> | Record<string, any>","outputParser: BaseLLMOutputParser<RunOutput>","llm: Runnable<BaseLanguageModelInput>","openAIFunctionDefinition: FunctionDefinition","input: any","config"],"sources":["../../src/chat_models/ibm.ts"],"sourcesContent":["import {\n  AIMessage,\n  AIMessageChunk,\n  ChatMessage,\n  ChatMessageChunk,\n  FunctionMessageChunk,\n  HumanMessageChunk,\n  isAIMessage,\n  MessageType,\n  ToolMessageChunk,\n  UsageMetadata,\n  type BaseMessage,\n} from \"@langchain/core/messages\";\nimport {\n  BaseLanguageModelInput,\n  FunctionDefinition,\n  StructuredOutputMethodOptions,\n} from \"@langchain/core/language_models/base\";\nimport { CallbackManagerForLLMRun } from \"@langchain/core/callbacks/manager\";\nimport {\n  BaseChatModel,\n  BaseChatModelCallOptions,\n  BindToolsInput,\n  LangSmithParams,\n  type BaseChatModelParams,\n} from \"@langchain/core/language_models/chat_models\";\nimport {\n  ChatGeneration,\n  ChatGenerationChunk,\n  ChatResult,\n} from \"@langchain/core/outputs\";\nimport { AsyncCaller } from \"@langchain/core/utils/async_caller\";\nimport {\n  DeploymentsTextChatParams,\n  RequestCallbacks,\n  TextChatMessagesTextChatMessageAssistant,\n  TextChatParameterTools,\n  TextChatParams,\n  TextChatResponse,\n  TextChatResponseFormat,\n  TextChatResultChoice,\n  TextChatResultMessage,\n  TextChatToolCall,\n  TextChatUsage,\n} from \"@ibm-cloud/watsonx-ai/dist/watsonx-ai-ml/vml_v1.js\";\nimport { WatsonXAI } from \"@ibm-cloud/watsonx-ai\";\nimport {\n  convertLangChainToolCallToOpenAI,\n  makeInvalidToolCall,\n  parseToolCall,\n} from \"@langchain/core/output_parsers/openai_tools\";\nimport { ToolCallChunk } from \"@langchain/core/messages/tool\";\nimport {\n  Runnable,\n  RunnablePassthrough,\n  RunnableSequence,\n} from \"@langchain/core/runnables\";\nimport {\n  BaseLLMOutputParser,\n  JsonOutputParser,\n  StructuredOutputParser,\n} from \"@langchain/core/output_parsers\";\nimport {\n  InteropZodType,\n  isInteropZodSchema,\n} from \"@langchain/core/utils/types\";\nimport { toJsonSchema } from \"@langchain/core/utils/json_schema\";\nimport { NewTokenIndices } from \"@langchain/core/callbacks/base\";\nimport {\n  Neverify,\n  WatsonxAuth,\n  WatsonxChatBasicOptions,\n  WatsonxDeployedParams,\n  WatsonxParams,\n} from \"../types/ibm.js\";\nimport {\n  _convertToolCallIdToMistralCompatible,\n  authenticateAndSetInstance,\n  WatsonxToolsOutputParser,\n} from \"../utils/ibm.js\";\n\nexport interface WatsonxDeltaStream {\n  role?: string;\n  content?: string;\n  tool_calls?: TextChatToolCall[];\n  refusal?: string;\n}\n\nexport interface WatsonxCallParams\n  extends Partial<\n    Omit<TextChatParams, \"modelId\" | \"toolChoice\" | \"messages\">\n  > {}\n\nexport interface WatsonxCallDeployedParams extends DeploymentsTextChatParams {}\n\nexport interface WatsonxCallOptionsChat\n  extends Omit<BaseChatModelCallOptions, \"stop\">,\n    WatsonxCallParams,\n    WatsonxChatBasicOptions {\n  promptIndex?: number;\n  tool_choice?: TextChatParameterTools | string | \"auto\" | \"any\";\n}\n\nexport interface WatsonxCallOptionsDeployedChat\n  extends Omit<BaseChatModelCallOptions, \"stop\">,\n    WatsonxCallDeployedParams,\n    WatsonxChatBasicOptions {\n  promptIndex?: number;\n  tool_choice?: TextChatParameterTools | string | \"auto\" | \"any\";\n}\n\ntype ChatWatsonxToolType = BindToolsInput | TextChatParameterTools;\n\nexport interface ChatWatsonxInput\n  extends BaseChatModelParams,\n    WatsonxParams,\n    WatsonxCallParams,\n    Neverify<Omit<DeploymentsTextChatParams, \"signal\" | \"headers\">> {}\n\nexport interface ChatWatsonxDeployedInput\n  extends BaseChatModelParams,\n    WatsonxDeployedParams,\n    Neverify<TextChatParams> {}\n\nexport type ChatWatsonxConstructor = BaseChatModelParams &\n  Partial<WatsonxParams> &\n  WatsonxDeployedParams &\n  WatsonxCallParams;\nfunction _convertToValidToolId(model: string, tool_call_id: string) {\n  if (model.startsWith(\"mistralai\"))\n    return _convertToolCallIdToMistralCompatible(tool_call_id);\n  else return tool_call_id;\n}\n\nfunction _convertToolToWatsonxTool(\n  tools: ChatWatsonxToolType[]\n): WatsonXAI.TextChatParameterTools[] {\n  return tools.map((tool) => {\n    if (\"type\" in tool) {\n      return tool as WatsonXAI.TextChatParameterTools;\n    }\n    // Check if schema is a Zod schema or already a JSON schema\n    const parameters = isInteropZodSchema(tool.schema)\n      ? toJsonSchema(tool.schema)\n      : tool.schema;\n\n    return {\n      type: \"function\",\n      function: {\n        name: tool.name,\n        description: tool.description ?? `Tool: ${tool.name}`,\n        parameters,\n      },\n    };\n  });\n}\n\nfunction _convertMessagesToWatsonxMessages(\n  messages: BaseMessage[],\n  model?: string\n): TextChatResultMessage[] {\n  const getRole = (role: MessageType) => {\n    switch (role) {\n      case \"human\":\n        return \"user\";\n      case \"ai\":\n        return \"assistant\";\n      case \"system\":\n        return \"system\";\n      case \"tool\":\n        return \"tool\";\n      case \"function\":\n        return \"function\";\n      default:\n        throw new Error(`Unknown message type: ${role}`);\n    }\n  };\n\n  const getTools = (message: BaseMessage): TextChatToolCall[] | undefined => {\n    if (isAIMessage(message) && message.tool_calls?.length) {\n      return message.tool_calls\n        .map((toolCall) => ({\n          ...toolCall,\n          id: _convertToValidToolId(model ?? \"\", toolCall.id ?? \"\"),\n        }))\n        .map(convertLangChainToolCallToOpenAI) as TextChatToolCall[];\n    }\n    return undefined;\n  };\n\n  return messages.map((message) => {\n    const toolCalls = getTools(message);\n    const content = toolCalls === undefined ? message.content : \"\";\n    if (\"tool_call_id\" in message && typeof message.tool_call_id === \"string\") {\n      return {\n        role: getRole(message._getType()),\n        content,\n        name: message.name,\n        tool_call_id: _convertToValidToolId(model ?? \"\", message.tool_call_id),\n      };\n    }\n\n    return {\n      role: getRole(message._getType()),\n      content,\n      tool_calls: toolCalls,\n    };\n  }) as TextChatResultMessage[];\n}\n\nfunction _watsonxResponseToChatMessage(\n  choice: TextChatResultChoice,\n  rawDataId: string,\n  usage?: TextChatUsage\n): BaseMessage {\n  const { message } = choice;\n  if (!message) throw new Error(\"No message presented\");\n  const rawToolCalls: TextChatToolCall[] = message.tool_calls ?? [];\n\n  switch (message.role) {\n    case \"assistant\": {\n      const toolCalls = [];\n      const invalidToolCalls = [];\n      for (const rawToolCall of rawToolCalls) {\n        try {\n          const parsed = parseToolCall(rawToolCall, { returnId: true });\n          toolCalls.push(parsed);\n        } catch (e: unknown) {\n          invalidToolCalls.push(\n            makeInvalidToolCall(rawToolCall, (e as Error).message)\n          );\n        }\n      }\n      const additional_kwargs: Record<string, unknown> = {\n        tool_calls: rawToolCalls.map((toolCall) => ({\n          ...toolCall,\n          type: \"function\",\n        })),\n      };\n\n      return new AIMessage({\n        id: rawDataId,\n        content: message.content ?? \"\",\n        tool_calls: toolCalls,\n        invalid_tool_calls: invalidToolCalls,\n        additional_kwargs,\n        usage_metadata: usage\n          ? {\n              input_tokens: usage.prompt_tokens ?? 0,\n              output_tokens: usage.completion_tokens ?? 0,\n              total_tokens: usage.total_tokens ?? 0,\n            }\n          : undefined,\n      });\n    }\n    default:\n      return new ChatMessage(message.content ?? \"\", message.role ?? \"unknown\");\n  }\n}\n\nfunction _convertDeltaToMessageChunk(\n  delta: WatsonxDeltaStream,\n  rawData: TextChatResponse,\n  model?: string,\n  usage?: TextChatUsage,\n  defaultRole?: TextChatMessagesTextChatMessageAssistant.Constants.Role\n) {\n  if (delta.refusal) throw new Error(delta.refusal);\n  const rawToolCalls = delta.tool_calls?.length\n    ? delta.tool_calls?.map(\n        (\n          toolCall,\n          index\n        ): TextChatToolCall & {\n          index: number;\n          type: \"function\";\n        } => ({\n          index,\n          ...toolCall,\n          id: _convertToValidToolId(model ?? \"\", toolCall.id),\n          type: \"function\",\n        })\n      )\n    : undefined;\n\n  let role = \"assistant\";\n  if (delta.role) {\n    role = delta.role;\n  } else if (defaultRole) {\n    role = defaultRole;\n  }\n  const content = delta.content ?? \"\";\n  let additional_kwargs;\n  if (rawToolCalls) {\n    additional_kwargs = {\n      tool_calls: rawToolCalls,\n    };\n  } else {\n    additional_kwargs = {};\n  }\n\n  if (role === \"user\") {\n    return new HumanMessageChunk({ content });\n  } else if (role === \"assistant\") {\n    const toolCallChunks: ToolCallChunk[] = [];\n    if (rawToolCalls && rawToolCalls.length > 0)\n      for (const rawToolCallChunk of rawToolCalls) {\n        toolCallChunks.push({\n          name: rawToolCallChunk.function?.name,\n          args: rawToolCallChunk.function?.arguments,\n          id: rawToolCallChunk.id,\n          index: rawToolCallChunk.index,\n          type: \"tool_call_chunk\",\n        });\n      }\n\n    return new AIMessageChunk({\n      content,\n      tool_call_chunks: toolCallChunks,\n      additional_kwargs,\n      usage_metadata: {\n        input_tokens: usage?.prompt_tokens ?? 0,\n        output_tokens: usage?.completion_tokens ?? 0,\n        total_tokens: usage?.total_tokens ?? 0,\n      },\n      id: rawData.id,\n    });\n  } else if (role === \"tool\") {\n    if (rawToolCalls)\n      return new ToolMessageChunk({\n        content,\n        additional_kwargs,\n        tool_call_id: _convertToValidToolId(model ?? \"\", rawToolCalls?.[0].id),\n      });\n  } else if (role === \"function\") {\n    return new FunctionMessageChunk({\n      content,\n      additional_kwargs,\n    });\n  } else {\n    return new ChatMessageChunk({ content, role });\n  }\n  return null;\n}\n\nfunction _convertToolChoiceToWatsonxToolChoice(\n  toolChoice: TextChatParameterTools | string | \"auto\" | \"any\"\n) {\n  if (typeof toolChoice === \"string\") {\n    if (toolChoice === \"any\" || toolChoice === \"required\") {\n      return { toolChoiceOption: \"required\" };\n    } else if (toolChoice === \"auto\" || toolChoice === \"none\") {\n      return { toolChoiceOption: toolChoice };\n    } else {\n      return {\n        toolChoice: {\n          type: \"function\",\n          function: { name: toolChoice },\n        },\n      };\n    }\n  } else if (\"type\" in toolChoice) return { toolChoice };\n  else\n    throw new Error(\n      `Unrecognized tool_choice type. Expected string or TextChatParameterTools. Recieved ${toolChoice}`\n    );\n}\n\nexport class ChatWatsonx<\n    CallOptions extends WatsonxCallOptionsChat =\n      | WatsonxCallOptionsChat\n      | WatsonxCallOptionsDeployedChat\n  >\n  extends BaseChatModel<CallOptions>\n  implements ChatWatsonxConstructor\n{\n  static lc_name() {\n    return \"ChatWatsonx\";\n  }\n\n  lc_serializable = true;\n\n  get lc_secrets(): { [key: string]: string } {\n    return {\n      authenticator: \"AUTHENTICATOR\",\n      apiKey: \"WATSONX_AI_APIKEY\",\n      apikey: \"WATSONX_AI_APIKEY\",\n      watsonxAIAuthType: \"WATSONX_AI_AUTH_TYPE\",\n      watsonxAIApikey: \"WATSONX_AI_APIKEY\",\n      watsonxAIBearerToken: \"WATSONX_AI_BEARER_TOKEN\",\n      watsonxAIUsername: \"WATSONX_AI_USERNAME\",\n      watsonxAIPassword: \"WATSONX_AI_PASSWORD\",\n      watsonxAIUrl: \"WATSONX_AI_URL\",\n    };\n  }\n\n  get lc_aliases(): { [key: string]: string } {\n    return {\n      authenticator: \"authenticator\",\n      apikey: \"watsonx_ai_apikey\",\n      apiKey: \"watsonx_ai_apikey\",\n      watsonxAIAuthType: \"watsonx_ai_auth_type\",\n      watsonxAIApikey: \"watsonx_ai_apikey\",\n      watsonxAIBearerToken: \"watsonx_ai_bearer_token\",\n      watsonxAIUsername: \"watsonx_ai_username\",\n      watsonxAIPassword: \"watsonx_ai_password\",\n      watsonxAIUrl: \"watsonx_ai_url\",\n    };\n  }\n\n  getLsParams(options: this[\"ParsedCallOptions\"]): LangSmithParams {\n    const params = this.invocationParams(options);\n    return {\n      ls_provider: \"watsonx\",\n      ls_model_name: this.model,\n      ls_model_type: \"chat\",\n      ls_temperature: params.temperature ?? undefined,\n      ls_max_tokens: params.maxTokens ?? undefined,\n    };\n  }\n\n  model?: string;\n\n  version = \"2024-05-31\";\n\n  maxTokens?: number;\n\n  maxCompletionTokens?: number;\n\n  maxRetries = 0;\n\n  serviceUrl: string;\n\n  spaceId?: string;\n\n  projectId?: string;\n\n  idOrName?: string;\n\n  frequencyPenalty?: number;\n\n  logprobs?: boolean;\n\n  topLogprobs?: number;\n\n  n?: number;\n\n  presencePenalty?: number;\n\n  temperature?: number;\n\n  topP?: number;\n\n  timeLimit?: number;\n\n  maxConcurrency?: number;\n\n  service: WatsonXAI;\n\n  responseFormat?: TextChatResponseFormat;\n\n  streaming: boolean;\n\n  watsonxCallbacks?: RequestCallbacks;\n\n  constructor(\n    fields: (ChatWatsonxInput | ChatWatsonxDeployedInput) & WatsonxAuth\n  ) {\n    super(fields);\n    if (\n      (\"projectId\" in fields && \"spaceId\" in fields) ||\n      (\"projectId\" in fields && \"idOrName\" in fields) ||\n      (\"spaceId\" in fields && \"idOrName\" in fields)\n    )\n      throw new Error(\"Maximum 1 id type can be specified per instance\");\n\n    if (\"model\" in fields) {\n      this.projectId = fields?.projectId;\n      this.spaceId = fields?.spaceId;\n      this.temperature = fields?.temperature;\n      this.maxRetries = fields?.maxRetries || this.maxRetries;\n      this.maxConcurrency = fields?.maxConcurrency;\n      this.frequencyPenalty = fields?.frequencyPenalty;\n      this.topLogprobs = fields?.topLogprobs;\n      this.maxTokens = fields?.maxTokens ?? this.maxTokens;\n      this.maxCompletionTokens = fields?.maxCompletionTokens;\n      this.presencePenalty = fields?.presencePenalty;\n      this.topP = fields?.topP;\n      this.timeLimit = fields?.timeLimit;\n      this.responseFormat = fields?.responseFormat ?? this.responseFormat;\n      this.streaming = fields?.streaming ?? this.streaming;\n      this.n = fields?.n ?? this.n;\n      this.model = fields?.model ?? this.model;\n    } else this.idOrName = fields?.idOrName;\n\n    this.watsonxCallbacks = fields?.watsonxCallbacks ?? this.watsonxCallbacks;\n    this.serviceUrl = fields?.serviceUrl;\n    this.version = fields?.version ?? this.version;\n\n    const {\n      watsonxAIApikey,\n      watsonxAIAuthType,\n      watsonxAIBearerToken,\n      watsonxAIUsername,\n      watsonxAIPassword,\n      watsonxAIUrl,\n      disableSSL,\n      version,\n      serviceUrl,\n    } = fields;\n\n    const auth = authenticateAndSetInstance({\n      watsonxAIApikey,\n      watsonxAIAuthType,\n      watsonxAIBearerToken,\n      watsonxAIUsername,\n      watsonxAIPassword,\n      watsonxAIUrl,\n      disableSSL,\n      version,\n      serviceUrl,\n    });\n    if (auth) this.service = auth;\n    else throw new Error(\"You have not provided one type of authentication\");\n  }\n\n  _llmType() {\n    return \"watsonx\";\n  }\n\n  invocationParams(options: this[\"ParsedCallOptions\"]) {\n    const { signal, promptIndex, ...rest } = options;\n    if (this.idOrName && Object.keys(rest).length > 0)\n      throw new Error(\"Options cannot be provided to a deployed model\");\n\n    const params = {\n      maxTokens: options.maxTokens ?? this.maxTokens,\n      maxCompletionTokens:\n        options.maxCompletionTokens ?? this.maxCompletionTokens,\n      temperature: options?.temperature ?? this.temperature,\n      timeLimit: options?.timeLimit ?? this.timeLimit,\n      topP: options?.topP ?? this.topP,\n      presencePenalty: options?.presencePenalty ?? this.presencePenalty,\n      n: options?.n ?? this.n,\n      topLogprobs: options?.topLogprobs ?? this.topLogprobs,\n      logprobs: options?.logprobs ?? this?.logprobs,\n      frequencyPenalty: options?.frequencyPenalty ?? this.frequencyPenalty,\n      tools: options.tools\n        ? _convertToolToWatsonxTool(options.tools)\n        : undefined,\n      responseFormat: options.responseFormat,\n    };\n    const toolChoiceResult = options.tool_choice\n      ? _convertToolChoiceToWatsonxToolChoice(options.tool_choice)\n      : {};\n    return { ...params, ...toolChoiceResult };\n  }\n\n  invocationCallbacks(options: this[\"ParsedCallOptions\"]) {\n    return options.watsonxCallbacks ?? this.watsonxCallbacks;\n  }\n\n  override bindTools(\n    tools: ChatWatsonxToolType[],\n    kwargs?: Partial<CallOptions>\n  ): Runnable<BaseLanguageModelInput, AIMessageChunk, CallOptions> {\n    return this.withConfig({\n      tools: _convertToolToWatsonxTool(tools),\n      ...kwargs,\n    } as CallOptions);\n  }\n\n  scopeId():\n    | { idOrName: string }\n    | { projectId: string; modelId: string }\n    | { spaceId: string; modelId: string }\n    | { modelId: string } {\n    if (this.projectId && this.model)\n      return { projectId: this.projectId, modelId: this.model };\n    else if (this.spaceId && this.model)\n      return { spaceId: this.spaceId, modelId: this.model };\n    else if (this.idOrName) return { idOrName: this.idOrName };\n    else if (this.model)\n      return {\n        modelId: this.model,\n      };\n    else throw new Error(\"No id or model provided!\");\n  }\n\n  async completionWithRetry<T>(\n    callback: () => T,\n    options?: this[\"ParsedCallOptions\"]\n  ) {\n    const caller = new AsyncCaller({\n      maxConcurrency: options?.maxConcurrency || this.maxConcurrency,\n      maxRetries: this.maxRetries,\n    });\n    const result = options\n      ? caller.callWithOptions(\n          {\n            signal: options.signal,\n          },\n          async () => callback()\n        )\n      : caller.call(async () => callback());\n\n    return result;\n  }\n\n  async _generate(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    if (this.streaming) {\n      const stream = this._streamResponseChunks(messages, options, runManager);\n      const finalChunks: Record<number, ChatGenerationChunk> = {};\n      let tokenUsage: UsageMetadata = {\n        input_tokens: 0,\n        output_tokens: 0,\n        total_tokens: 0,\n      };\n      const tokenUsages: UsageMetadata[] = [];\n      for await (const chunk of stream) {\n        const message = chunk.message as AIMessageChunk;\n        if (message?.usage_metadata) {\n          const completion = chunk.generationInfo?.completion;\n          if (tokenUsages[completion])\n            tokenUsages[completion].output_tokens =\n              message.usage_metadata.output_tokens;\n          else tokenUsages[completion] = message.usage_metadata;\n        }\n        chunk.message.response_metadata = {\n          ...chunk.generationInfo,\n          ...chunk.message.response_metadata,\n        };\n\n        const index =\n          (chunk.generationInfo as NewTokenIndices)?.completion ?? 0;\n        if (finalChunks[index] === undefined) {\n          finalChunks[index] = chunk;\n        } else {\n          finalChunks[index] = finalChunks[index].concat(chunk);\n        }\n      }\n      tokenUsage = tokenUsages.reduce((acc, curr) => {\n        return {\n          input_tokens: acc.input_tokens + curr.input_tokens,\n          output_tokens: acc.output_tokens + curr.output_tokens,\n          total_tokens: acc.total_tokens + curr.total_tokens,\n        };\n      });\n      const generations = Object.entries(finalChunks)\n        .sort(([aKey], [bKey]) => parseInt(aKey, 10) - parseInt(bKey, 10))\n        .map(([_, value]) => value);\n      return { generations, llmOutput: { tokenUsage } };\n    } else {\n      const params = this.invocationParams(options);\n      const scopeId = this.scopeId();\n      const watsonxCallbacks = this.invocationCallbacks(options);\n      const watsonxMessages = _convertMessagesToWatsonxMessages(\n        messages,\n        this.model\n      );\n      const callback = () =>\n        \"idOrName\" in scopeId\n          ? this.service.deploymentsTextChat(\n              {\n                ...scopeId,\n                messages: watsonxMessages,\n              },\n              watsonxCallbacks\n            )\n          : this.service.textChat(\n              {\n                ...params,\n                ...scopeId,\n                messages: watsonxMessages,\n              },\n              watsonxCallbacks\n            );\n      const { result } = await this.completionWithRetry(callback, options);\n      const generations: ChatGeneration[] = [];\n      for (const part of result.choices) {\n        const generation: ChatGeneration = {\n          text: part.message?.content ?? \"\",\n          message: _watsonxResponseToChatMessage(\n            part,\n            result.id,\n            result?.usage\n          ),\n        };\n        if (part.finish_reason) {\n          generation.generationInfo = { finish_reason: part.finish_reason };\n        }\n        generations.push(generation);\n      }\n      if (options.signal?.aborted) {\n        throw new Error(\"AbortError\");\n      }\n\n      return {\n        generations,\n        llmOutput: {\n          tokenUsage: result?.usage,\n        },\n      };\n    }\n  }\n\n  async *_streamResponseChunks(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    _runManager?: CallbackManagerForLLMRun\n  ): AsyncGenerator<ChatGenerationChunk> {\n    const params = this.invocationParams(options);\n    const scopeId = this.scopeId();\n    const watsonxMessages = _convertMessagesToWatsonxMessages(\n      messages,\n      this.model\n    );\n    const watsonxCallbacks = this.invocationCallbacks(options);\n    const callback = () =>\n      \"idOrName\" in scopeId\n        ? this.service.deploymentsTextChatStream(\n            {\n              ...scopeId,\n              messages: watsonxMessages,\n              returnObject: true,\n            },\n            watsonxCallbacks\n          )\n        : this.service.textChatStream(\n            {\n              ...params,\n              ...scopeId,\n              messages: watsonxMessages,\n              returnObject: true,\n            },\n            watsonxCallbacks\n          );\n\n    const stream = await this.completionWithRetry(callback, options);\n    let defaultRole;\n    let usage: TextChatUsage | undefined;\n    let currentCompletion = 0;\n    for await (const chunk of stream) {\n      if (options.signal?.aborted) {\n        throw new Error(\"AbortError\");\n      }\n      if (chunk?.data?.usage) usage = chunk.data.usage;\n      const { data } = chunk;\n      const choice = data.choices[0] as TextChatResultChoice &\n        Record<\"delta\", TextChatResultMessage>;\n      if (choice && !(\"delta\" in choice)) {\n        continue;\n      }\n      const delta = choice?.delta;\n\n      if (!delta) {\n        continue;\n      }\n      currentCompletion = choice.index ?? 0;\n      const newTokenIndices = {\n        prompt: options.promptIndex ?? 0,\n        completion: choice.index ?? 0,\n      };\n\n      const generationInfo = {\n        ...newTokenIndices,\n        finish_reason: choice.finish_reason,\n      };\n\n      const message = _convertDeltaToMessageChunk(\n        delta,\n        data,\n        this.model,\n        chunk.data.usage,\n        defaultRole\n      );\n\n      defaultRole =\n        (delta.role as TextChatMessagesTextChatMessageAssistant.Constants.Role) ??\n        defaultRole;\n\n      if (message === null || (!delta.content && !delta.tool_calls)) {\n        continue;\n      }\n      const generationChunk = new ChatGenerationChunk({\n        message,\n        text: delta.content ?? \"\",\n        generationInfo,\n      });\n\n      yield generationChunk;\n\n      // eslint-disable-next-line no-void\n      void _runManager?.handleLLMNewToken(\n        generationChunk.text ?? \"\",\n        newTokenIndices,\n        undefined,\n        undefined,\n        undefined,\n        { chunk: generationChunk }\n      );\n    }\n\n    const generationChunk = new ChatGenerationChunk({\n      message: new AIMessageChunk({\n        content: \"\",\n        response_metadata: {\n          usage,\n        },\n        usage_metadata: {\n          input_tokens: usage?.prompt_tokens ?? 0,\n          output_tokens: usage?.completion_tokens ?? 0,\n          total_tokens: usage?.total_tokens ?? 0,\n        },\n      }),\n      text: \"\",\n      generationInfo: {\n        prompt: options.promptIndex ?? 0,\n        completion: currentCompletion ?? 0,\n      },\n    });\n    yield generationChunk;\n  }\n\n  /** @ignore */\n  _combineLLMOutput() {\n    return [];\n  }\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<boolean>\n  ):\n    | Runnable<BaseLanguageModelInput, RunOutput>\n    | Runnable<\n        BaseLanguageModelInput,\n        { raw: BaseMessage; parsed: RunOutput }\n      > {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const schema: InteropZodType<RunOutput> | Record<string, any> =\n      outputSchema;\n    const name = config?.name;\n    const method = config?.method;\n    const includeRaw = config?.includeRaw;\n    let functionName = name ?? \"extract\";\n    let outputParser: BaseLLMOutputParser<RunOutput>;\n    let llm: Runnable<BaseLanguageModelInput>;\n    if (method === \"jsonMode\") {\n      const options = {\n        responseFormat: { type: \"json_object\" },\n      } as Partial<CallOptions>;\n      llm = this.withConfig(options);\n\n      if (isInteropZodSchema(schema)) {\n        outputParser = StructuredOutputParser.fromZodSchema(schema);\n      } else {\n        outputParser = new JsonOutputParser<RunOutput>();\n      }\n    } else {\n      if (isInteropZodSchema(schema)) {\n        const asJsonSchema = toJsonSchema(schema);\n        llm = this.bindTools(\n          [\n            {\n              type: \"function\" as const,\n              function: {\n                name: functionName,\n                description:\n                  asJsonSchema.description ?? `Tool: ${functionName}`,\n                parameters: asJsonSchema,\n              },\n            },\n          ],\n          {\n            // Ideally that would be set to required but this is not supported yet\n            tool_choice: {\n              type: \"function\",\n              function: {\n                name: functionName,\n              },\n            },\n          } as Partial<CallOptions>\n        );\n        outputParser = new WatsonxToolsOutputParser({\n          returnSingle: true,\n          keyName: functionName,\n          zodSchema: schema,\n        });\n      } else {\n        let openAIFunctionDefinition: FunctionDefinition;\n        if (\n          typeof schema.name === \"string\" &&\n          typeof schema.parameters === \"object\" &&\n          schema.parameters != null\n        ) {\n          openAIFunctionDefinition = schema as FunctionDefinition;\n          functionName = schema.name;\n        } else {\n          openAIFunctionDefinition = {\n            name: functionName,\n            description: schema.description ?? \"\",\n            parameters: schema,\n          };\n        }\n        llm = this.bindTools(\n          [\n            {\n              type: \"function\" as const,\n              function: openAIFunctionDefinition,\n            },\n          ],\n          {\n            // Ideally that would be set to required but this is not supported yet\n            tool_choice: {\n              type: \"function\",\n              function: {\n                name: functionName,\n              },\n            },\n          } as Partial<CallOptions>\n        );\n        outputParser = new WatsonxToolsOutputParser<RunOutput>({\n          returnSingle: true,\n          keyName: functionName,\n        });\n      }\n    }\n\n    if (!includeRaw) {\n      return llm.pipe(outputParser) as Runnable<\n        BaseLanguageModelInput,\n        RunOutput\n      >;\n    }\n\n    const parserAssign = RunnablePassthrough.assign({\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      parsed: (input: any, config) => outputParser.invoke(input.raw, config),\n    });\n    const parserNone = RunnablePassthrough.assign({\n      parsed: () => null,\n    });\n    const parsedWithFallback = parserAssign.withFallbacks({\n      fallbacks: [parserNone],\n    });\n    return RunnableSequence.from<\n      BaseLanguageModelInput,\n      { raw: BaseMessage; parsed: RunOutput }\n    >([\n      {\n        raw: llm,\n      },\n      parsedWithFallback,\n    ]);\n  }\n}\n"],"mappings":"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"}