{"version":3,"file":"convex.cjs","names":["v"],"sources":["../../src/utils/convex.ts"],"sourcesContent":["import {\n  internalQueryGeneric as internalQuery,\n  internalMutationGeneric as internalMutation,\n} from \"convex/server\";\nimport { GenericId, v } from \"convex/values\";\n\nexport const get = /*#__PURE__*/ internalQuery({\n  args: {\n    id: /*#__PURE__*/ v.string(),\n  },\n  handler: async (ctx, args) => {\n    const result = await ctx.db.get(args.id as GenericId<string>);\n    return result;\n  },\n});\n\nexport const insert = /*#__PURE__*/ internalMutation({\n  args: {\n    table: /*#__PURE__*/ v.string(),\n    document: /*#__PURE__*/ v.any(),\n  },\n  handler: async (ctx, args) => {\n    await ctx.db.insert(args.table, args.document);\n  },\n});\n\nexport const lookup = /*#__PURE__*/ internalQuery({\n  args: {\n    table: /*#__PURE__*/ v.string(),\n    index: /*#__PURE__*/ v.string(),\n    keyField: /*#__PURE__*/ v.string(),\n    key: /*#__PURE__*/ v.string(),\n  },\n  handler: async (ctx, args) => {\n    const result = await ctx.db\n      .query(args.table)\n      .withIndex(args.index, (q) => q.eq(args.keyField, args.key))\n      .collect();\n    return result;\n  },\n});\n\nexport const upsert = /*#__PURE__*/ internalMutation({\n  args: {\n    table: /*#__PURE__*/ v.string(),\n    index: /*#__PURE__*/ v.string(),\n    keyField: /*#__PURE__*/ v.string(),\n    key: /*#__PURE__*/ v.string(),\n    document: /*#__PURE__*/ v.any(),\n  },\n  handler: async (ctx, args) => {\n    const existing = await ctx.db\n      .query(args.table)\n      .withIndex(args.index, (q) => q.eq(args.keyField, args.key))\n      .unique();\n    if (existing !== null) {\n      await ctx.db.replace(existing._id, args.document);\n    } else {\n      await ctx.db.insert(args.table, args.document);\n    }\n  },\n});\n\nexport const deleteMany = /*#__PURE__*/ internalMutation({\n  args: {\n    table: /*#__PURE__*/ v.string(),\n    index: /*#__PURE__*/ v.string(),\n    keyField: /*#__PURE__*/ v.string(),\n    key: /*#__PURE__*/ v.string(),\n  },\n  handler: async (ctx, args) => {\n    const existing = await ctx.db\n      .query(args.table)\n      .withIndex(args.index, (q) => q.eq(args.keyField, args.key))\n      .collect();\n    await Promise.all(existing.map((doc) => ctx.db.delete(doc._id)));\n  },\n});\n"],"mappings":";;;;;;;;;;;;;AAMA,MAAa,8DAAkC;CAC7C,MAAM,EACJ,oBAAkBA,gBAAE,QAAQ,CAC7B;CACD,SAAS,OAAO,KAAK,SAAS;EAC5B,MAAM,SAAS,MAAM,IAAI,GAAG,IAAI,KAAK,GAAwB;AAC7D,SAAO;CACR;AACF,EAAC;AAEF,MAAa,oEAAwC;CACnD,MAAM;EACJ,uBAAqBA,gBAAE,QAAQ;EAC/B,0BAAwBA,gBAAE,KAAK;CAChC;CACD,SAAS,OAAO,KAAK,SAAS;EAC5B,MAAM,IAAI,GAAG,OAAO,KAAK,OAAO,KAAK,SAAS;CAC/C;AACF,EAAC;AAEF,MAAa,iEAAqC;CAChD,MAAM;EACJ,uBAAqBA,gBAAE,QAAQ;EAC/B,uBAAqBA,gBAAE,QAAQ;EAC/B,0BAAwBA,gBAAE,QAAQ;EAClC,qBAAmBA,gBAAE,QAAQ;CAC9B;CACD,SAAS,OAAO,KAAK,SAAS;EAC5B,MAAM,SAAS,MAAM,IAAI,GACtB,MAAM,KAAK,MAAM,CACjB,UAAU,KAAK,OAAO,CAAC,MAAM,EAAE,GAAG,KAAK,UAAU,KAAK,IAAI,CAAC,CAC3D,SAAS;AACZ,SAAO;CACR;AACF,EAAC;AAEF,MAAa,oEAAwC;CACnD,MAAM;EACJ,uBAAqBA,gBAAE,QAAQ;EAC/B,uBAAqBA,gBAAE,QAAQ;EAC/B,0BAAwBA,gBAAE,QAAQ;EAClC,qBAAmBA,gBAAE,QAAQ;EAC7B,0BAAwBA,gBAAE,KAAK;CAChC;CACD,SAAS,OAAO,KAAK,SAAS;EAC5B,MAAM,WAAW,MAAM,IAAI,GACxB,MAAM,KAAK,MAAM,CACjB,UAAU,KAAK,OAAO,CAAC,MAAM,EAAE,GAAG,KAAK,UAAU,KAAK,IAAI,CAAC,CAC3D,QAAQ;AACX,MAAI,aAAa,MACf,MAAM,IAAI,GAAG,QAAQ,SAAS,KAAK,KAAK,SAAS;OAEjD,MAAM,IAAI,GAAG,OAAO,KAAK,OAAO,KAAK,SAAS;CAEjD;AACF,EAAC;AAEF,MAAa,wEAA4C;CACvD,MAAM;EACJ,uBAAqBA,gBAAE,QAAQ;EAC/B,uBAAqBA,gBAAE,QAAQ;EAC/B,0BAAwBA,gBAAE,QAAQ;EAClC,qBAAmBA,gBAAE,QAAQ;CAC9B;CACD,SAAS,OAAO,KAAK,SAAS;EAC5B,MAAM,WAAW,MAAM,IAAI,GACxB,MAAM,KAAK,MAAM,CACjB,UAAU,KAAK,OAAO,CAAC,MAAM,EAAE,GAAG,KAAK,UAAU,KAAK,IAAI,CAAC,CAC3D,SAAS;EACZ,MAAM,QAAQ,IAAI,SAAS,IAAI,CAAC,QAAQ,IAAI,GAAG,OAAO,IAAI,IAAI,CAAC,CAAC;CACjE;AACF,EAAC"}