{"version":3,"file":"astradb.d.cts","names":["CreateCollectionOptions","AsyncCaller","AsyncCallerParams","Document","EmbeddingsInterface","MaxMarginalRelevanceSearchOptions","VectorStore","CollectionFilter","Record","AstraLibArgs","AstraDeleteParams","AstraDBVectorStore","Promise"],"sources":["../../src/vectorstores/astradb.d.ts"],"sourcesContent":["import { CreateCollectionOptions } from \"@datastax/astra-db-ts\";\nimport { AsyncCaller, AsyncCallerParams } from \"@langchain/core/utils/async_caller\";\nimport { Document } from \"@langchain/core/documents\";\nimport type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { MaxMarginalRelevanceSearchOptions, VectorStore } from \"@langchain/core/vectorstores\";\nexport type CollectionFilter = Record<string, unknown>;\nexport interface AstraLibArgs extends AsyncCallerParams {\n    token: string;\n    endpoint: string;\n    collection: string;\n    keyspace?: string;\n    idKey?: string;\n    contentKey?: string;\n    skipCollectionProvisioning?: boolean;\n    collectionOptions?: CreateCollectionOptions<any>;\n    batchSize?: number;\n}\nexport type AstraDeleteParams = {\n    ids: string[];\n};\nexport declare class AstraDBVectorStore extends VectorStore {\n    FilterType: CollectionFilter;\n    private astraDBClient;\n    private collectionName;\n    private collection;\n    private collectionOptions;\n    private readonly idKey;\n    private readonly contentKey; // if undefined the entirety of the content aside from the id and embedding will be stored as content\n    caller: AsyncCaller;\n    private readonly skipCollectionProvisioning;\n    _vectorstoreType(): string;\n    constructor(embeddings: EmbeddingsInterface, args: AstraLibArgs);\n    private static applyCollectionOptionsDefaults;\n    /**\n     * Create a new collection in your Astra DB vector database and then connects to it.\n     * If the collection already exists, it will connect to it as well.\n     *\n     * @returns Promise that resolves if connected to the collection.\n     */\n    initialize(): Promise<void>;\n    /**\n     * Method to save vectors to AstraDB.\n     *\n     * @param vectors Vectors to save.\n     * @param documents The documents associated with the vectors.\n     * @returns Promise that resolves when the vectors have been added.\n     */\n    addVectors(vectors: number[][], documents: Document[], options?: string[]): Promise<void>;\n    /**\n     * Method that adds documents to AstraDB.\n     *\n     * @param documents Array of documents to add to AstraDB.\n     * @param options Optional ids for the documents.\n     * @returns Promise that resolves the documents have been added.\n     */\n    addDocuments(documents: Document[], options?: string[]): Promise<void>;\n    /**\n     * Method that deletes documents from AstraDB.\n     *\n     * @param params AstraDeleteParameters for the delete.\n     * @returns Promise that resolves when the documents have been deleted.\n     */\n    delete(params: AstraDeleteParams): Promise<void>;\n    /**\n     * Method that performs a similarity search in AstraDB and returns and similarity scores.\n     *\n     * @param query Query vector for the similarity search.\n     * @param k Number of top results to return.\n     * @param filter Optional filter to apply to the search.\n     * @returns Promise that resolves with an array of documents and their scores.\n     */\n    similaritySearchVectorWithScore(query: number[], k: number, filter?: CollectionFilter): Promise<[Document, number][]>;\n    /**\n     * Return documents selected using the maximal marginal relevance.\n     * Maximal marginal relevance optimizes for similarity to the query AND diversity\n     * among selected documents.\n     *\n     * @param {string} query - Text to look up documents similar to.\n     * @param {number} options.k - Number of documents to return.\n     * @param {number} options.fetchK - Number of documents to fetch before passing to the MMR algorithm.\n     * @param {number} options.lambda - Number between 0 and 1 that determines the degree of diversity among the results,\n     *                 where 0 corresponds to maximum diversity and 1 to minimum diversity.\n     * @param {CollectionFilter} options.filter - Optional filter\n     *\n     * @returns {Promise<Document[]>} - List of documents selected by maximal marginal relevance.\n     */\n    maxMarginalRelevanceSearch(query: string, options: MaxMarginalRelevanceSearchOptions<this[\"FilterType\"]>): Promise<Document[]>;\n    /**\n     * Static method to create an instance of AstraDBVectorStore from texts.\n     *\n     * @param texts The texts to use.\n     * @param metadatas The metadata associated with the texts.\n     * @param embeddings The embeddings to use.\n     * @param dbConfig The arguments for the AstraDBVectorStore.\n     * @returns Promise that resolves with a new instance of AstraDBVectorStore.\n     */\n    static fromTexts(texts: string[], metadatas: object[] | object, embeddings: EmbeddingsInterface, dbConfig: AstraLibArgs): Promise<AstraDBVectorStore>;\n    /**\n     * Static method to create an instance of AstraDBVectorStore from documents.\n     *\n     * @param docs The Documents to use.\n     * @param embeddings The embeddings to use.\n     * @param dbConfig The arguments for the AstraDBVectorStore.\n     * @returns Promise that resolves with a new instance of AstraDBVectorStore.\n     */\n    static fromDocuments(docs: Document[], embeddings: EmbeddingsInterface, dbConfig: AstraLibArgs): Promise<AstraDBVectorStore>;\n    /**\n     * Static method to create an instance of AstraDBVectorStore from an existing index.\n     *\n     * @param embeddings The embeddings to use.\n     * @param dbConfig The arguments for the AstraDBVectorStore.\n     * @returns Promise that resolves with a new instance of AstraDBVectorStore.\n     */\n    static fromExistingIndex(embeddings: EmbeddingsInterface, dbConfig: AstraLibArgs): Promise<AstraDBVectorStore>;\n}\n"],"mappings":";;;;;;;;;;KAKYO,gBAAAA,GAAmBC;UACdC,YAAAA,SAAqBP;;;;;;;;sBAQdF;EATZO,SAAAA,CAAAA,EAAAA,MAAAA;AACZ;AAA6B,KAWjBG,iBAAAA,GAXiB;EAAA,GAQLV,EAAAA,MAAAA,EAAAA;CAAuB;AARQ,cAclCW,kBAAAA,SAA2BL,WAAAA,CAdO;EAW3CI,UAAAA,EAIIH,gBAJa;EAGRI,QAAAA,aAAkB;EAAA,QAAA,cAAA;EAAA,QACvBJ,UAAAA;EAAgB,QAOpBN,iBAAAA;EAAW,iBAGKG,KAAAA;EAAmB,iBAAQK,UAAAA,CAAAA,CAAAA;EAAY,MAQjDG,EAXNX,WAWMW;EAAO,iBAQsBT,0BAAAA;EAAQ,gBAAyBS,CAAAA,CAAAA,EAAAA,MAAAA;EAAO,WAQ3DT,CAAAA,UAAAA,EAxBAC,mBAwBAD,EAAAA,IAAAA,EAxB2BM,YAwB3BN;EAAQ,eAAyBS,8BAAAA;EAAO;;;;;;EA+BoB,UAA+BT,CAAAA,CAAAA,EA/CrGS,OA+CqGT,CAAAA,IAAAA,CAAAA;EAAQ;;;;;;;EAmBrD,UAAYM,CAAAA,OAAAA,EAAAA,MAAAA,EAAAA,EAAAA,EAAAA,SAAAA,EA1DvCN,QA0DuCM,EAAAA,EAAAA,OAAAA,CAAAA,EAAAA,MAAAA,EAAAA,CAAAA,EA1DNG,OA0DMH,CAAAA,IAAAA,CAAAA;EAAY;;;;;;;EArFvC,YAAA,CAAA,SAAA,EAmC/BN,QAnC+B,EAAA,EAAA,OAAA,CAAA,EAAA,MAAA,EAAA,CAAA,EAmCES,OAnCF,CAAA,IAAA,CAAA;;;;;;;iBA0CxCF,oBAAoBE;;;;;;;;;uEASkCL,mBAAmBK,SAAST;;;;;;;;;;;;;;;qDAe9CE,wDAAwDO,QAAQT;;;;;;;;;;8EAUvCC,+BAA+BK,eAAeG,QAAQD;;;;;;;;;6BASvGR,wBAAwBC,+BAA+BK,eAAeG,QAAQD;;;;;;;;uCAQpEP,+BAA+BK,eAAeG,QAAQD"}