{"version":3,"file":"portkey.js","names":["message: Message","delta: Record<string, any>","init?: Partial<PortkeyChat>","messages: BaseMessage[]","options: this[\"ParsedCallOptions\"]","_?: CallbackManagerForLLMRun","generations: ChatGeneration[]","generation: ChatGeneration","runManager?: CallbackManagerForLLMRun"],"sources":["../../src/chat_models/portkey.ts"],"sourcesContent":["import { LLMOptions } from \"portkey-ai\";\nimport { CallbackManagerForLLMRun } from \"@langchain/core/callbacks/manager\";\nimport {\n  AIMessage,\n  AIMessageChunk,\n  BaseMessage,\n  ChatMessage,\n  ChatMessageChunk,\n  FunctionMessageChunk,\n  HumanMessage,\n  HumanMessageChunk,\n  SystemMessage,\n  SystemMessageChunk,\n} from \"@langchain/core/messages\";\nimport {\n  ChatResult,\n  ChatGeneration,\n  ChatGenerationChunk,\n} from \"@langchain/core/outputs\";\nimport { BaseChatModel } from \"@langchain/core/language_models/chat_models\";\n\nimport { PortkeySession, getPortkeySession } from \"../llms/portkey.js\";\n\ninterface Message {\n  role?: string;\n  content?: string;\n}\n\nfunction portkeyResponseToChatMessage(message: Message): BaseMessage {\n  switch (message.role) {\n    case \"user\":\n      return new HumanMessage(message.content || \"\");\n    case \"assistant\":\n      return new AIMessage(message.content || \"\");\n    case \"system\":\n      return new SystemMessage(message.content || \"\");\n    default:\n      return new ChatMessage(message.content || \"\", message.role ?? \"unknown\");\n  }\n}\n\nfunction _convertDeltaToMessageChunk(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  delta: Record<string, any>\n) {\n  const { role } = delta;\n  const content = delta.content ?? \"\";\n  let additional_kwargs;\n  if (delta.function_call) {\n    additional_kwargs = {\n      function_call: delta.function_call,\n    };\n  } else {\n    additional_kwargs = {};\n  }\n  if (role === \"user\") {\n    return new HumanMessageChunk({ content });\n  } else if (role === \"assistant\") {\n    return new AIMessageChunk({ content, additional_kwargs });\n  } else if (role === \"system\") {\n    return new SystemMessageChunk({ content });\n  } else if (role === \"function\") {\n    return new FunctionMessageChunk({\n      content,\n      additional_kwargs,\n      name: delta.name,\n    });\n  } else {\n    return new ChatMessageChunk({ content, role });\n  }\n}\n\nexport class PortkeyChat extends BaseChatModel {\n  apiKey?: string = undefined;\n\n  baseURL?: string = undefined;\n\n  mode?: string = undefined;\n\n  llms?: [LLMOptions] | null = undefined;\n\n  session: PortkeySession;\n\n  constructor(init?: Partial<PortkeyChat>) {\n    super(init ?? {});\n    this.apiKey = init?.apiKey;\n    this.baseURL = init?.baseURL;\n    this.mode = init?.mode;\n    this.llms = init?.llms;\n    this.session = getPortkeySession({\n      apiKey: this.apiKey,\n      baseURL: this.baseURL,\n      llms: this.llms,\n      mode: this.mode,\n    });\n  }\n\n  _llmType() {\n    return \"portkey\";\n  }\n\n  async _generate(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    _?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    const messagesList = messages.map((message) => {\n      if (typeof message.content !== \"string\") {\n        throw new Error(\n          \"PortkeyChat does not support non-string message content.\"\n        );\n      }\n      return {\n        role: message._getType() as string,\n        content: message.content,\n      };\n    });\n    const response = await this.session.portkey.chatCompletions.create({\n      messages: messagesList,\n      ...options,\n      stream: false,\n    });\n    const generations: ChatGeneration[] = [];\n    for (const data of response.choices ?? []) {\n      const text = data.message?.content ?? \"\";\n      const generation: ChatGeneration = {\n        text,\n        message: portkeyResponseToChatMessage(data.message ?? {}),\n      };\n      if (data.finish_reason) {\n        generation.generationInfo = { finish_reason: data.finish_reason };\n      }\n      generations.push(generation);\n    }\n\n    return {\n      generations,\n    };\n  }\n\n  async *_streamResponseChunks(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): AsyncGenerator<ChatGenerationChunk> {\n    const messagesList = messages.map((message) => {\n      if (typeof message.content !== \"string\") {\n        throw new Error(\n          \"PortkeyChat does not support non-string message content.\"\n        );\n      }\n      return {\n        role: message._getType() as string,\n        content: message.content,\n      };\n    });\n    const response = await this.session.portkey.chatCompletions.create({\n      messages: messagesList,\n      ...options,\n      stream: true,\n    });\n    for await (const data of response) {\n      const choice = data?.choices[0];\n      if (!choice) {\n        continue;\n      }\n      const chunk = new ChatGenerationChunk({\n        message: _convertDeltaToMessageChunk(choice.delta ?? {}),\n        text: choice.message?.content ?? \"\",\n        generationInfo: {\n          finishReason: choice.finish_reason,\n        },\n      });\n      yield chunk;\n      // eslint-disable-next-line no-void\n      void runManager?.handleLLMNewToken(chunk.text ?? \"\");\n    }\n    if (options.signal?.aborted) {\n      throw new Error(\"AbortError\");\n    }\n  }\n\n  _combineLLMOutput() {\n    return {};\n  }\n}\n"],"mappings":"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"}