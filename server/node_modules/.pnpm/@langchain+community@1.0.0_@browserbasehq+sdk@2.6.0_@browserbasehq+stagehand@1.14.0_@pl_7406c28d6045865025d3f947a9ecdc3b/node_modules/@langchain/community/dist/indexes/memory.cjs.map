{"version":3,"file":"memory.cjs","names":["RecordManager","keys: string[]","updateOptions?: UpdateOptions","options?: ListKeyOptions"],"sources":["../../src/indexes/memory.ts"],"sourcesContent":["import {\n  ListKeyOptions,\n  RecordManager,\n  UpdateOptions,\n} from \"@langchain/core/indexing\";\n\ninterface MemoryRecord {\n  updatedAt: number;\n  groupId: string | null;\n}\n\nexport class InMemoryRecordManager extends RecordManager {\n  lc_namespace = [\"langchain\", \"recordmanagers\", \"memory\"];\n\n  records: Map<string, MemoryRecord>;\n\n  constructor() {\n    super();\n    this.records = new Map();\n  }\n\n  async createSchema(): Promise<void> {\n    // nothing to do here\n    // compatibility with other record managers\n    return Promise.resolve();\n  }\n\n  async getTime(): Promise<number> {\n    return Promise.resolve(Date.now());\n  }\n\n  async update(keys: string[], updateOptions?: UpdateOptions): Promise<void> {\n    const updatedAt = await this.getTime();\n    const { timeAtLeast, groupIds: _groupIds } = updateOptions ?? {};\n\n    if (timeAtLeast && updatedAt < timeAtLeast) {\n      throw new Error(\n        `Time sync issue with database ${updatedAt} < ${timeAtLeast}`\n      );\n    }\n\n    const groupIds = _groupIds ?? keys.map(() => null);\n\n    if (groupIds.length !== keys.length) {\n      throw new Error(\n        `Number of keys (${keys.length}) does not match number of group_ids ${groupIds.length})`\n      );\n    }\n\n    keys.forEach((key, i) => {\n      const old = this.records.get(key);\n      if (old) {\n        old.updatedAt = updatedAt;\n      } else {\n        this.records.set(key, { updatedAt, groupId: groupIds[i] });\n      }\n    });\n  }\n\n  async exists(keys: string[]): Promise<boolean[]> {\n    return Promise.resolve(keys.map((key) => this.records.has(key)));\n  }\n\n  async listKeys(options?: ListKeyOptions): Promise<string[]> {\n    const { before, after, limit, groupIds } = options ?? {};\n\n    const filteredRecords = Array.from(this.records).filter(([_key, doc]) => {\n      // Inclusive bounds for before and after (i.e. <= and >=).\n      // This is technically incorrect, but because there is no\n      // latency, it is not garanteed that after an update the\n      // timestamp on subsequent listKeys calls will be different.\n      const isBefore = !before || doc.updatedAt <= before;\n      const isAfter = !after || doc.updatedAt >= after;\n      const belongsToGroup = !groupIds || groupIds.includes(doc.groupId);\n      return isBefore && isAfter && belongsToGroup;\n    });\n\n    return Promise.resolve(\n      filteredRecords\n        .map(([key]) => key)\n        .slice(0, limit ?? filteredRecords.length)\n    );\n  }\n\n  async deleteKeys(keys: string[]): Promise<void> {\n    keys.forEach((key) => this.records.delete(key));\n    return Promise.resolve();\n  }\n}\n"],"mappings":";;;;;;AAWA,IAAa,wBAAb,cAA2CA,wCAAc;CACvD,eAAe;EAAC;EAAa;EAAkB;CAAS;CAExD;CAEA,cAAc;EACZ,OAAO;EACP,KAAK,0BAAU,IAAI;CACpB;CAED,MAAM,eAA8B;AAGlC,SAAO,QAAQ,SAAS;CACzB;CAED,MAAM,UAA2B;AAC/B,SAAO,QAAQ,QAAQ,KAAK,KAAK,CAAC;CACnC;CAED,MAAM,OAAOC,MAAgBC,eAA8C;EACzE,MAAM,YAAY,MAAM,KAAK,SAAS;EACtC,MAAM,EAAE,aAAa,UAAU,WAAW,GAAG,iBAAiB,CAAE;AAEhE,MAAI,eAAe,YAAY,YAC7B,OAAM,IAAI,MACR,CAAC,8BAA8B,EAAE,UAAU,GAAG,EAAE,aAAa;EAIjE,MAAM,WAAW,aAAa,KAAK,IAAI,MAAM,KAAK;AAElD,MAAI,SAAS,WAAW,KAAK,OAC3B,OAAM,IAAI,MACR,CAAC,gBAAgB,EAAE,KAAK,OAAO,qCAAqC,EAAE,SAAS,OAAO,CAAC,CAAC;EAI5F,KAAK,QAAQ,CAAC,KAAK,MAAM;GACvB,MAAM,MAAM,KAAK,QAAQ,IAAI,IAAI;AACjC,OAAI,KACF,IAAI,YAAY;QAEhB,KAAK,QAAQ,IAAI,KAAK;IAAE;IAAW,SAAS,SAAS;GAAI,EAAC;EAE7D,EAAC;CACH;CAED,MAAM,OAAOD,MAAoC;AAC/C,SAAO,QAAQ,QAAQ,KAAK,IAAI,CAAC,QAAQ,KAAK,QAAQ,IAAI,IAAI,CAAC,CAAC;CACjE;CAED,MAAM,SAASE,SAA6C;EAC1D,MAAM,EAAE,QAAQ,OAAO,OAAO,UAAU,GAAG,WAAW,CAAE;EAExD,MAAM,kBAAkB,MAAM,KAAK,KAAK,QAAQ,CAAC,OAAO,CAAC,CAAC,MAAM,IAAI,KAAK;GAKvE,MAAM,WAAW,CAAC,UAAU,IAAI,aAAa;GAC7C,MAAM,UAAU,CAAC,SAAS,IAAI,aAAa;GAC3C,MAAM,iBAAiB,CAAC,YAAY,SAAS,SAAS,IAAI,QAAQ;AAClE,UAAO,YAAY,WAAW;EAC/B,EAAC;AAEF,SAAO,QAAQ,QACb,gBACG,IAAI,CAAC,CAAC,IAAI,KAAK,IAAI,CACnB,MAAM,GAAG,SAAS,gBAAgB,OAAO,CAC7C;CACF;CAED,MAAM,WAAWF,MAA+B;EAC9C,KAAK,QAAQ,CAAC,QAAQ,KAAK,QAAQ,OAAO,IAAI,CAAC;AAC/C,SAAO,QAAQ,SAAS;CACzB;AACF"}