{"version":3,"file":"zep_cloud.d.cts","names":["Zep","ZepClient","Memory","InputValues","OutputValues","MemoryVariables","BaseMessage","HumanMessage","BaseChatMemory","BaseChatMemoryInput","zepMemoryContextToSystemPrompt","condenseZepMemoryIntoHumanMessage","_langchain_core_messages5","MessageStructure","zepMemoryToMessages","MessageType","ZepCloudMemoryInput","MemoryType","ZepCloudMemory","Promise"],"sources":["../../src/memory/zep_cloud.d.ts"],"sourcesContent":["import { Zep, ZepClient } from \"@getzep/zep-cloud\";\nimport { Memory } from \"@getzep/zep-cloud/api\";\nimport { InputValues, OutputValues, MemoryVariables } from \"@langchain/core/memory\";\nimport { BaseMessage, HumanMessage } from \"@langchain/core/messages\";\nimport { BaseChatMemory, BaseChatMemoryInput } from \"./chat_memory.js\";\n// Extract Summary and Facts from Zep memory, if present and compose a system prompt\nexport declare const zepMemoryContextToSystemPrompt: (memory: Memory) => string;\n// We are condensing the Zep context into a human message in order to satisfy\n// some models' input requirements and allow more flexibility for devs.\n// (for example, Anthropic only supports one system message, and does not support multiple user messages in a row)\nexport declare const condenseZepMemoryIntoHumanMessage: (memory: Memory) => HumanMessage<import(\"@langchain/core/messages\").MessageStructure>;\n// Convert Zep Memory to a list of BaseMessages\nexport declare const zepMemoryToMessages: (memory: Memory) => BaseMessage<import(\"@langchain/core/messages\").MessageStructure, import(\"@langchain/core/messages\").MessageType>[];\n/**\n * Interface defining the structure of the input data for the ZepMemory\n * class. It includes properties like humanPrefix, aiPrefix, memoryKey, memoryType\n * sessionId, and apiKey.\n */\nexport interface ZepCloudMemoryInput extends BaseChatMemoryInput {\n    humanPrefix?: string;\n    aiPrefix?: string;\n    memoryKey?: string;\n    sessionId: string;\n    apiKey: string;\n    memoryType?: Zep.MemoryType;\n    // Whether to return separate messages for chat history with a SystemMessage containing (facts and summary) or return a single HumanMessage with the entire memory context.\n    // Defaults to false (return a single HumanMessage) in order to allow more flexibility with different models.\n    separateMessages?: boolean;\n}\n/**\n * Class used to manage the memory of a chat session, including loading\n * and saving the chat history, and clearing the memory when needed. It\n * uses the ZepClient to interact with the Zep service for managing the\n * chat session's memory.\n * @example\n * ```typescript\n * const sessionId = randomUUID();\n *\n * // Initialize ZepCloudMemory with session ID and API key\n * const memory = new ZepCloudMemory({\n *   sessionId,\n *   apiKey: \"<zep api key>\",\n * });\n *\n * // Create a ChatOpenAI model instance with specific parameters\n * const model = new ChatOpenAI({\n *   model: \"gpt-3.5-turbo\",\n *   temperature: 0,\n * });\n *\n * // Create a ConversationChain with the model and memory\n * const chain = new ConversationChain({ llm: model, memory });\n *\n * // Example of calling the chain with an input\n * const res1 = await chain.call({ input: \"Hi! I'm Jim.\" });\n * console.log({ res1 });\n *\n * // Follow-up call to the chain to demonstrate memory usage\n * const res2 = await chain.call({ input: \"What did I just say my name was?\" });\n * console.log({ res2 });\n *\n * // Output the session ID and the current state of memory\n * console.log(\"Session ID: \", sessionId);\n * console.log(\"Memory: \", await memory.loadMemoryVariables({}));\n *\n * ```\n */\nexport declare class ZepCloudMemory extends BaseChatMemory implements ZepCloudMemoryInput {\n    humanPrefix: string;\n    aiPrefix: string;\n    memoryKey: string;\n    apiKey: string;\n    sessionId: string;\n    zepClient: ZepClient;\n    memoryType: Zep.MemoryType;\n    separateMessages: boolean;\n    constructor(fields: ZepCloudMemoryInput);\n    get memoryKeys(): string[];\n    /**\n     * Method that retrieves the chat history from the Zep service and formats\n     * it into a list of messages.\n     * @param values Input values for the method.\n     * @returns Promise that resolves with the chat history formatted into a list of messages.\n     */\n    loadMemoryVariables(values: InputValues): Promise<MemoryVariables>;\n    /**\n     * Method that saves the input and output messages to the Zep service.\n     * @param inputValues Input messages to be saved.\n     * @param outputValues Output messages to be saved.\n     * @returns Promise that resolves when the messages have been saved.\n     */\n    saveContext(inputValues: InputValues, outputValues: OutputValues): Promise<void>;\n    /**\n     * Method that deletes the chat history from the Zep service.\n     * @returns Promise that resolves when the chat history has been deleted.\n     */\n    clear(): Promise<void>;\n}\n"],"mappings":";;;;;;;;;;;;cAMqBU,yCAAyCR;;;;cAIzCS,4CAA4CT,WAAWK,aAALK,yBAAAA,CAAqDC,gBAAAA;;cAEvGC,8BAA8BZ,WAAWI,YAALM,yBAAAA,CAAoDC,gBAAAA,EAAgBD,yBAAAA,CAAqCG,WAAAA;;;;;AANlK;AAIqBJ,UAQJK,mBAAAA,SAA4BP,qBAAAA,CAAAA,mBARgG,CAAA;EAAA,WAAA,CAAA,EAAA,MAAA;EAAA,QAA5EP,CAAAA,EAAAA,MAAAA;EAAM,SAAAU,CAAAA,EAAAA,MAAAA;EAAqE,SAAhEL,EAAAA,MAAAA;EAAY,MAAA,EAAA,MAAA;EAEnEO,UAAAA,CAAAA,EAYJd,GAAAA,CAAIiB,UAZ2J;EAAA;EAAA;EAAvH,gBAAAL,CAAAA,EAAAA,OAAAA;;;AAAgB;AAMzE;;;;AAAgE;AAiDhE;;;;;;;;;;;;;;AAAyF;;;;;;;;;;;;;;;;;cAApEM,cAAAA,SAAuBV,qBAAAA,CAAAA,cAAAA,YAA0BQ;;;;;;aAMvDf;cACCD,GAAAA,CAAIiB;;sBAEID;;;;;;;;8BAQQb,cAAcgB,QAAQd;;;;;;;2BAOzBF,2BAA2BC,eAAee;;;;;WAK1DA"}