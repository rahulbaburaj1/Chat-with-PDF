{"version":3,"file":"event_source_parse.d.ts","names":["IterableReadableStream","EventStreamContentType","EventSourceMessage","getBytes","Uint8Array","ReadableStream","Promise","getLines","ArrayBufferLike","getMessages","convertEventStreamToIterableReadableDataStream"],"sources":["../../src/utils/event_source_parse.d.ts"],"sourcesContent":["import { IterableReadableStream } from \"@langchain/core/utils/stream\";\nexport declare const EventStreamContentType = \"text/event-stream\";\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\nexport interface EventSourceMessage {\n    /** The event ID to set the EventSource object's last event ID value. */\n    id: string;\n    /** A string identifying the type of event described. */\n    event: string;\n    /** The event data */\n    data: string;\n    /** The reconnection interval (in milliseconds) to wait before retrying the connection */\n    retry?: number;\n}\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nexport declare function getBytes(stream: ReadableStream<Uint8Array>, onChunk: (arr: Uint8Array, flush?: boolean) => void): Promise<void>;\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nexport declare function getLines(onLine: (line: Uint8Array, fieldLength: number, flush?: boolean) => void): (arr: Uint8Array<ArrayBufferLike>, flush?: boolean | undefined) => void;\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nexport declare function getMessages(onMessage?: (msg: EventSourceMessage) => void, onId?: (id: string) => void, onRetry?: (retry: number) => void): (line: Uint8Array<ArrayBufferLike>, fieldLength: number, flush?: boolean | undefined) => void;\nexport declare function convertEventStreamToIterableReadableDataStream(stream: ReadableStream): IterableReadableStream<any>;\n"],"mappings":";;;;;;cACqBC,sBAAAA;;;;;UAKJC,kBAAAA;;;;;;;EALID;EAKJC,KAAAA,CAAAA,EAAAA,MAAAA;AAgBjB;;;;;;AAAkI;AAO1GK,iBAPAJ,QAAAA,CAOQ,MAAA,EAPSE,cAOT,CAPwBD,UAOxB,CAAA,EAAA,OAAA,EAAA,CAAA,GAAA,EAPoDA,UAOpD,EAAA,KAAA,CAAA,EAAA,OAAA,EAAA,GAAA,IAAA,CAAA,EAP2FE,OAO3F,CAAA,IAAA,CAAA;;;;;AAA4F;AAQ5H;AAAmC,iBARXC,QAAAA,CAQW,MAAA,EAAA,CAAA,IAAA,EARaH,UAQb,EAAA,WAAA,EAAA,MAAA,EAAA,KAAA,CAAA,EAAA,OAAA,EAAA,GAAA,IAAA,CAAA,EAAA,CAAA,GAAA,EAR+EA,UAQ/E,CAR0FI,eAQ1F,CAAA,EAAA,KAAA,CAAA,EAAA,OAAA,GAAA,SAAA,EAAA,GAAA,IAAA;;;;AAAkI;AACrK;;;AAAgGR,iBADxES,WAAAA,CACwET,SAAAA,CAAAA,EAAAA,CAAAA,GAAAA,EAD1CE,kBAC0CF,EAAAA,GAAAA,IAAAA,EAAAA,IAAAA,CAAAA,EAAAA,CAAAA,EAAAA,EAAAA,MAAAA,EAAAA,GAAAA,IAAAA,EAAAA,OAAAA,CAAAA,EAAAA,CAAAA,KAAAA,EAAAA,MAAAA,EAAAA,GAAAA,IAAAA,CAAAA,EAAAA,CAAAA,IAAAA,EAD2DI,UAC3DJ,CADsEQ,eACtER,CAAAA,EAAAA,WAAAA,EAAAA,MAAAA,EAAAA,KAAAA,CAAAA,EAAAA,OAAAA,GAAAA,SAAAA,EAAAA,GAAAA,IAAAA;AAAsB,iBAA9FU,8CAAAA,CAA8F,MAAA,EAAvCL,cAAuC,CAAA,EAAtBL,sBAAsB,CAAA,GAAA,CAAA"}