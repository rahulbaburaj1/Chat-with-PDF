{"version":3,"file":"usermanager.js","names":[],"sources":["../../../../../../../../../node_modules/.pnpm/couchbase@4.5.0/node_modules/couchbase/dist/usermanager.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UserManager = exports.Group = exports.UserAndMetadata = exports.User = exports.RoleAndOrigin = exports.RoleAndDescription = exports.Role = exports.Origin = void 0;\nconst bindingutilities_1 = require(\"./bindingutilities\");\nconst utilities_1 = require(\"./utilities\");\n/**\n * Contains information about an origin for a role.\n *\n * @category Management\n */\nclass Origin {\n    /**\n     * @internal\n     */\n    constructor(data) {\n        this.type = data.type;\n        this.name = data.name;\n    }\n    /**\n     * @internal\n     */\n    static _fromCppData(data) {\n        return new Origin({\n            type: data.type,\n            name: data.name,\n        });\n    }\n}\nexports.Origin = Origin;\n/**\n * Contains information about a role.\n *\n * @category Management\n */\nclass Role {\n    /**\n     * @internal\n     */\n    constructor(data) {\n        this.name = data.name;\n        this.bucket = data.bucket;\n        this.scope = data.scope;\n        this.collection = data.collection;\n    }\n    /**\n     * @internal\n     */\n    static _fromCppData(data) {\n        return new Role({\n            name: data.name,\n            bucket: data.bucket,\n            scope: data.scope,\n            collection: data.collection,\n        });\n    }\n    /**\n     * @internal\n     */\n    static _toCppData(data) {\n        return {\n            name: data.name,\n            bucket: data.bucket,\n            scope: data.scope,\n            collection: data.collection,\n        };\n    }\n}\nexports.Role = Role;\n/**\n * Contains information about a role along with its description.\n *\n * @category Management\n */\nclass RoleAndDescription extends Role {\n    /**\n     * @internal\n     */\n    constructor(data) {\n        super(data);\n        this.displayName = data.displayName;\n        this.description = data.description;\n    }\n    /**\n     * @internal\n     */\n    static _fromCppData(data) {\n        const role = Role._fromCppData(data);\n        return new RoleAndDescription({\n            ...role,\n            displayName: data.name,\n            description: data.description,\n        });\n    }\n}\nexports.RoleAndDescription = RoleAndDescription;\n/**\n * Contains information about a role along with its origin.\n *\n * @category Management\n */\nclass RoleAndOrigin extends Role {\n    /**\n     * @internal\n     */\n    constructor(data) {\n        super(data);\n        this.origins = data.origins;\n    }\n    /**\n     * @internal\n     */\n    static _fromCppData(data) {\n        const origins = data.origins.map((origin) => Origin._fromCppData(origin));\n        return new RoleAndOrigin({\n            ...Role._fromCppData({\n                name: data.name,\n                bucket: data.bucket,\n                scope: data.scope,\n                collection: data.collection,\n            }),\n            origins,\n        });\n    }\n}\nexports.RoleAndOrigin = RoleAndOrigin;\n/**\n * Contains information about a user.\n *\n * @category Management\n */\nclass User {\n    /**\n     * @internal\n     */\n    constructor(data) {\n        this.username = data.username;\n        this.displayName = data.displayName;\n        this.groups = data.groups;\n        this.roles = data.roles;\n    }\n    /**\n     * @internal\n     */\n    static _fromCppData(data) {\n        return new User({\n            username: data.username,\n            displayName: data.display_name,\n            groups: data.groups,\n            roles: data.roles.map((role) => Role._fromCppData(role)),\n            password: undefined,\n        });\n    }\n    /**\n     * @internal\n     */\n    static _toCppData(data) {\n        const roles = [];\n        if (data.roles) {\n            data.roles.forEach((role) => {\n                if (typeof role === 'string') {\n                    roles.push({\n                        name: role,\n                    });\n                }\n                else {\n                    roles.push(Role._toCppData(role));\n                }\n            });\n        }\n        return {\n            username: data.username,\n            display_name: data.displayName,\n            groups: data.groups ? data.groups : [],\n            roles: roles,\n            password: data.password,\n        };\n    }\n}\nexports.User = User;\n/**\n * Contains information about a user along with some additional meta-data\n * about that user.\n *\n * @category Management\n */\nclass UserAndMetadata extends User {\n    /**\n     * Same as {@link effectiveRoles}, which already contains the roles\n     * including their origins.\n     *\n     * @deprecated Use {@link effectiveRoles} instead.\n     */\n    get effectiveRolesAndOrigins() {\n        return this.effectiveRoles;\n    }\n    /**\n     * @internal\n     */\n    constructor(data) {\n        super(data);\n        this.domain = data.domain;\n        this.effectiveRoles = data.effectiveRoles;\n        this.passwordChanged = data.passwordChanged;\n        this.externalGroups = data.externalGroups;\n    }\n    /**\n     * @internal\n     */\n    static _fromCppData(data) {\n        const user = User._fromCppData({\n            username: data.username,\n            display_name: data.display_name,\n            groups: data.groups,\n            roles: data.roles,\n            password: data.password,\n        });\n        const effectiveRoles = data.effective_roles.map((erole) => RoleAndOrigin._fromCppData(erole));\n        return new UserAndMetadata({\n            ...user,\n            domain: (0, bindingutilities_1.authDomainFromCpp)(data.domain),\n            effectiveRoles: effectiveRoles,\n            effectiveRolesAndOrigins: effectiveRoles,\n            passwordChanged: data.password_changed\n                ? new Date(data.password_changed)\n                : undefined,\n            externalGroups: data.external_groups,\n        });\n    }\n}\nexports.UserAndMetadata = UserAndMetadata;\n/**\n * Contains information about a group.\n *\n * @category Management\n */\nclass Group {\n    /**\n     * @internal\n     */\n    constructor(data) {\n        this.name = data.name;\n        this.description = data.description;\n        this.roles = data.roles;\n        this.ldapGroupReference = data.ldapGroupReference;\n    }\n    /**\n     * @internal\n     */\n    static _fromCppData(data) {\n        return new Group({\n            name: data.name,\n            description: data.description || '',\n            roles: data.roles.map((role) => Role._fromCppData(role)),\n            ldapGroupReference: data.ldap_group_reference,\n        });\n    }\n    /**\n     * @internal\n     */\n    static _toCppData(data) {\n        const roles = [];\n        if (data.roles) {\n            data.roles.forEach((role) => {\n                if (typeof role === 'string') {\n                    roles.push({\n                        name: role,\n                    });\n                }\n                else {\n                    roles.push(Role._toCppData(role));\n                }\n            });\n        }\n        return {\n            name: data.name,\n            description: data.description,\n            roles: roles,\n            ldap_group_reference: data.ldapGroupReference,\n        };\n    }\n}\nexports.Group = Group;\n/**\n * UserManager is an interface which enables the management of users,\n * groups and roles for the cluster.\n *\n * @category Management\n */\nclass UserManager {\n    /**\n     * @internal\n     */\n    constructor(cluster) {\n        this._cluster = cluster;\n    }\n    /**\n     * Returns a specific user by their username.\n     *\n     * @param username The username of the user to fetch.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async getUser(username, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const cppDomain = (0, bindingutilities_1.authDomainToCpp)(options.domainName || 'local');\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementUserGet({\n                username: username,\n                domain: cppDomain,\n                timeout: timeout,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(null, UserAndMetadata._fromCppData(resp.user));\n            });\n        }, callback);\n    }\n    /**\n     * Returns a list of all existing users.\n     *\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async getAllUsers(options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[0];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const cppDomain = (0, bindingutilities_1.authDomainToCpp)(options.domainName || 'local');\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementUserGetAll({\n                domain: cppDomain,\n                timeout: timeout,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                const users = resp.users.map((user) => UserAndMetadata._fromCppData(user));\n                wrapCallback(null, users);\n            });\n        }, callback);\n    }\n    /**\n     * Creates or updates an existing user.\n     *\n     * @param user The user to update.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async upsertUser(user, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const cppDomain = (0, bindingutilities_1.authDomainToCpp)(options.domainName || 'local');\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementUserUpsert({\n                user: User._toCppData(user),\n                domain: cppDomain,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Change password for the currently authenticatd user.\n     *\n     * @param newPassword The new password to be applied.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async changePassword(newPassword, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementChangePassword({\n                newPassword: newPassword,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Drops an existing user.\n     *\n     * @param username The username of the user to drop.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async dropUser(username, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const cppDomain = (0, bindingutilities_1.authDomainToCpp)(options.domainName || 'local');\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementUserDrop({\n                username: username,\n                domain: cppDomain,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Returns a list of roles available on the server.\n     *\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async getRoles(options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[0];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementRoleGetAll({\n                timeout: timeout,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                const roles = resp.roles.map((role) => Role._fromCppData(role));\n                wrapCallback(null, roles);\n            });\n        }, callback);\n    }\n    /**\n     * Returns a group by it's name.\n     *\n     * @param groupName The name of the group to retrieve.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async getGroup(groupName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementGroupGet({\n                name: groupName,\n                timeout: timeout,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(null, Group._fromCppData(resp.group));\n            });\n        }, callback);\n    }\n    /**\n     * Returns a list of all existing groups.\n     *\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async getAllGroups(options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[0];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementGroupGetAll({\n                timeout: timeout,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                const groups = resp.groups.map((group) => Group._fromCppData(group));\n                wrapCallback(null, groups);\n            });\n        }, callback);\n    }\n    /**\n     * Creates or updates an existing group.\n     *\n     * @param group The group to update.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async upsertGroup(group, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementGroupUpsert({\n                group: Group._toCppData(group),\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Drops an existing group.\n     *\n     * @param groupName The name of the group to drop.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async dropGroup(groupName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementGroupDrop({\n                name: groupName,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n}\nexports.UserManager = UserManager;\n"],"x_google_ignoreList":[0],"mappings":"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"}