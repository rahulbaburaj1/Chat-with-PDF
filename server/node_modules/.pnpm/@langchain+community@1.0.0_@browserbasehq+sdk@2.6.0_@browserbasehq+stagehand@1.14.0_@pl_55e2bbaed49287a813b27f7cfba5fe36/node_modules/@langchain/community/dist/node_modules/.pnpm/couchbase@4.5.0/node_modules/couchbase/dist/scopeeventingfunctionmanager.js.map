{"version":3,"file":"scopeeventingfunctionmanager.js","names":[],"sources":["../../../../../../../../../node_modules/.pnpm/couchbase@4.5.0/node_modules/couchbase/dist/scopeeventingfunctionmanager.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ScopeEventingFunctionManager = void 0;\nconst utilities_1 = require(\"./utilities\");\nconst bindingutilities_1 = require(\"./bindingutilities\");\nconst eventingfunctionmanager_1 = require(\"./eventingfunctionmanager\");\n/**\n * ScopeEventingFunctionManager provides an interface for managing the\n * eventing functions on the scope.\n * Uncommitted: This API is subject to change in the future.\n *\n * @category Management\n */\nclass ScopeEventingFunctionManager {\n    /**\n     * @internal\n     */\n    constructor(cluster, bucketName, scopeName) {\n        this._cluster = cluster;\n        this._bucketName = bucketName;\n        this._scopeName = scopeName;\n    }\n    /**\n     * Creates or updates an eventing function.\n     *\n     * @param functionDefinition The description of the eventing function to upsert.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async upsertFunction(functionDefinition, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementEventingUpsertFunction({\n                function: eventingfunctionmanager_1.EventingFunction._toCppData(functionDefinition),\n                bucket_name: this._bucketName,\n                scope_name: this._scopeName,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Deletes an eventing function.\n     *\n     * @param name The name of the eventing function to delete.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async dropFunction(name, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementEventingDropFunction({\n                name: name,\n                bucket_name: this._bucketName,\n                scope_name: this._scopeName,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Fetches all eventing functions.\n     *\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async getAllFunctions(options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[0];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementEventingGetAllFunctions({\n                bucket_name: this._bucketName,\n                scope_name: this._scopeName,\n                timeout: timeout,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                const functions = resp.functions.map((functionData) => eventingfunctionmanager_1.EventingFunction._fromCppData(functionData));\n                wrapCallback(null, functions);\n            });\n        }, callback);\n    }\n    /**\n     * Fetches a specific eventing function.\n     *\n     * @param name The name of the eventing function to fetch.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async getFunction(name, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementEventingGetFunction({\n                name: name,\n                bucket_name: this._bucketName,\n                scope_name: this._scopeName,\n                timeout: timeout,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                const eventingFunction = eventingfunctionmanager_1.EventingFunction._fromCppData(resp.function);\n                wrapCallback(null, eventingFunction);\n            });\n        }, callback);\n    }\n    /**\n     * Deploys an eventing function.\n     *\n     * @param name The name of the eventing function to deploy.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async deployFunction(name, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementEventingDeployFunction({\n                name: name,\n                bucket_name: this._bucketName,\n                scope_name: this._scopeName,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Undeploys an eventing function.\n     *\n     * @param name The name of the eventing function to undeploy.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async undeployFunction(name, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementEventingUndeployFunction({\n                name: name,\n                bucket_name: this._bucketName,\n                scope_name: this._scopeName,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Pauses an eventing function.\n     *\n     * @param name The name of the eventing function to pause.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async pauseFunction(name, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementEventingPauseFunction({\n                name: name,\n                bucket_name: this._bucketName,\n                scope_name: this._scopeName,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Resumes an eventing function.\n     *\n     * @param name The name of the eventing function to resume.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async resumeFunction(name, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementEventingResumeFunction({\n                name: name,\n                bucket_name: this._bucketName,\n                scope_name: this._scopeName,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Fetches the status of all eventing functions.\n     *\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async functionsStatus(options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[0];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementEventingGetStatus({\n                bucket_name: this._bucketName,\n                scope_name: this._scopeName,\n                timeout: timeout,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                const state = eventingfunctionmanager_1.EventingState._fromCppData(resp.status);\n                wrapCallback(null, state);\n            });\n        }, callback);\n    }\n}\nexports.ScopeEventingFunctionManager = ScopeEventingFunctionManager;\n"],"x_google_ignoreList":[0],"mappings":"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"}