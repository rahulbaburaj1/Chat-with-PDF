{"version":3,"file":"transcoders.js","names":[],"sources":["../../../../../../../../../node_modules/.pnpm/couchbase@4.5.0/node_modules/couchbase/dist/transcoders.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RawJsonTranscoder = exports.RawStringTranscoder = exports.RawBinaryTranscoder = exports.DefaultTranscoder = void 0;\nconst NF_JSON = 0x00;\nconst NF_RAW = 0x02;\nconst NF_UTF8 = 0x04;\nconst NF_MASK = 0xff;\nconst NF_UNKNOWN = 0x100;\nconst CF_NONE = 0x00 << 24;\nconst CF_PRIVATE = 0x01 << 24;\nconst CF_JSON = 0x02 << 24;\nconst CF_RAW = 0x03 << 24;\nconst CF_UTF8 = 0x04 << 24;\nconst CF_MASK = 0xff << 24;\n/**\n * The default transcoder implements cross-sdk transcoding capabilities by\n * taking advantage of the common flags specification to ensure compatibility.\n * This transcoder is capable of encoding/decoding any value which is encodable\n * to JSON, and additionally has special-case handling for Buffer objects.\n *\n * @category Key-Value\n */\nclass DefaultTranscoder {\n    /**\n     * Encodes the specified value, returning a buffer and flags that are\n     * stored to the server and later used for decoding.\n     *\n     * @param value The value to encode.\n     */\n    encode(value) {\n        // If its a buffer, write that directly as raw.\n        if (Buffer.isBuffer(value)) {\n            return [value, CF_RAW | NF_RAW];\n        }\n        // If its a string, encode it as a UTF8 string.\n        if (typeof value === 'string') {\n            return [Buffer.from(value), CF_UTF8 | NF_UTF8];\n        }\n        // Encode it to JSON and save that otherwise.\n        return [Buffer.from(JSON.stringify(value)), CF_JSON | NF_JSON];\n    }\n    /**\n     * Decodes a buffer and flags tuple back to the original type of the\n     * document.\n     *\n     * @param bytes The bytes that were previously encoded.\n     * @param flags The flags associated with the data.\n     */\n    decode(bytes, flags) {\n        let format = flags & NF_MASK;\n        const cfformat = flags & CF_MASK;\n        if (cfformat !== CF_NONE) {\n            if (cfformat === CF_JSON) {\n                format = NF_JSON;\n            }\n            else if (cfformat === CF_RAW) {\n                format = NF_RAW;\n            }\n            else if (cfformat === CF_UTF8) {\n                format = NF_UTF8;\n            }\n            else if (cfformat !== CF_PRIVATE) {\n                // Unknown CF Format!  The following will force\n                //   fallback to reporting RAW data.\n                format = NF_UNKNOWN;\n            }\n        }\n        if (format === NF_UTF8) {\n            return bytes.toString('utf8');\n        }\n        else if (format === NF_RAW) {\n            return bytes;\n        }\n        else if (format === NF_JSON) {\n            try {\n                return JSON.parse(bytes.toString('utf8'));\n            }\n            catch (e) {\n                // If we encounter a parse error, assume that we need\n                // to return bytes instead of an object.\n                return bytes;\n            }\n        }\n        // Default to returning a Buffer if all else fails.\n        return bytes;\n    }\n}\nexports.DefaultTranscoder = DefaultTranscoder;\n/**\n * The raw binary transcoder provides an explicit mechanism for storing and retrieving raw\n * byte data.\n *\n * @category Key-Value\n */\nclass RawBinaryTranscoder {\n    /**\n     * Encodes the specified value, returning a buffer and flags that are\n     * stored to the server and later used for decoding.\n     *\n     * @param value The value to encode.\n     */\n    encode(value) {\n        // If its a buffer, write that directly as raw.\n        if (Buffer.isBuffer(value)) {\n            return [value, CF_RAW | NF_RAW];\n        }\n        throw new Error('Only binary data supported by RawBinaryTranscoder.');\n    }\n    /**\n     * Decodes a buffer and flags tuple back to the original type of the\n     * document.\n     *\n     * @param bytes The bytes that were previously encoded.\n     * @param flags The flags associated with the data.\n     */\n    decode(bytes, flags) {\n        let format = flags & NF_MASK;\n        const cfformat = flags & CF_MASK;\n        if (cfformat !== CF_NONE) {\n            if (cfformat === CF_JSON) {\n                format = NF_JSON;\n            }\n            else if (cfformat === CF_RAW) {\n                format = NF_RAW;\n            }\n            else if (cfformat === CF_UTF8) {\n                format = NF_UTF8;\n            }\n            else if (cfformat !== CF_PRIVATE) {\n                // Unknown CF Format!  The following will force\n                //   fallback to reporting RAW data.\n                format = NF_UNKNOWN;\n            }\n        }\n        if (format === NF_RAW) {\n            return bytes;\n        }\n        else if (format === NF_UTF8) {\n            throw new Error('String format not supported by RawBinaryTranscoder.');\n        }\n        else if (format === NF_JSON) {\n            throw new Error('JSON format not supported by RawBinaryTranscoder.');\n        }\n        else if (format === NF_UNKNOWN) {\n            throw new Error('Unknown format not supported by RawBinaryTranscoder.');\n        }\n        else {\n            throw new Error(`Unrecognized format provided: ${format}.`);\n        }\n    }\n}\nexports.RawBinaryTranscoder = RawBinaryTranscoder;\n/**\n * The raw string transcoder provides an explicit mechanism for storing and retrieving raw\n * string data.\n *\n * @category Key-Value\n */\nclass RawStringTranscoder {\n    /**\n     * Encodes the specified value, returning a buffer and flags that are\n     * stored to the server and later used for decoding.\n     *\n     * @param value The value to encode.\n     */\n    encode(value) {\n        // If its a string, encode it as a UTF8 string.\n        if (typeof value === 'string') {\n            return [Buffer.from(value), CF_UTF8 | NF_UTF8];\n        }\n        throw new Error('Only string data supported by RawStringTranscoder.');\n    }\n    /**\n     * Decodes a buffer and flags tuple back to the original type of the\n     * document.\n     *\n     * @param bytes The bytes that were previously encoded.\n     * @param flags The flags associated with the data.\n     */\n    decode(bytes, flags) {\n        let format = flags & NF_MASK;\n        const cfformat = flags & CF_MASK;\n        if (cfformat !== CF_NONE) {\n            if (cfformat === CF_JSON) {\n                format = NF_JSON;\n            }\n            else if (cfformat === CF_RAW) {\n                format = NF_RAW;\n            }\n            else if (cfformat === CF_UTF8) {\n                format = NF_UTF8;\n            }\n            else if (cfformat !== CF_PRIVATE) {\n                // Unknown CF Format!  The following will force\n                //   fallback to reporting RAW data.\n                format = NF_UNKNOWN;\n            }\n        }\n        if (format === NF_UTF8) {\n            return bytes.toString('utf8');\n        }\n        else if (format === NF_RAW) {\n            throw new Error('Binary format not supported by RawStringTranscoder.');\n        }\n        else if (format === NF_JSON) {\n            throw new Error('JSON format not supported by RawStringTranscoder.');\n        }\n        else if (format === NF_UNKNOWN) {\n            throw new Error('Unknown format not supported by RawStringTranscoder.');\n        }\n        else {\n            throw new Error(`Unrecognized format provided: ${format}.`);\n        }\n    }\n}\nexports.RawStringTranscoder = RawStringTranscoder;\n/**\n * The raw JSON transcoder provides an explicit mechanism for storing and retrieving JSON data.\n *\n * @category Key-Value\n */\nclass RawJsonTranscoder {\n    /**\n     * Encodes the specified value, returning a buffer and flags that are\n     * stored to the server and later used for decoding.\n     *\n     * @param value The value to encode.\n     */\n    encode(value) {\n        if (typeof value === 'string') {\n            return [Buffer.from(value), CF_JSON | NF_JSON];\n        }\n        if (Buffer.isBuffer(value)) {\n            return [value, CF_JSON | NF_JSON];\n        }\n        throw new Error('Only binary and string data supported by RawJsonTranscoder.');\n    }\n    /**\n     * Decodes a buffer and flags tuple back to the original type of the\n     * document.\n     *\n     * @param bytes The bytes that were previously encoded.\n     * @param flags The flags associated with the data.\n     */\n    decode(bytes, flags) {\n        let format = flags & NF_MASK;\n        const cfformat = flags & CF_MASK;\n        if (cfformat !== CF_NONE) {\n            if (cfformat === CF_JSON) {\n                format = NF_JSON;\n            }\n            else if (cfformat === CF_RAW) {\n                format = NF_RAW;\n            }\n            else if (cfformat === CF_UTF8) {\n                format = NF_UTF8;\n            }\n            else if (cfformat !== CF_PRIVATE) {\n                // Unknown CF Format!  The following will force\n                //   fallback to reporting RAW data.\n                format = NF_UNKNOWN;\n            }\n        }\n        if (format === NF_UTF8) {\n            throw new Error('string format not supported by RawJsonTranscoder.');\n        }\n        else if (format === NF_RAW) {\n            throw new Error('Binary format not supported by RawJsonTranscoder.');\n        }\n        else if (format === NF_JSON) {\n            return bytes;\n        }\n        else if (format === NF_UNKNOWN) {\n            throw new Error('Unknown format not supported by RawJsonTranscoder.');\n        }\n        else {\n            throw new Error(`Unrecognized format provided: ${format}.`);\n        }\n    }\n}\nexports.RawJsonTranscoder = RawJsonTranscoder;\n"],"x_google_ignoreList":[0],"mappings":"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"}