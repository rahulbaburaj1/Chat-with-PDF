import { CassandraClientArgs, CassandraTable, CassandraTableArgs, Column, WhereClause } from "../utils/cassandra.cjs";
import { Document } from "@langchain/core/documents";
import { EmbeddingsInterface } from "@langchain/core/embeddings";
import { MaxMarginalRelevanceSearchOptions, VectorStore } from "@langchain/core/vectorstores";

//#region src/vectorstores/cassandra.d.ts
declare namespace cassandra_d_exports {
  export { CassandraLibArgs, CassandraStore, SupportedVectorTypes };
}
type SupportedVectorTypes = "cosine" | "dot_product" | "euclidean";
interface CassandraLibArgs extends CassandraClientArgs, Omit<CassandraTableArgs, "nonKeyColumns" | "keyspace"> {
  // keyspace is optional on CassandraClientArgs, but mandatory on CassandraTableArgs; we make it mandatory here
  keyspace: string;
  vectorType?: SupportedVectorTypes;
  dimensions: number;
  metadataColumns?: Column[];
  nonKeyColumns?: Column | Column[];
}
/**
 * Class for interacting with the Cassandra database. It extends the
 * VectorStore class and provides methods for adding vectors and
 * documents, searching for similar vectors, and creating instances from
 * texts or documents.
 */
declare class CassandraStore extends VectorStore {
  FilterType: WhereClause;
  private readonly table;
  private readonly idColumnAutoName = "id";
  private readonly idColumnAutoGenerated;
  private readonly vectorColumnName = "vector";
  private readonly vectorColumn;
  private readonly textColumnName = "text";
  private readonly textColumn;
  private readonly metadataColumnDefaultName = "metadata";
  private readonly metadataColumns;
  private readonly similarityColumn;
  private readonly embeddingColumnAlias = "embedding";
  _vectorstoreType(): string;
  private _cleanArgs;
  private _getColumnByName;
  constructor(embeddings: EmbeddingsInterface, args: CassandraLibArgs);
  /**
   * Method to save vectors to the Cassandra database.
   * @param vectors Vectors to save.
   * @param documents The documents associated with the vectors.
   * @returns Promise that resolves when the vectors have been added.
   */
  addVectors(vectors: number[][], documents: Document[]): Promise<void>;
  getCassandraTable(): CassandraTable;
  /**
   * Method to add documents to the Cassandra database.
   * @param documents The documents to add.
   * @returns Promise that resolves when the documents have been added.
   */
  addDocuments(documents: Document[]): Promise<void>;
  /**
   * Helper method to search for vectors that are similar to a given query vector.
   * @param query The query vector.
   * @param k The number of similar Documents to return.
   * @param filter Optional filter to be applied as a WHERE clause.
   * @param includeEmbedding Whether to include the embedding vectors in the results.
   * @returns Promise that resolves with an array of tuples, each containing a Document and a score.
   */
  search(query: number[], k: number, filter?: WhereClause, includeEmbedding?: boolean): Promise<[Document, number][]>;
  /**
   * Method to search for vectors that are similar to a given query vector.
   * @param query The query vector.
   * @param k The number of similar Documents to return.
   * @param filter Optional filter to be applied as a WHERE clause.
   * @returns Promise that resolves with an array of tuples, each containing a Document and a score.
   */
  similaritySearchVectorWithScore(query: number[], k: number, filter?: WhereClause): Promise<[Document, number][]>;
  /**
   * Method to search for vectors that are similar to a given query vector, but with
   * the results selected using the maximal marginal relevance.
   * @param query The query string.
   * @param options.k The number of similar Documents to return.
   * @param options.fetchK=4*k The number of records to fetch before passing to the MMR algorithm.
   * @param options.lambda=0.5 The degree of diversity among the results between 0 (maximum diversity) and 1 (minimum diversity).
   * @param options.filter Optional filter to be applied as a WHERE clause.
   * @returns List of documents selected by maximal marginal relevance.
   */
  maxMarginalRelevanceSearch(query: string, options: MaxMarginalRelevanceSearchOptions<this["FilterType"]>): Promise<Document[]>;
  /**
   * Static method to create an instance of CassandraStore from texts.
   * @param texts The texts to use.
   * @param metadatas The metadata associated with the texts.
   * @param embeddings The embeddings to use.
   * @param args The arguments for the CassandraStore.
   * @returns Promise that resolves with a new instance of CassandraStore.
   */
  static fromTexts(texts: string[], metadatas: object | object[], embeddings: EmbeddingsInterface, args: CassandraLibArgs): Promise<CassandraStore>;
  /**
   * Static method to create an instance of CassandraStore from documents.
   * @param docs The documents to use.
   * @param embeddings The embeddings to use.
   * @param args The arguments for the CassandraStore.
   * @returns Promise that resolves with a new instance of CassandraStore.
   */
  static fromDocuments(docs: Document[], embeddings: EmbeddingsInterface, args: CassandraLibArgs): Promise<CassandraStore>;
  /**
   * Static method to create an instance of CassandraStore from an existing
   * index.
   * @param embeddings The embeddings to use.
   * @param args The arguments for the CassandraStore.
   * @returns Promise that resolves with a new instance of CassandraStore.
   */
  static fromExistingIndex(embeddings: EmbeddingsInterface, args: CassandraLibArgs): Promise<CassandraStore>;
}
//#endregion
export { CassandraLibArgs, CassandraStore, SupportedVectorTypes, cassandra_d_exports };
//# sourceMappingURL=cassandra.d.cts.map