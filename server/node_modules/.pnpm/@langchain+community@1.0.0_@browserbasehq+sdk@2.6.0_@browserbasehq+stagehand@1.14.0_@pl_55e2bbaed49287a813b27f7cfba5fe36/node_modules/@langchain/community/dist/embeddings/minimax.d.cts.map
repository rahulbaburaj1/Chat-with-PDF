{"version":3,"file":"minimax.d.cts","names":["Embeddings","EmbeddingsParams","ConfigurationParameters","MinimaxEmbeddingsParams","CreateMinimaxEmbeddingRequest","MinimaxEmbeddings","Record","Partial","Promise"],"sources":["../../src/embeddings/minimax.d.ts"],"sourcesContent":["import { Embeddings, EmbeddingsParams } from \"@langchain/core/embeddings\";\nimport { ConfigurationParameters } from \"../chat_models/minimax.js\";\n/**\n * Interface for MinimaxEmbeddings parameters. Extends EmbeddingsParams and\n * defines additional parameters specific to the MinimaxEmbeddings class.\n */\nexport interface MinimaxEmbeddingsParams extends EmbeddingsParams {\n    /**\n     * Model name to use\n     * Alias for `model`\n     */\n    modelName: string;\n    /** Model name to use */\n    model: string;\n    /**\n     * API key to use when making requests. Defaults to the value of\n     * `MINIMAX_GROUP_ID` environment variable.\n     */\n    minimaxGroupId?: string;\n    /**\n     * Secret key to use when making requests. Defaults to the value of\n     * `MINIMAX_API_KEY` environment variable.\n     * Alias for `apiKey`\n     */\n    minimaxApiKey?: string;\n    /**\n     * Secret key to use when making requests. Defaults to the value of\n     * `MINIMAX_API_KEY` environment variable.\n     */\n    apiKey?: string;\n    /**\n     * The maximum number of documents to embed in a single request. This is\n     * limited by the Minimax API to a maximum of 4096.\n     */\n    batchSize?: number;\n    /**\n     * Whether to strip new lines from the input text. This is recommended by\n     * Minimax, but may not be suitable for all use cases.\n     */\n    stripNewLines?: boolean;\n    /**\n     *  The target use-case after generating the vector.\n     *  When using embeddings, the vector of the target content is first generated through the db and stored in the vector database,\n     *  and then the vector of the retrieval text is generated through the query.\n     *  Note: For the parameters of the partial algorithm, we adopted a separate algorithm plan for query and db.\n     *  Therefore, for a paragraph of text, if it is to be used as a retrieval text, it should use the db,\n     *  and if it is used as a retrieval text, it should use the query.\n     */\n    type?: \"db\" | \"query\";\n}\nexport interface CreateMinimaxEmbeddingRequest {\n    /**\n     * @type {string}\n     * @memberof CreateMinimaxEmbeddingRequest\n     */\n    model: string;\n    /**\n     *  Text to generate vector expectation\n     * @type {CreateEmbeddingRequestInput}\n     * @memberof CreateMinimaxEmbeddingRequest\n     */\n    texts: string[];\n    /**\n     *  The target use-case after generating the vector. When using embeddings,\n     *  first generate the vector of the target content through the db and store it in the vector database,\n     *  and then generate the vector of the retrieval text through the query.\n     *  Note: For the parameter of the algorithm, we use the algorithm scheme of query and db separation,\n     *  so a text, if it is to be retrieved as a text, should use the db,\n     *  if it is used as a retrieval text, should use the query.\n     * @type {string}\n     * @memberof CreateMinimaxEmbeddingRequest\n     */\n    type: \"db\" | \"query\";\n}\n/**\n * Class for generating embeddings using the Minimax API. Extends the\n * Embeddings class and implements MinimaxEmbeddingsParams\n * @example\n * ```typescript\n * const embeddings = new MinimaxEmbeddings();\n *\n * // Embed a single query\n * const queryEmbedding = await embeddings.embedQuery(\"Hello world\");\n * console.log(queryEmbedding);\n *\n * // Embed multiple documents\n * const documentsEmbedding = await embeddings.embedDocuments([\n *   \"Hello world\",\n *   \"Bye bye\",\n * ]);\n * console.log(documentsEmbedding);\n * ```\n */\nexport declare class MinimaxEmbeddings extends Embeddings implements MinimaxEmbeddingsParams {\n    modelName: string;\n    model: string;\n    batchSize: number;\n    stripNewLines: boolean;\n    minimaxGroupId?: string;\n    minimaxApiKey?: string;\n    apiKey?: string;\n    type: \"db\" | \"query\";\n    apiUrl: string;\n    basePath?: string;\n    headers?: Record<string, string>;\n    constructor(fields?: Partial<MinimaxEmbeddingsParams> & {\n        configuration?: ConfigurationParameters;\n    });\n    /**\n     * Method to generate embeddings for an array of documents. Splits the\n     * documents into batches and makes requests to the Minimax API to generate\n     * embeddings.\n     * @param texts Array of documents to generate embeddings for.\n     * @returns Promise that resolves to a 2D array of embeddings for each document.\n     */\n    embedDocuments(texts: string[]): Promise<number[][]>;\n    /**\n     * Method to generate an embedding for a single document. Calls the\n     * embeddingWithRetry method with the document as the input.\n     * @param text Document to generate an embedding for.\n     * @returns Promise that resolves to an embedding for the document.\n     */\n    embedQuery(text: string): Promise<number[]>;\n    private embeddingWithRetry;\n}\n"],"mappings":";;;;;;;;;;;UAMiBG,uBAAAA,SAAgCF;;;;;EAAhCE,SAAAA,EAAAA,MAAAA;EA4CAC;EA2CIC,KAAAA,EAAAA,MAAAA;EAAiB;;;;EAYN,cACRH,CAAAA,EAAAA,MAAAA;EAAuB;;;;AAb6C;;;;;;;;;;;;;;;;;;;;;;;;;;;UA3C3EE,6BAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cA2CIC,iBAAAA,SAA0BL,UAAAA,YAAsBG;;;;;;;;;;;YAWvDG;uBACWC,QAAQJ;oBACTD;;;;;;;;;mCASaM;;;;;;;4BAOPA"}