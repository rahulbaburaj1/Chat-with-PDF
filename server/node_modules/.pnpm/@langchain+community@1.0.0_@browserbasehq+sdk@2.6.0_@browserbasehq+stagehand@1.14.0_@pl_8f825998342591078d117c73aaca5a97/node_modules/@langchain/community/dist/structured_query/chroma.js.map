{"version":3,"file":"chroma.js","names":["func: Operator | Comparator","operation: Operation","comparison: Comparison","query: StructuredQuery","defaultFilter: this[\"VisitStructuredQueryOutput\"][\"filter\"] | undefined","generatedFilter: this[\"VisitStructuredQueryOutput\"][\"filter\"] | undefined","mergeType: \"and\" | \"or\" | \"replace\""],"sources":["../../src/structured_query/chroma.ts"],"sourcesContent":["import {\n  BaseTranslator,\n  Comparator,\n  Comparators,\n  Comparison,\n  Operation,\n  Operator,\n  Operators,\n  StructuredQuery,\n  Visitor,\n  isFilterEmpty,\n  castValue,\n} from \"@langchain/core/structured_query\";\nimport { Chroma } from \"../vectorstores/chroma.js\";\n\n/**\n * Specialized translator for the Chroma vector database. It extends the\n * BasicTranslator class and translates internal query language elements\n * to valid filters. The class defines a subset of allowed logical\n * operators and comparators that can be used in the translation process.\n * @example\n * ```typescript\n * const chromaTranslator = new ChromaTranslator();\n * const selfQueryRetriever = new SelfQueryRetriever({\n *   llm: new ChatOpenAI({ model: \"gpt-4o-mini\" }),\n *   vectorStore: new Chroma(),\n *   documentContents: \"Brief summary of a movie\",\n *   attributeInfo: [],\n *   structuredQueryTranslator: chromaTranslator,\n * });\n *\n * const relevantDocuments = await selfQueryRetriever.getRelevantDocuments(\n *   \"Which movies are directed by Greta Gerwig?\",\n * );\n * ```\n */\nexport class ChromaTranslator<T extends Chroma> extends BaseTranslator<T> {\n  declare VisitOperationOutput: T[\"FilterType\"];\n\n  declare VisitComparisonOutput: T[\"FilterType\"];\n\n  allowedOperators: Operator[] = [Operators.and, Operators.or];\n\n  allowedComparators: Comparator[] = [\n    Comparators.eq,\n    Comparators.ne,\n    Comparators.gt,\n    Comparators.gte,\n    Comparators.lt,\n    Comparators.lte,\n  ];\n\n  formatFunction(func: Operator | Comparator): string {\n    if (func in Comparators) {\n      if (\n        this.allowedComparators.length > 0 &&\n        this.allowedComparators.indexOf(func as Comparator) === -1\n      ) {\n        throw new Error(\n          `Comparator ${func} not allowed. Allowed comparators: ${this.allowedComparators.join(\n            \", \"\n          )}`\n        );\n      }\n    } else if (func in Operators) {\n      if (\n        this.allowedOperators.length > 0 &&\n        this.allowedOperators.indexOf(func as Operator) === -1\n      ) {\n        throw new Error(\n          `Operator ${func} not allowed. Allowed operators: ${this.allowedOperators.join(\n            \", \"\n          )}`\n        );\n      }\n    } else {\n      throw new Error(\"Unknown comparator or operator\");\n    }\n    return `$${func}`;\n  }\n\n  visitOperation(operation: Operation): this[\"VisitOperationOutput\"] {\n    const args = operation.args?.map((arg) => arg.accept(this as Visitor));\n    return {\n      [this.formatFunction(operation.operator)]: args,\n    } as this[\"VisitOperationOutput\"];\n  }\n\n  visitComparison(comparison: Comparison): this[\"VisitComparisonOutput\"] {\n    return {\n      [comparison.attribute]: {\n        [this.formatFunction(comparison.comparator)]: castValue(\n          comparison.value\n        ),\n      },\n    } as this[\"VisitComparisonOutput\"];\n  }\n\n  visitStructuredQuery(\n    query: StructuredQuery\n  ): this[\"VisitStructuredQueryOutput\"] {\n    let nextArg = {} as this[\"VisitStructuredQueryOutput\"];\n    if (query.filter) {\n      nextArg = {\n        filter: query.filter.accept(this as Visitor),\n      } as this[\"VisitStructuredQueryOutput\"];\n    }\n    return nextArg;\n  }\n\n  mergeFilters(\n    defaultFilter: this[\"VisitStructuredQueryOutput\"][\"filter\"] | undefined,\n    generatedFilter: this[\"VisitStructuredQueryOutput\"][\"filter\"] | undefined,\n    mergeType: \"and\" | \"or\" | \"replace\" = \"and\",\n    forceDefaultFilter = false\n  ): this[\"VisitStructuredQueryOutput\"][\"filter\"] | undefined {\n    if (isFilterEmpty(defaultFilter) && isFilterEmpty(generatedFilter)) {\n      return undefined;\n    }\n    if (isFilterEmpty(defaultFilter) || mergeType === \"replace\") {\n      if (isFilterEmpty(generatedFilter)) {\n        return undefined;\n      }\n      return generatedFilter;\n    }\n    if (isFilterEmpty(generatedFilter)) {\n      if (forceDefaultFilter) {\n        return defaultFilter;\n      }\n      if (mergeType === \"and\") {\n        return undefined;\n      }\n      return defaultFilter;\n    }\n    if (mergeType === \"and\") {\n      return {\n        $and: [defaultFilter, generatedFilter],\n      } as this[\"VisitStructuredQueryOutput\"][\"filter\"];\n    } else if (mergeType === \"or\") {\n      return {\n        $or: [defaultFilter, generatedFilter],\n      } as this[\"VisitStructuredQueryOutput\"][\"filter\"];\n    } else {\n      throw new Error(\"Unknown merge type\");\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA,IAAa,mBAAb,cAAwD,eAAkB;CAKxE,mBAA+B,CAAC,UAAU,KAAK,UAAU,EAAG;CAE5D,qBAAmC;EACjC,YAAY;EACZ,YAAY;EACZ,YAAY;EACZ,YAAY;EACZ,YAAY;EACZ,YAAY;CACb;CAED,eAAeA,MAAqC;AAClD,MAAI,QAAQ,aACV;OACE,KAAK,mBAAmB,SAAS,KACjC,KAAK,mBAAmB,QAAQ,KAAmB,KAAK,GAExD,OAAM,IAAI,MACR,CAAC,WAAW,EAAE,KAAK,mCAAmC,EAAE,KAAK,mBAAmB,KAC9E,KACD,EAAE;EAEN,WACQ,QAAQ,WACjB;OACE,KAAK,iBAAiB,SAAS,KAC/B,KAAK,iBAAiB,QAAQ,KAAiB,KAAK,GAEpD,OAAM,IAAI,MACR,CAAC,SAAS,EAAE,KAAK,iCAAiC,EAAE,KAAK,iBAAiB,KACxE,KACD,EAAE;EAEN,MAED,OAAM,IAAI,MAAM;AAElB,SAAO,CAAC,CAAC,EAAE,MAAM;CAClB;CAED,eAAeC,WAAoD;EACjE,MAAM,OAAO,UAAU,MAAM,IAAI,CAAC,QAAQ,IAAI,OAAO,KAAgB,CAAC;AACtE,SAAO,GACJ,KAAK,eAAe,UAAU,SAAS,GAAG,KAC5C;CACF;CAED,gBAAgBC,YAAuD;AACrE,SAAO,GACJ,WAAW,YAAY,GACrB,KAAK,eAAe,WAAW,WAAW,GAAG,UAC5C,WAAW,MACZ,CACF,EACF;CACF;CAED,qBACEC,OACoC;EACpC,IAAI,UAAU,CAAE;AAChB,MAAI,MAAM,QACR,UAAU,EACR,QAAQ,MAAM,OAAO,OAAO,KAAgB,CAC7C;AAEH,SAAO;CACR;CAED,aACEC,eACAC,iBACAC,YAAsC,OACtC,qBAAqB,OACqC;AAC1D,MAAI,cAAc,cAAc,IAAI,cAAc,gBAAgB,CAChE,QAAO;AAET,MAAI,cAAc,cAAc,IAAI,cAAc,WAAW;AAC3D,OAAI,cAAc,gBAAgB,CAChC,QAAO;AAET,UAAO;EACR;AACD,MAAI,cAAc,gBAAgB,EAAE;AAClC,OAAI,mBACF,QAAO;AAET,OAAI,cAAc,MAChB,QAAO;AAET,UAAO;EACR;AACD,MAAI,cAAc,MAChB,QAAO,EACL,MAAM,CAAC,eAAe,eAAgB,EACvC;WACQ,cAAc,KACvB,QAAO,EACL,KAAK,CAAC,eAAe,eAAgB,EACtC;MAED,OAAM,IAAI,MAAM;CAEnB;AACF"}