{"version":3,"file":"collection.cjs","names":["err"],"sources":["../../../../../../../../../node_modules/.pnpm/couchbase@4.5.0/node_modules/couchbase/dist/collection.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Collection = void 0;\nconst binarycollection_1 = require(\"./binarycollection\");\nconst binding_1 = __importStar(require(\"./binding\"));\nconst bindingutilities_1 = require(\"./bindingutilities\");\nconst crudoptypes_1 = require(\"./crudoptypes\");\nconst datastructures_1 = require(\"./datastructures\");\nconst errors_1 = require(\"./errors\");\nconst generaltypes_1 = require(\"./generaltypes\");\nconst queryindexmanager_1 = require(\"./queryindexmanager\");\nconst rangeScan_1 = require(\"./rangeScan\");\nconst sdspecs_1 = require(\"./sdspecs\");\nconst sdutils_1 = require(\"./sdutils\");\nconst streamablepromises_1 = require(\"./streamablepromises\");\nconst utilities_1 = require(\"./utilities\");\n/**\n * Exposes the operations which are available to be performed against a collection.\n * Namely the ability to perform KV operations.\n *\n * @category Core\n */\nclass Collection {\n    /**\n     * @internal\n     */\n    static get DEFAULT_NAME() {\n        return '_default';\n    }\n    /**\n    @internal\n    */\n    constructor(scope, collectionName) {\n        this._scope = scope;\n        this._name = collectionName;\n        this._conn = scope.conn;\n        this._kvScanTimeout = 75000;\n        this._scanBatchByteLimit = 15000;\n        this._scanBatchItemLimit = 50;\n    }\n    /**\n    @internal\n    */\n    get conn() {\n        return this._conn;\n    }\n    /**\n    @internal\n    */\n    get cluster() {\n        return this._scope.bucket.cluster;\n    }\n    /**\n    @internal\n    */\n    get scope() {\n        return this._scope;\n    }\n    /**\n    @internal\n    */\n    get transcoder() {\n        return this._scope.transcoder;\n    }\n    /**\n    @internal\n    */\n    _mutationTimeout(durabilityLevel) {\n        if (durabilityLevel !== undefined &&\n            durabilityLevel !== null &&\n            durabilityLevel !== generaltypes_1.DurabilityLevel.None) {\n            return this.cluster.kvDurableTimeout;\n        }\n        return this.cluster.kvTimeout;\n    }\n    /**\n     * @internal\n     */\n    _cppDocId(key) {\n        return {\n            bucket: this.scope.bucket.name,\n            scope: this.scope.name || '_default',\n            collection: this.name || '_default',\n            key: key,\n        };\n    }\n    /**\n     * @internal\n     */\n    _encodeDoc(transcoder, value, callback) {\n        try {\n            const [bytesBuf, flagsOut] = transcoder.encode(value);\n            callback(null, bytesBuf, flagsOut);\n        }\n        catch (e) {\n            return callback(e, Buffer.alloc(0), 0);\n        }\n    }\n    /**\n     * @internal\n     */\n    _decodeDoc(transcoder, bytes, flags, callback) {\n        try {\n            const content = transcoder.decode(bytes, flags);\n            callback(null, content);\n        }\n        catch (e) {\n            return callback(e, null);\n        }\n    }\n    /**\n     * @internal\n     */\n    _subdocEncode(value) {\n        return Buffer.from(value);\n    }\n    /**\n     * @internal\n     */\n    _subdocDecode(bytes) {\n        try {\n            return JSON.parse(bytes.toString('utf8'));\n        }\n        catch (e) {\n            // If we encounter a parse error, assume that we need\n            // to return bytes instead of an object.\n            return bytes;\n        }\n    }\n    /**\n     * The name of the collection this Collection object references.\n     */\n    get name() {\n        return this._name;\n    }\n    /**\n     * Retrieves the value of a document from the collection.\n     *\n     * @param key The document key to retrieve.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    get(key, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        if (options.project || options.withExpiry) {\n            return this._projectedGet(key, options, callback);\n        }\n        const transcoder = options.transcoder || this.transcoder;\n        const timeout = options.timeout || this.cluster.kvTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._conn.get({\n                id: this._cppDocId(key),\n                timeout,\n                partition: 0,\n                opaque: 0,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                this._decodeDoc(transcoder, resp.value, resp.flags, (err, content) => {\n                    if (err) {\n                        return wrapCallback(err, null);\n                    }\n                    wrapCallback(null, new crudoptypes_1.GetResult({\n                        content: content,\n                        cas: resp.cas,\n                    }));\n                });\n            });\n        }, callback);\n    }\n    _projectedGet(key, options, callback) {\n        let expiryStart = -1;\n        let projStart = -1;\n        let paths = [];\n        let spec = [];\n        let needReproject = false;\n        if (options.withExpiry) {\n            expiryStart = spec.length;\n            spec.push(sdspecs_1.LookupInSpec.get(sdspecs_1.LookupInMacro.Expiry));\n        }\n        projStart = spec.length;\n        if (!options.project) {\n            paths = [''];\n            spec.push(sdspecs_1.LookupInSpec.get(''));\n        }\n        else {\n            let projects = options.project;\n            if (!Array.isArray(projects)) {\n                projects = [projects];\n            }\n            for (let i = 0; i < projects.length; ++i) {\n                paths.push(projects[i]);\n                spec.push(sdspecs_1.LookupInSpec.get(projects[i]));\n            }\n        }\n        // The following code relies on the projections being\n        // the last segment of the specs array, this way we handle\n        // an overburdened operation in a single area.\n        if (spec.length > 16) {\n            spec = spec.splice(0, projStart);\n            spec.push(sdspecs_1.LookupInSpec.get(''));\n            needReproject = true;\n        }\n        return utilities_1.PromiseHelper.wrapAsync(async () => {\n            const res = await this.lookupIn(key, spec, {\n                ...options,\n            });\n            let content = null;\n            let expiry = undefined;\n            if (expiryStart >= 0) {\n                const expiryRes = res.content[expiryStart];\n                expiry = expiryRes.value;\n            }\n            if (projStart >= 0) {\n                if (!needReproject) {\n                    for (let i = 0; i < paths.length; ++i) {\n                        const projPath = paths[i];\n                        const projRes = res.content[projStart + i];\n                        if (!projRes.error) {\n                            content = sdutils_1.SdUtils.insertByPath(content, projPath, projRes.value);\n                        }\n                    }\n                }\n                else {\n                    content = {};\n                    const reprojRes = res.content[projStart];\n                    for (let j = 0; j < paths.length; ++j) {\n                        const reprojPath = paths[j];\n                        const value = sdutils_1.SdUtils.getByPath(reprojRes.value, reprojPath);\n                        content = sdutils_1.SdUtils.insertByPath(content, reprojPath, value);\n                    }\n                }\n            }\n            return new crudoptypes_1.GetResult({\n                content: content,\n                cas: res.cas,\n                expiryTime: expiry,\n            });\n        }, callback);\n    }\n    /**\n     * Checks whether a specific document exists or not.\n     *\n     * @param key The document key to check for existence.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    exists(key, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this.cluster.kvTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._conn.exists({\n                id: this._cppDocId(key),\n                partition: 0,\n                opaque: 0,\n                timeout,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                if (resp.deleted) {\n                    return wrapCallback(null, new crudoptypes_1.ExistsResult({\n                        cas: undefined,\n                        exists: false,\n                    }));\n                }\n                wrapCallback(null, new crudoptypes_1.ExistsResult({\n                    cas: resp.cas,\n                    exists: resp.document_exists,\n                }));\n            });\n        }, callback);\n    }\n    /**\n     * @internal\n     */\n    _getReplica(key, getAllReplicas, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[2];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const emitter = new streamablepromises_1.StreamableReplicasPromise((replicas) => replicas);\n        const transcoder = options.transcoder || this.transcoder;\n        const timeout = options.timeout || this.cluster.kvTimeout;\n        if (getAllReplicas) {\n            this._conn.getAllReplicas({\n                id: this._cppDocId(key),\n                timeout: timeout,\n                read_preference: (0, bindingutilities_1.readPreferenceToCpp)(options.readPreference),\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    emitter.emit('error', err);\n                    emitter.emit('end');\n                    return;\n                }\n                resp.entries.forEach((replica) => {\n                    this._decodeDoc(transcoder, replica.value, replica.flags, (err, content) => {\n                        if (err) {\n                            emitter.emit('error', err);\n                            emitter.emit('end');\n                            return;\n                        }\n                        emitter.emit('replica', new crudoptypes_1.GetReplicaResult({\n                            content: content,\n                            cas: replica.cas,\n                            isReplica: replica.replica,\n                        }));\n                    });\n                });\n                emitter.emit('end');\n                return;\n            });\n        }\n        else {\n            this._conn.getAnyReplica({\n                id: this._cppDocId(key),\n                timeout: timeout,\n                read_preference: (0, bindingutilities_1.readPreferenceToCpp)(options.readPreference),\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    emitter.emit('error', err);\n                    emitter.emit('end');\n                    return;\n                }\n                this._decodeDoc(transcoder, resp.value, resp.flags, (err, content) => {\n                    if (err) {\n                        emitter.emit('error', err);\n                        emitter.emit('end');\n                        return;\n                    }\n                    emitter.emit('replica', new crudoptypes_1.GetReplicaResult({\n                        content: content,\n                        cas: resp.cas,\n                        isReplica: resp.replica,\n                    }));\n                });\n                emitter.emit('end');\n                return;\n            });\n        }\n        return utilities_1.PromiseHelper.wrapAsync(() => emitter, callback);\n    }\n    /**\n     * Retrieves the value of the document from any of the available replicas.  This\n     * will return as soon as the first response is received from any replica node.\n     *\n     * @param key The document key to retrieve.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    getAnyReplica(key, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        return utilities_1.PromiseHelper.wrapAsync(async () => {\n            const replicas = await this._getReplica(key, false, options);\n            return replicas[0];\n        }, callback);\n    }\n    /**\n     * Retrieves the value of the document from all available replicas.  Note that\n     * as replication is asynchronous, each node may return a different value.\n     *\n     * @param key The document key to retrieve.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    getAllReplicas(key, options, callback) {\n        return this._getReplica(key, true, options, callback);\n    }\n    /**\n     * Inserts a new document to the collection, failing if the document already exists.\n     *\n     * @param key The document key to insert.\n     * @param value The value of the document to insert.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    insert(key, value, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[2];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const expiry = options.expiry ? (0, utilities_1.expiryToTimestamp)(options.expiry) : 0;\n        const transcoder = options.transcoder || this.transcoder;\n        const durabilityLevel = options.durabilityLevel;\n        const persistTo = options.durabilityPersistTo;\n        const replicateTo = options.durabilityReplicateTo;\n        const timeout = options.timeout || this._mutationTimeout(durabilityLevel);\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._encodeDoc(transcoder, value, (err, bytes, flags) => {\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                const insertReq = {\n                    id: this._cppDocId(key),\n                    value: bytes,\n                    flags,\n                    expiry: expiry,\n                    timeout,\n                    partition: 0,\n                    opaque: 0,\n                };\n                const insertCallback = (cppErr, resp) => {\n                    const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                    if (err) {\n                        return wrapCallback(err, null);\n                    }\n                    wrapCallback(err, new crudoptypes_1.MutationResult({\n                        cas: resp.cas,\n                        token: resp.token,\n                    }));\n                };\n                if (persistTo || replicateTo) {\n                    this._conn.insertWithLegacyDurability({\n                        ...insertReq,\n                        persist_to: (0, bindingutilities_1.persistToToCpp)(persistTo),\n                        replicate_to: (0, bindingutilities_1.replicateToToCpp)(replicateTo),\n                    }, insertCallback);\n                }\n                else {\n                    this._conn.insert({\n                        ...insertReq,\n                        durability_level: (0, bindingutilities_1.durabilityToCpp)(durabilityLevel),\n                    }, insertCallback);\n                }\n            });\n        }, callback);\n    }\n    /**\n     * Upserts a document to the collection.  This operation succeeds whether or not the\n     * document already exists.\n     *\n     * @param key The document key to upsert.\n     * @param value The new value for the document.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    upsert(key, value, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[2];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const expiry = options.expiry ? (0, utilities_1.expiryToTimestamp)(options.expiry) : 0;\n        const preserve_expiry = options.preserveExpiry;\n        const transcoder = options.transcoder || this.transcoder;\n        const durabilityLevel = options.durabilityLevel;\n        const persistTo = options.durabilityPersistTo;\n        const replicateTo = options.durabilityReplicateTo;\n        const timeout = options.timeout || this._mutationTimeout(durabilityLevel);\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._encodeDoc(transcoder, value, (err, bytes, flags) => {\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                const upsertReq = {\n                    id: this._cppDocId(key),\n                    value: bytes,\n                    flags,\n                    expiry: expiry,\n                    preserve_expiry: preserve_expiry || false,\n                    timeout,\n                    partition: 0,\n                    opaque: 0,\n                };\n                const upsertCallback = (cppErr, resp) => {\n                    const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                    if (err) {\n                        return wrapCallback(err, null);\n                    }\n                    wrapCallback(err, new crudoptypes_1.MutationResult({\n                        cas: resp.cas,\n                        token: resp.token,\n                    }));\n                };\n                if (persistTo || replicateTo) {\n                    this._conn.upsertWithLegacyDurability({\n                        ...upsertReq,\n                        persist_to: (0, bindingutilities_1.persistToToCpp)(persistTo),\n                        replicate_to: (0, bindingutilities_1.replicateToToCpp)(replicateTo),\n                    }, upsertCallback);\n                }\n                else {\n                    this._conn.upsert({\n                        ...upsertReq,\n                        durability_level: (0, bindingutilities_1.durabilityToCpp)(durabilityLevel),\n                    }, upsertCallback);\n                }\n            });\n        }, callback);\n    }\n    /**\n     * Replaces the value of an existing document.  Failing if the document does not exist.\n     *\n     * @param key The document key to replace.\n     * @param value The new value for the document.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    replace(key, value, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[2];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const expiry = options.expiry ? (0, utilities_1.expiryToTimestamp)(options.expiry) : 0;\n        const cas = options.cas;\n        const preserve_expiry = options.preserveExpiry;\n        const transcoder = options.transcoder || this.transcoder;\n        const durabilityLevel = options.durabilityLevel;\n        const persistTo = options.durabilityPersistTo;\n        const replicateTo = options.durabilityReplicateTo;\n        const timeout = options.timeout || this._mutationTimeout(durabilityLevel);\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._encodeDoc(transcoder, value, (err, bytes, flags) => {\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                const replaceReq = {\n                    id: this._cppDocId(key),\n                    value: bytes,\n                    flags,\n                    expiry,\n                    cas: cas || binding_1.zeroCas,\n                    preserve_expiry: preserve_expiry || false,\n                    timeout,\n                    partition: 0,\n                    opaque: 0,\n                };\n                const replaceCallback = (cppErr, resp) => {\n                    const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                    if (err) {\n                        return wrapCallback(err, null);\n                    }\n                    wrapCallback(err, new crudoptypes_1.MutationResult({\n                        cas: resp.cas,\n                        token: resp.token,\n                    }));\n                };\n                if (persistTo || replicateTo) {\n                    this._conn.replaceWithLegacyDurability({\n                        ...replaceReq,\n                        persist_to: (0, bindingutilities_1.persistToToCpp)(persistTo),\n                        replicate_to: (0, bindingutilities_1.replicateToToCpp)(replicateTo),\n                    }, replaceCallback);\n                }\n                else {\n                    this._conn.replace({\n                        ...replaceReq,\n                        durability_level: (0, bindingutilities_1.durabilityToCpp)(durabilityLevel),\n                    }, replaceCallback);\n                }\n            });\n        }, callback);\n    }\n    /**\n     * Remove an existing document from the collection.\n     *\n     * @param key The document key to remove.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    remove(key, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const cas = options.cas;\n        const durabilityLevel = options.durabilityLevel;\n        const persistTo = options.durabilityPersistTo;\n        const replicateTo = options.durabilityReplicateTo;\n        const timeout = options.timeout || this._mutationTimeout(durabilityLevel);\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            const removeReq = {\n                id: this._cppDocId(key),\n                cas: cas || binding_1.zeroCas,\n                timeout,\n                partition: 0,\n                opaque: 0,\n            };\n            const removeCallback = (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err, new crudoptypes_1.MutationResult({\n                    cas: resp.cas,\n                    token: resp.token,\n                }));\n            };\n            if (persistTo || replicateTo) {\n                this._conn.removeWithLegacyDurability({\n                    ...removeReq,\n                    persist_to: (0, bindingutilities_1.persistToToCpp)(persistTo),\n                    replicate_to: (0, bindingutilities_1.replicateToToCpp)(replicateTo),\n                }, removeCallback);\n            }\n            else {\n                this._conn.remove({\n                    ...removeReq,\n                    durability_level: (0, bindingutilities_1.durabilityToCpp)(durabilityLevel),\n                }, removeCallback);\n            }\n        }, callback);\n    }\n    /**\n     * Retrieves the value of the document and simultanously updates the expiry time\n     * for the same document.\n     *\n     * @param key The document to fetch and touch.\n     * @param expiry The new expiry to apply to the document, specified in seconds.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    getAndTouch(key, expiry, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[2];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const transcoder = options.transcoder || this.transcoder;\n        const timeout = options.timeout || this.cluster.kvTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._conn.getAndTouch({\n                id: this._cppDocId(key),\n                expiry: (0, utilities_1.expiryToTimestamp)(expiry),\n                timeout,\n                partition: 0,\n                opaque: 0,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                this._decodeDoc(transcoder, resp.value, resp.flags, (err, content) => {\n                    if (err) {\n                        return wrapCallback(err, null);\n                    }\n                    wrapCallback(err, new crudoptypes_1.GetResult({\n                        content: content,\n                        cas: resp.cas,\n                    }));\n                });\n            });\n        }, callback);\n    }\n    /**\n     * Updates the expiry on an existing document.\n     *\n     * @param key The document key to touch.\n     * @param expiry The new expiry to set for the document, specified in seconds.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    touch(key, expiry, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[2];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this.cluster.kvTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._conn.touch({\n                id: this._cppDocId(key),\n                expiry: (0, utilities_1.expiryToTimestamp)(expiry),\n                timeout,\n                partition: 0,\n                opaque: 0,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err, new crudoptypes_1.MutationResult({\n                    cas: resp.cas,\n                }));\n            });\n        }, callback);\n    }\n    /**\n     * Locks a document and retrieves the value of that document at the time it is locked.\n     *\n     * @param key The document key to retrieve and lock.\n     * @param lockTime The amount of time to lock the document for, specified in seconds.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    getAndLock(key, lockTime, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[2];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const transcoder = options.transcoder || this.transcoder;\n        const timeout = options.timeout || this.cluster.kvTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._conn.getAndLock({\n                id: this._cppDocId(key),\n                lock_time: lockTime,\n                timeout,\n                partition: 0,\n                opaque: 0,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                this._decodeDoc(transcoder, resp.value, resp.flags, (err, content) => {\n                    if (err) {\n                        return wrapCallback(err, null);\n                    }\n                    wrapCallback(err, new crudoptypes_1.GetResult({\n                        cas: resp.cas,\n                        content: content,\n                    }));\n                });\n            });\n        }, callback);\n    }\n    /**\n     * Unlocks a previously locked document.\n     *\n     * @param key The document key to unlock.\n     * @param cas The CAS of the document, used to validate lock ownership.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    unlock(key, cas, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[2];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this.cluster.kvTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._conn.unlock({\n                id: this._cppDocId(key),\n                cas,\n                timeout,\n                partition: 0,\n                opaque: 0,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err);\n                }\n                wrapCallback(null);\n            });\n        }, callback);\n    }\n    /**\n     * @internal\n     */\n    _continueScan(iterator, transcoder, emitter) {\n        iterator.next((cppErr, resp) => {\n            const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n            if (err) {\n                emitter.emit('error', err);\n                emitter.emit('end');\n                return;\n            }\n            if (typeof resp === 'undefined') {\n                emitter.emit('end');\n                return;\n            }\n            const key = resp.key;\n            if (typeof resp.body !== 'undefined') {\n                const cas = resp.body.cas;\n                const expiry = resp.body.expiry;\n                this._decodeDoc(transcoder, resp.body.value, resp.body.flags, (err, content) => {\n                    if (err) {\n                        emitter.emit('error', err);\n                        emitter.emit('end');\n                        return;\n                    }\n                    emitter.emit('result', new crudoptypes_1.ScanResult({\n                        id: key,\n                        content: content,\n                        cas: cas,\n                        expiryTime: expiry,\n                    }));\n                });\n            }\n            else {\n                emitter.emit('result', new crudoptypes_1.ScanResult({\n                    id: key,\n                }));\n            }\n            if (emitter.cancelRequested && !iterator.cancelled) {\n                iterator.cancel();\n            }\n            this._continueScan(iterator, transcoder, emitter);\n            return;\n        });\n    }\n    /**\n     * @internal\n     */\n    _doScan(scanType, options, transcoder, callback) {\n        const bucketName = this._scope.bucket.name;\n        const scopeName = this._scope.name;\n        const collectionName = this._name;\n        return utilities_1.PromiseHelper.wrapAsync(() => {\n            const { cppErr, result } = this._conn.scan(bucketName, scopeName, collectionName, scanType.getScanType(), (0, bindingutilities_1.scanTypeToCpp)(scanType), options);\n            const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n            if (err) {\n                throw err;\n            }\n            const emitter = new streamablepromises_1.StreamableScanPromise((results) => results);\n            this._continueScan(result, transcoder, emitter);\n            return emitter;\n        }, callback);\n    }\n    /**\n     * Performs a key-value scan operation.\n     *\n     * Use this API for low concurrency batch queries where latency is not a critical as the system\n     * may have to scan a lot of documents to find the matching documents.\n     * For low latency range queries, it is recommended that you use SQL++ with the necessary indexes.\n     *\n     * @param scanType The type of scan to execute.\n     * @param options Optional parameters for the scan operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    scan(scanType, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[2];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const transcoder = options.transcoder || this.transcoder;\n        const timeout = options.timeout || this._kvScanTimeout;\n        const idsOnly = options.idsOnly || false;\n        const batchByteLimit = options.batchByteLimit || this._scanBatchByteLimit;\n        const batchItemLimit = options.batchByteLimit || this._scanBatchItemLimit;\n        if (typeof options.concurrency !== 'undefined' && options.concurrency < 1) {\n            throw new errors_1.InvalidArgumentError(new Error('Concurrency option must be positive'));\n        }\n        const concurrency = options.concurrency || 1;\n        if (scanType instanceof rangeScan_1.SamplingScan && scanType.limit < 1) {\n            throw new errors_1.InvalidArgumentError(new Error('Sampling scan limit must be positive'));\n        }\n        const orchestratorOptions = {\n            ids_only: idsOnly,\n            consistent_with: (0, bindingutilities_1.mutationStateToCpp)(options.consistentWith),\n            batch_item_limit: batchItemLimit,\n            batch_byte_limit: batchByteLimit,\n            concurrency: concurrency,\n            timeout: timeout,\n        };\n        return this._doScan(scanType, orchestratorOptions, transcoder, callback);\n    }\n    /**\n     * Performs a lookup-in operation against a document, fetching individual fields or\n     * information about specific fields inside the document value.\n     *\n     * @param key The document key to look in.\n     * @param specs A list of specs describing the data to fetch from the document.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    lookupIn(key, specs, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[2];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        if (specs.length === 0) {\n            throw new errors_1.InvalidArgumentError(new Error('At least one lookup spec must be provided.'));\n        }\n        const cppSpecs = [];\n        for (let i = 0; i < specs.length; ++i) {\n            cppSpecs.push({\n                opcode_: specs[i]._op,\n                flags_: specs[i]._flags,\n                path_: specs[i]._path,\n                original_index_: i,\n            });\n        }\n        const timeout = options.timeout || this.cluster.kvTimeout;\n        const accessDeleted = options.accessDeleted || false;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._conn.lookupIn({\n                id: this._cppDocId(key),\n                specs: cppSpecs,\n                timeout,\n                partition: 0,\n                opaque: 0,\n                access_deleted: accessDeleted,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (resp && resp.fields) {\n                    const content = [];\n                    for (let i = 0; i < resp.fields.length; ++i) {\n                        const itemRes = resp.fields[i];\n                        const error = (0, bindingutilities_1.errorFromCpp)(itemRes.ec);\n                        let value = undefined;\n                        if (itemRes.value && itemRes.value.length > 0) {\n                            value = this._subdocDecode(itemRes.value);\n                        }\n                        if (itemRes.opcode === binding_1.default.protocol_subdoc_opcode.exists) {\n                            value = itemRes.exists;\n                        }\n                        content.push(new crudoptypes_1.LookupInResultEntry({\n                            error,\n                            value,\n                        }));\n                    }\n                    wrapCallback(err, new crudoptypes_1.LookupInResult({\n                        content: content,\n                        cas: resp.cas,\n                    }));\n                    return;\n                }\n                wrapCallback(err, null);\n            });\n        }, callback);\n    }\n    /**\n     * @internal\n     */\n    _lookupInReplica(key, lookupInAllReplicas, specs, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[3];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        if (specs.length === 0) {\n            throw new errors_1.InvalidArgumentError(new Error('At least one lookup spec must be provided.'));\n        }\n        const emitter = new streamablepromises_1.StreamableReplicasPromise((replicas) => replicas);\n        const cppSpecs = [];\n        for (let i = 0; i < specs.length; ++i) {\n            cppSpecs.push({\n                opcode_: specs[i]._op,\n                flags_: specs[i]._flags,\n                path_: specs[i]._path,\n                original_index_: i,\n            });\n        }\n        const timeout = options.timeout || this.cluster.kvTimeout;\n        if (lookupInAllReplicas) {\n            this._conn.lookupInAllReplicas({\n                id: this._cppDocId(key),\n                specs: cppSpecs,\n                timeout: timeout,\n                read_preference: (0, bindingutilities_1.readPreferenceToCpp)(options.readPreference),\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    emitter.emit('error', err);\n                    emitter.emit('end');\n                    return;\n                }\n                resp.entries.forEach((replica) => {\n                    const content = [];\n                    for (let i = 0; i < replica.fields.length; ++i) {\n                        const itemRes = replica.fields[i];\n                        const error = (0, bindingutilities_1.errorFromCpp)(itemRes.ec);\n                        let value = undefined;\n                        if (itemRes.value && itemRes.value.length > 0) {\n                            value = this._subdocDecode(itemRes.value);\n                        }\n                        if (itemRes.opcode === binding_1.default.protocol_subdoc_opcode.exists) {\n                            value = itemRes.exists;\n                        }\n                        content.push(new crudoptypes_1.LookupInResultEntry({\n                            error,\n                            value,\n                        }));\n                    }\n                    emitter.emit('replica', new crudoptypes_1.LookupInReplicaResult({\n                        content: content,\n                        cas: replica.cas,\n                        isReplica: replica.is_replica,\n                    }));\n                });\n                emitter.emit('end');\n                return;\n            });\n        }\n        else {\n            this._conn.lookupInAnyReplica({\n                id: this._cppDocId(key),\n                specs: cppSpecs,\n                timeout: timeout,\n                read_preference: (0, bindingutilities_1.readPreferenceToCpp)(options.readPreference),\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    emitter.emit('error', err);\n                    emitter.emit('end');\n                    return;\n                }\n                const content = [];\n                for (let i = 0; i < resp.fields.length; ++i) {\n                    const itemRes = resp.fields[i];\n                    const error = (0, bindingutilities_1.errorFromCpp)(itemRes.ec);\n                    let value = undefined;\n                    if (itemRes.value && itemRes.value.length > 0) {\n                        value = this._subdocDecode(itemRes.value);\n                    }\n                    if (itemRes.opcode === binding_1.default.protocol_subdoc_opcode.exists) {\n                        value = itemRes.exists;\n                    }\n                    content.push(new crudoptypes_1.LookupInResultEntry({\n                        error,\n                        value,\n                    }));\n                }\n                emitter.emit('replica', new crudoptypes_1.LookupInReplicaResult({\n                    content: content,\n                    cas: resp.cas,\n                    isReplica: resp.is_replica,\n                }));\n                emitter.emit('end');\n                return;\n            });\n        }\n        return utilities_1.PromiseHelper.wrapAsync(() => emitter, callback);\n    }\n    /**\n     * Performs a lookup-in operation against a document, fetching individual fields or\n     * information about specific fields inside the document value from any of the available\n     * replicas in the cluster.\n     *\n     * @param key The document key to look in.\n     * @param specs A list of specs describing the data to fetch from the document.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    lookupInAnyReplica(key, specs, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[2];\n            options = undefined;\n        }\n        return utilities_1.PromiseHelper.wrapAsync(async () => {\n            const replicas = await this._lookupInReplica(key, false, specs, options);\n            return replicas[0];\n        }, callback);\n    }\n    /**\n     * Performs a lookup-in operation against a document, fetching individual fields or\n     * information about specific fields inside the document value from all available replicas.\n     * Note that as replication is asynchronous, each node may return a different value.\n     *\n     * @param key The document key to look in.\n     * @param specs A list of specs describing the data to fetch from the document.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    lookupInAllReplicas(key, specs, options, callback) {\n        return this._lookupInReplica(key, true, specs, options, callback);\n    }\n    /**\n     * Performs a mutate-in operation against a document.  Allowing atomic modification of\n     * specific fields within a document.  Also enables access to document extended-attributes.\n     *\n     * @param key The document key to mutate.\n     * @param specs A list of specs describing the operations to perform on the document.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    mutateIn(key, specs, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[2];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        if (specs.length === 0) {\n            throw new errors_1.InvalidArgumentError(new Error('At least one lookup spec must be provided.'));\n        }\n        const cppSpecs = [];\n        for (let i = 0; i < specs.length; ++i) {\n            cppSpecs.push({\n                opcode_: specs[i]._op,\n                flags_: specs[i]._flags,\n                path_: specs[i]._path,\n                value_: specs[i]._data\n                    ? this._subdocEncode(specs[i]._data)\n                    : specs[i]._data,\n                original_index_: 0,\n            });\n        }\n        const storeSemantics = options.upsertDocument\n            ? generaltypes_1.StoreSemantics.Upsert\n            : options.storeSemantics;\n        const expiry = options.expiry\n            ? (0, utilities_1.expiryToTimestamp)(options.expiry)\n            : undefined;\n        const preserveExpiry = options.preserveExpiry;\n        const cas = options.cas;\n        const durabilityLevel = options.durabilityLevel;\n        const persistTo = options.durabilityPersistTo;\n        const replicateTo = options.durabilityReplicateTo;\n        const timeout = options.timeout || this._mutationTimeout(durabilityLevel);\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            const mutateInReq = {\n                id: this._cppDocId(key),\n                store_semantics: (0, bindingutilities_1.storeSemanticToCpp)(storeSemantics),\n                specs: cppSpecs,\n                expiry,\n                preserve_expiry: preserveExpiry || false,\n                cas: cas || binding_1.zeroCas,\n                timeout,\n                partition: 0,\n                opaque: 0,\n                access_deleted: false,\n                create_as_deleted: false,\n            };\n            const mutateInCallback = (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (resp && resp.fields) {\n                    const content = [];\n                    for (let i = 0; i < resp.fields.length; ++i) {\n                        const itemRes = resp.fields[i];\n                        let value = undefined;\n                        if (itemRes.value && itemRes.value.length > 0) {\n                            value = this._subdocDecode(itemRes.value);\n                        }\n                        content.push(new crudoptypes_1.MutateInResultEntry({\n                            value,\n                        }));\n                    }\n                    wrapCallback(err, new crudoptypes_1.MutateInResult({\n                        content: content,\n                        cas: resp.cas,\n                        token: resp.token,\n                    }));\n                    return;\n                }\n                wrapCallback(err, null);\n            };\n            if (persistTo || replicateTo) {\n                this._conn.mutateInWithLegacyDurability({\n                    ...mutateInReq,\n                    persist_to: (0, bindingutilities_1.persistToToCpp)(persistTo),\n                    replicate_to: (0, bindingutilities_1.replicateToToCpp)(replicateTo),\n                }, mutateInCallback);\n            }\n            else {\n                this._conn.mutateIn({\n                    ...mutateInReq,\n                    durability_level: (0, bindingutilities_1.durabilityToCpp)(durabilityLevel),\n                }, mutateInCallback);\n            }\n        }, callback);\n    }\n    /**\n     * Returns a CouchbaseList permitting simple list storage in a document.\n     *\n     * @param key The document key the data-structure resides in.\n     */\n    list(key) {\n        return new datastructures_1.CouchbaseList(this, key);\n    }\n    /**\n     * Returns a CouchbaseQueue permitting simple queue storage in a document.\n     *\n     * @param key The document key the data-structure resides in.\n     */\n    queue(key) {\n        return new datastructures_1.CouchbaseQueue(this, key);\n    }\n    /**\n     * Returns a CouchbaseMap permitting simple map storage in a document.\n     *\n     * @param key The document key the data-structure resides in.\n     */\n    map(key) {\n        return new datastructures_1.CouchbaseMap(this, key);\n    }\n    /**\n     * Returns a CouchbaseSet permitting simple set storage in a document.\n     *\n     * @param key The document key the data-structure resides in.\n     */\n    set(key) {\n        return new datastructures_1.CouchbaseSet(this, key);\n    }\n    /**\n     * Returns a BinaryCollection object reference, allowing access to various\n     * binary operations possible against a collection.\n     */\n    binary() {\n        return new binarycollection_1.BinaryCollection(this);\n    }\n    /**\n     * @internal\n     */\n    _binaryIncrement(key, delta, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[2];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const initial_value = options.initial;\n        const expiry = options.expiry ? (0, utilities_1.expiryToTimestamp)(options.expiry) : 0;\n        const durabilityLevel = options.durabilityLevel;\n        const persistTo = options.durabilityPersistTo;\n        const replicateTo = options.durabilityReplicateTo;\n        const timeout = options.timeout || this.cluster.kvTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            const incrementReq = {\n                id: this._cppDocId(key),\n                delta,\n                initial_value,\n                expiry: expiry,\n                timeout,\n                partition: 0,\n                opaque: 0,\n            };\n            const incrementCallback = (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err, new crudoptypes_1.CounterResult({\n                    cas: resp.cas,\n                    token: resp.token,\n                    value: resp.content,\n                }));\n            };\n            if (persistTo || replicateTo) {\n                this._conn.incrementWithLegacyDurability({\n                    ...incrementReq,\n                    persist_to: (0, bindingutilities_1.persistToToCpp)(persistTo),\n                    replicate_to: (0, bindingutilities_1.replicateToToCpp)(replicateTo),\n                }, incrementCallback);\n            }\n            else {\n                this._conn.increment({\n                    ...incrementReq,\n                    durability_level: (0, bindingutilities_1.durabilityToCpp)(durabilityLevel),\n                }, incrementCallback);\n            }\n        }, callback);\n    }\n    /**\n     * @internal\n     */\n    _binaryDecrement(key, delta, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[2];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const initial_value = options.initial;\n        const expiry = options.expiry ? (0, utilities_1.expiryToTimestamp)(options.expiry) : 0;\n        const durabilityLevel = options.durabilityLevel;\n        const persistTo = options.durabilityPersistTo;\n        const replicateTo = options.durabilityReplicateTo;\n        const timeout = options.timeout || this.cluster.kvTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            const decrementReq = {\n                id: this._cppDocId(key),\n                delta,\n                initial_value,\n                expiry: expiry,\n                timeout,\n                partition: 0,\n                opaque: 0,\n            };\n            const decrementCallback = (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err, new crudoptypes_1.CounterResult({\n                    cas: resp.cas,\n                    token: resp.token,\n                    value: resp.content,\n                }));\n            };\n            if (persistTo || replicateTo) {\n                this._conn.decrementWithLegacyDurability({\n                    ...decrementReq,\n                    persist_to: (0, bindingutilities_1.persistToToCpp)(persistTo),\n                    replicate_to: (0, bindingutilities_1.replicateToToCpp)(replicateTo),\n                }, decrementCallback);\n            }\n            else {\n                this._conn.decrement({\n                    ...decrementReq,\n                    durability_level: (0, bindingutilities_1.durabilityToCpp)(durabilityLevel),\n                }, decrementCallback);\n            }\n        }, callback);\n    }\n    /**\n     * @internal\n     */\n    _binaryAppend(key, value, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[2];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const durabilityLevel = options.durabilityLevel;\n        const persistTo = options.durabilityPersistTo;\n        const replicateTo = options.durabilityReplicateTo;\n        const cas = options.cas;\n        const timeout = options.timeout || this.cluster.kvTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            if (!Buffer.isBuffer(value)) {\n                value = Buffer.from(value);\n            }\n            const appendReq = {\n                id: this._cppDocId(key),\n                value,\n                cas: cas || binding_1.zeroCas,\n                timeout,\n                partition: 0,\n                opaque: 0,\n            };\n            const appendCallback = (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err, new crudoptypes_1.MutationResult({\n                    cas: resp.cas,\n                    token: resp.token,\n                }));\n            };\n            if (persistTo || replicateTo) {\n                this._conn.appendWithLegacyDurability({\n                    ...appendReq,\n                    persist_to: (0, bindingutilities_1.persistToToCpp)(persistTo),\n                    replicate_to: (0, bindingutilities_1.replicateToToCpp)(replicateTo),\n                }, appendCallback);\n            }\n            else {\n                this._conn.append({\n                    ...appendReq,\n                    durability_level: (0, bindingutilities_1.durabilityToCpp)(durabilityLevel),\n                }, appendCallback);\n            }\n        }, callback);\n    }\n    /**\n     * @internal\n     */\n    _binaryPrepend(key, value, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[2];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const durabilityLevel = options.durabilityLevel;\n        const persistTo = options.durabilityPersistTo;\n        const replicateTo = options.durabilityReplicateTo;\n        const cas = options.cas;\n        const timeout = options.timeout || this.cluster.kvTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            if (!Buffer.isBuffer(value)) {\n                value = Buffer.from(value);\n            }\n            const prependReq = {\n                id: this._cppDocId(key),\n                value,\n                cas: cas || binding_1.zeroCas,\n                timeout,\n                partition: 0,\n                opaque: 0,\n            };\n            const prependCallback = (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err, new crudoptypes_1.MutationResult({\n                    cas: resp.cas,\n                    token: resp.token,\n                }));\n            };\n            if (persistTo || replicateTo) {\n                this._conn.prependWithLegacyDurability({\n                    ...prependReq,\n                    persist_to: (0, bindingutilities_1.persistToToCpp)(persistTo),\n                    replicate_to: (0, bindingutilities_1.replicateToToCpp)(replicateTo),\n                }, prependCallback);\n            }\n            else {\n                this._conn.prepend({\n                    ...prependReq,\n                    durability_level: (0, bindingutilities_1.durabilityToCpp)(durabilityLevel),\n                }, prependCallback);\n            }\n        }, callback);\n    }\n    /**\n     * Returns a CollectionQueryIndexManager which can be used to manage the query indexes\n     * of this collection.\n     */\n    queryIndexes() {\n        return new queryindexmanager_1.CollectionQueryIndexManager(this);\n    }\n}\nexports.Collection = Collection;\n"],"x_google_ignoreList":[0],"mappings":"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"}