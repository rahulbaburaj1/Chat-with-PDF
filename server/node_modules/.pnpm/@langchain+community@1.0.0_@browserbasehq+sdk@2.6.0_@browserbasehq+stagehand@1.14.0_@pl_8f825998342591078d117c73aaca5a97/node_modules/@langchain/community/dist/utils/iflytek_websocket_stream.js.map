{"version":3,"file":"iflytek_websocket_stream.js","names":["url: string","options: WebSocketStreamOptions"],"sources":["../../src/utils/iflytek_websocket_stream.ts"],"sourcesContent":["export interface WebSocketConnection<\n  T extends Uint8Array | string = Uint8Array | string\n> {\n  readable: ReadableStream<T>;\n  writable: WritableStream<T>;\n  protocol: string;\n  extensions: string;\n}\n\nexport interface WebSocketCloseInfo {\n  code?: number;\n  reason?: string;\n}\n\nexport interface WebSocketStreamOptions {\n  protocols?: string[];\n  signal?: AbortSignal;\n}\n\n/**\n * [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket) with [Streams API](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API)\n *\n * @see https://web.dev/websocketstream/\n */\nexport abstract class BaseWebSocketStream<\n  T extends Uint8Array | string = Uint8Array | string\n> {\n  readonly url: string;\n\n  readonly connection: Promise<WebSocketConnection<T>>;\n\n  readonly closed: Promise<WebSocketCloseInfo>;\n\n  readonly close: (closeInfo?: WebSocketCloseInfo) => void;\n\n  constructor(url: string, options: WebSocketStreamOptions = {}) {\n    if (options.signal?.aborted) {\n      throw new DOMException(\"This operation was aborted\", \"AbortError\");\n    }\n\n    this.url = url;\n\n    const ws = this.openWebSocket(url, options);\n\n    const closeWithInfo = ({ code, reason }: WebSocketCloseInfo = {}) =>\n      ws.close(code, reason);\n\n    this.connection = new Promise((resolve, reject) => {\n      ws.onopen = () => {\n        resolve({\n          readable: new ReadableStream<T>({\n            start(controller) {\n              ws.onmessage = ({ data }) => controller.enqueue(data);\n              ws.onerror = (e) => controller.error(e);\n            },\n            cancel: closeWithInfo,\n          }),\n          writable: new WritableStream<T>({\n            write(chunk) {\n              ws.send(chunk);\n            },\n            abort() {\n              ws.close();\n            },\n            close: closeWithInfo,\n          }),\n          protocol: ws.protocol,\n          extensions: ws.extensions,\n        });\n        ws.removeEventListener(\"error\", reject);\n      };\n      ws.addEventListener(\"error\", reject);\n    });\n\n    this.closed = new Promise<WebSocketCloseInfo>((resolve, reject) => {\n      ws.onclose = ({ code, reason }) => {\n        resolve({ code, reason });\n        ws.removeEventListener(\"error\", reject);\n      };\n      ws.addEventListener(\"error\", reject);\n    });\n\n    if (options.signal) {\n      options.signal.onabort = () => ws.close();\n    }\n\n    this.close = closeWithInfo;\n  }\n\n  abstract openWebSocket(\n    url: string,\n    options: WebSocketStreamOptions\n  ): WebSocket;\n}\n"],"mappings":";;;;;;AAwBA,IAAsB,sBAAtB,MAEE;CACA,AAAS;CAET,AAAS;CAET,AAAS;CAET,AAAS;CAET,YAAYA,KAAaC,UAAkC,CAAE,GAAE;AAC7D,MAAI,QAAQ,QAAQ,QAClB,OAAM,IAAI,aAAa,8BAA8B;EAGvD,KAAK,MAAM;EAEX,MAAM,KAAK,KAAK,cAAc,KAAK,QAAQ;EAE3C,MAAM,gBAAgB,CAAC,EAAE,MAAM,QAA4B,GAAG,CAAE,MAC9D,GAAG,MAAM,MAAM,OAAO;EAExB,KAAK,aAAa,IAAI,QAAQ,CAAC,SAAS,WAAW;GACjD,GAAG,SAAS,MAAM;IAChB,QAAQ;KACN,UAAU,IAAI,eAAkB;MAC9B,MAAM,YAAY;OAChB,GAAG,YAAY,CAAC,EAAE,MAAM,KAAK,WAAW,QAAQ,KAAK;OACrD,GAAG,UAAU,CAAC,MAAM,WAAW,MAAM,EAAE;MACxC;MACD,QAAQ;KACT;KACD,UAAU,IAAI,eAAkB;MAC9B,MAAM,OAAO;OACX,GAAG,KAAK,MAAM;MACf;MACD,QAAQ;OACN,GAAG,OAAO;MACX;MACD,OAAO;KACR;KACD,UAAU,GAAG;KACb,YAAY,GAAG;IAChB,EAAC;IACF,GAAG,oBAAoB,SAAS,OAAO;GACxC;GACD,GAAG,iBAAiB,SAAS,OAAO;EACrC;EAED,KAAK,SAAS,IAAI,QAA4B,CAAC,SAAS,WAAW;GACjE,GAAG,UAAU,CAAC,EAAE,MAAM,QAAQ,KAAK;IACjC,QAAQ;KAAE;KAAM;IAAQ,EAAC;IACzB,GAAG,oBAAoB,SAAS,OAAO;GACxC;GACD,GAAG,iBAAiB,SAAS,OAAO;EACrC;AAED,MAAI,QAAQ,QACV,QAAQ,OAAO,UAAU,MAAM,GAAG,OAAO;EAG3C,KAAK,QAAQ;CACd;AAMF"}