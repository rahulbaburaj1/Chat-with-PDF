{"version":3,"file":"upstash_ratelimit.d.cts","names":["Ratelimit","Serialized","LLMResult","ChainValues","BaseCallbackHandler","UpstashRatelimitError","Error","UpstashRatelimitHandlerOptions","UpstashRatelimitHandler","Promise","Record"],"sources":["../../../src/callbacks/handlers/upstash_ratelimit.d.ts"],"sourcesContent":["import { Ratelimit } from \"@upstash/ratelimit\";\nimport { Serialized } from \"@langchain/core/load/serializable\";\nimport { LLMResult } from \"@langchain/core/outputs\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport { BaseCallbackHandler } from \"@langchain/core/callbacks/base\";\n/**\n * Upstash Ratelimit Error\n *\n * Raised when the rate limit is reached in `UpstashRatelimitHandler`.\n */\ndeclare class UpstashRatelimitError extends Error {\n    type: \"token\" | \"request\";\n    limit?: number;\n    reset?: number;\n    /**\n     * @param message - Error message\n     * @param type - The kind of limit which was reached. One of \"token\" or \"request\"\n     * @param limit - The limit which was reached. Passed when type is request\n     * @param reset - Unix timestamp in milliseconds when the limits are reset. Passed when type is request\n     */\n    constructor(message: string, type: \"token\" | \"request\", limit?: number, reset?: number);\n}\ninterface UpstashRatelimitHandlerOptions {\n    tokenRatelimit?: Ratelimit;\n    requestRatelimit?: Ratelimit;\n    includeOutputTokens?: boolean;\n    llmOutputTokenUsageField?: string;\n    llmOutputTotalTokenField?: string;\n    llmOutputPromptTokenField?: string;\n}\n/**\n * Callback to handle rate limiting based on the number of requests\n * or the number of tokens in the input.\n *\n * It uses Upstash Ratelimit to track the rate limit which utilizes\n * Upstash Redis to track the state.\n *\n * Should not be passed to the chain when initializing the chain.\n * This is because the handler has a state which should be fresh\n * every time invoke is called. Instead, initialize and pass a handler\n * every time you invoke.\n */\ndeclare class UpstashRatelimitHandler extends BaseCallbackHandler {\n    name: string;\n    raiseError: boolean;\n    private _checked;\n    identifier: string;\n    tokenRatelimit?: Ratelimit;\n    requestRatelimit?: Ratelimit;\n    includeOutputTokens: boolean;\n    llmOutputTokenUsageField: string;\n    llmOutputTotalTokenField: string;\n    llmOutputPromptTokenField: string;\n    /**\n     * @param identifier - The identifier to rate limit, like a user ID or an IP address\n     * @param options - Ratelimit options\n     */\n    constructor(identifier: string, options: UpstashRatelimitHandlerOptions);\n    /**\n     * Run when the chain starts running.\n     *\n     * This method is called multiple times during a chain execution.\n     * To ensure it only runs once, it checks and updates a `_checked` state.\n     *\n     * @param _chain - Serialized chain\n     * @param _inputs - Chain input values\n     * @throws UpstashRatelimitError - If the request rate limit is reached\n     */\n    handleChainStart(_chain: Serialized, _inputs: ChainValues): Promise<void>;\n    /**\n     * Run when the LLM starts running.\n     *\n     * @param _llm - Serialized LLM\n     * @param _prompts - Prompts passed to the LLM\n     * @throws UpstashRatelimitError - If the token rate limit is reached\n     */\n    handleLLMStart(_llm: Serialized, _prompts: string[], _runId: string, _parentRunId?: string, _extraParams?: Record<string, unknown>, _tags?: string[], _metadata?: Record<string, unknown>, _name?: string): Promise<void>;\n    /**\n     * Run when the LLM ends running.\n     *\n     * If the `includeOutputTokens` is set to true, the number of tokens\n     * in the LLM completion are counted for rate limiting.\n     *\n     * @param output - LLM result output\n     * @throws Error - If the LLM response does not include required token usage information\n     */\n    handleLLMEnd(output: LLMResult, _runId: string, _parentRunId?: string, _tags?: string[]): Promise<void>;\n    /**\n     * Creates a new UpstashRatelimitHandler object with the same\n     * ratelimit configurations but with a new identifier if it's\n     * provided.\n     *\n     * Also resets the state of the handler.\n     *\n     * @param identifier - Optional new identifier to use for the new handler instance\n     * @returns New UpstashRatelimitHandler instance\n     */\n    reset(identifier?: string): UpstashRatelimitHandler;\n}\nexport { UpstashRatelimitHandler, UpstashRatelimitError, UpstashRatelimitHandlerOptions, };\n"],"mappings":";;;;;;;;;;;;;;;cAUcK,qBAAAA,SAA8BC,KAAK;;;;EAAnCD;AAAmC;;;;AAcjB;EAkBlBG,WAAAA,CAAAA,OAAAA,EAAAA,MAAuB,EAAA,IAAA,EAAA,OAAA,GAAA,SAAA,EAAA,KAAA,CAAA,EAAA,MAAA,EAAA,KAAA,CAAA,EAAA,MAAA;;UApB3BD,8BAAAA,CAyBWP;EAAS,cACPA,CAAAA,EAzBFA,SAyBEA;EAAS,gBASaO,CAAAA,EAjCtBP,SAiCsBO;EAA8B,mBAW9CN,CAAAA,EAAAA,OAAAA;EAAU,wBAAWE,CAAAA,EAAAA,MAAAA;EAAW,wBAAGM,CAAAA,EAAAA,MAAAA;EAAO,yBAQ9CR,CAAAA,EAAAA,MAAAA;;;;;;;;AAlCwC;;;;;;cAAnDO,uBAAAA,SAAgCJ,mBAAAA;;;;;mBAKzBJ;qBACEA;;;;;;;;;2CASsBO;;;;;;;;;;;2BAWhBN,qBAAqBE,cAAcM;;;;;;;;uBAQvCR,sFAAsFS,uDAAuDA,0CAA0CD;;;;;;;;;;uBAUvLP,qEAAqEO;;;;;;;;;;;8BAW9DD"}