{"version":3,"file":"lancedb.cjs","names":["VectorStore","embeddings: EmbeddingsInterface","args?: LanceDBArgs","documents: Document[]","vectors: number[][]","data: Array<Record<string, unknown>>","db: Connection","query: number[]","k: number","docsAndScore: [Document, number][]","metadata: Record<string, unknown>","Document","texts: string[]","metadatas: object[] | object","dbConfig?: LanceDBArgs","docs: Document[]"],"sources":["../../src/vectorstores/lancedb.ts"],"sourcesContent":["import { connect, Table, Connection } from \"@lancedb/lancedb\";\nimport type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { VectorStore } from \"@langchain/core/vectorstores\";\nimport { Document } from \"@langchain/core/documents\";\n\n/**\n * Defines the arguments for the LanceDB class constructor. It includes a\n * table and an optional textKey.\n */\nexport type LanceDBArgs = {\n  table?: Table;\n  textKey?: string;\n  uri?: string;\n  tableName?: string;\n  mode?: \"create\" | \"overwrite\";\n};\n\n/**\n * A wrapper for an open-source database for vector-search with persistent\n * storage. It simplifies retrieval, filtering, and management of\n * embeddings.\n */\nexport class LanceDB extends VectorStore {\n  private table?: Table;\n\n  private textKey: string;\n\n  private uri: string;\n\n  private tableName: string;\n\n  private mode?: \"create\" | \"overwrite\";\n\n  constructor(embeddings: EmbeddingsInterface, args?: LanceDBArgs) {\n    super(embeddings, args || {});\n    this.table = args?.table;\n    this.embeddings = embeddings;\n    this.textKey = args?.textKey || \"text\";\n    this.uri = args?.uri || \"~/lancedb\";\n    this.tableName = args?.tableName || \"langchain\";\n    this.mode = args?.mode || \"overwrite\";\n  }\n\n  /**\n   * Adds documents to the database.\n   * @param documents The documents to be added.\n   * @returns A Promise that resolves when the documents have been added.\n   */\n  async addDocuments(documents: Document[]): Promise<void> {\n    const texts = documents.map(({ pageContent }) => pageContent);\n    return this.addVectors(\n      await this.embeddings.embedDocuments(texts),\n      documents\n    );\n  }\n\n  _vectorstoreType(): string {\n    return \"lancedb\";\n  }\n\n  /**\n   * Adds vectors and their corresponding documents to the database.\n   * @param vectors The vectors to be added.\n   * @param documents The corresponding documents to be added.\n   * @returns A Promise that resolves when the vectors and documents have been added.\n   */\n  async addVectors(vectors: number[][], documents: Document[]): Promise<void> {\n    if (vectors.length === 0) {\n      return;\n    }\n    if (vectors.length !== documents.length) {\n      throw new Error(`Vectors and documents must have the same length`);\n    }\n\n    const data: Array<Record<string, unknown>> = [];\n    for (let i = 0; i < documents.length; i += 1) {\n      const record = {\n        vector: vectors[i],\n        [this.textKey]: documents[i].pageContent,\n      };\n      Object.keys(documents[i].metadata).forEach((metaKey) => {\n        record[metaKey] = documents[i].metadata[metaKey];\n      });\n      data.push(record);\n    }\n    if (!this.table) {\n      const db: Connection = await connect(this.uri);\n      this.table = await db.createTable(this.tableName, data, {\n        mode: this.mode,\n      });\n\n      return;\n    }\n    await this.table.add(data);\n  }\n\n  /**\n   * Performs a similarity search on the vectors in the database and returns\n   * the documents and their scores.\n   * @param query The query vector.\n   * @param k The number of results to return.\n   * @returns A Promise that resolves with an array of tuples, each containing a Document and its score.\n   */\n  async similaritySearchVectorWithScore(\n    query: number[],\n    k: number\n  ): Promise<[Document, number][]> {\n    if (!this.table) {\n      throw new Error(\n        \"Table not found. Please add vectors to the table first.\"\n      );\n    }\n    const results = await this.table\n      .query()\n      .nearestTo(query)\n      .limit(k)\n      .toArray();\n\n    const docsAndScore: [Document, number][] = [];\n    results.forEach((item) => {\n      const metadata: Record<string, unknown> = {};\n      Object.keys(item).forEach((key) => {\n        if (key !== \"vector\" && key !== \"score\" && key !== this.textKey) {\n          metadata[key] = item[key];\n        }\n      });\n\n      docsAndScore.push([\n        new Document({\n          pageContent: item[this.textKey] as string,\n          metadata,\n        }),\n        item.score as number,\n      ]);\n    });\n    return docsAndScore;\n  }\n\n  /**\n   * Creates a new instance of LanceDB from texts.\n   * @param texts The texts to be converted into documents.\n   * @param metadatas The metadata for the texts.\n   * @param embeddings The embeddings to be managed.\n   * @param dbConfig The configuration for the LanceDB instance.\n   * @returns A Promise that resolves with a new instance of LanceDB.\n   */\n  static async fromTexts(\n    texts: string[],\n    metadatas: object[] | object,\n    embeddings: EmbeddingsInterface,\n    dbConfig?: LanceDBArgs\n  ): Promise<LanceDB> {\n    const docs: Document[] = [];\n    for (let i = 0; i < texts.length; i += 1) {\n      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;\n      const newDoc = new Document({\n        pageContent: texts[i],\n        metadata,\n      });\n      docs.push(newDoc);\n    }\n    return LanceDB.fromDocuments(docs, embeddings, dbConfig);\n  }\n\n  /**\n   * Creates a new instance of LanceDB from documents.\n   * @param docs The documents to be added to the database.\n   * @param embeddings The embeddings to be managed.\n   * @param dbConfig The configuration for the LanceDB instance.\n   * @returns A Promise that resolves with a new instance of LanceDB.\n   */\n  static async fromDocuments(\n    docs: Document[],\n    embeddings: EmbeddingsInterface,\n    dbConfig?: LanceDBArgs\n  ): Promise<LanceDB> {\n    const instance = new this(embeddings, dbConfig);\n    await instance.addDocuments(docs);\n    return instance;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;AAsBA,IAAa,UAAb,MAAa,gBAAgBA,0CAAY;CACvC,AAAQ;CAER,AAAQ;CAER,AAAQ;CAER,AAAQ;CAER,AAAQ;CAER,YAAYC,YAAiCC,MAAoB;EAC/D,MAAM,YAAY,QAAQ,CAAE,EAAC;EAC7B,KAAK,QAAQ,MAAM;EACnB,KAAK,aAAa;EAClB,KAAK,UAAU,MAAM,WAAW;EAChC,KAAK,MAAM,MAAM,OAAO;EACxB,KAAK,YAAY,MAAM,aAAa;EACpC,KAAK,OAAO,MAAM,QAAQ;CAC3B;;;;;;CAOD,MAAM,aAAaC,WAAsC;EACvD,MAAM,QAAQ,UAAU,IAAI,CAAC,EAAE,aAAa,KAAK,YAAY;AAC7D,SAAO,KAAK,WACV,MAAM,KAAK,WAAW,eAAe,MAAM,EAC3C,UACD;CACF;CAED,mBAA2B;AACzB,SAAO;CACR;;;;;;;CAQD,MAAM,WAAWC,SAAqBD,WAAsC;AAC1E,MAAI,QAAQ,WAAW,EACrB;AAEF,MAAI,QAAQ,WAAW,UAAU,OAC/B,OAAM,IAAI,MAAM,CAAC,+CAA+C,CAAC;EAGnE,MAAME,OAAuC,CAAE;AAC/C,OAAK,IAAI,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK,GAAG;GAC5C,MAAM,SAAS;IACb,QAAQ,QAAQ;KACf,KAAK,UAAU,UAAU,GAAG;GAC9B;GACD,OAAO,KAAK,UAAU,GAAG,SAAS,CAAC,QAAQ,CAAC,YAAY;IACtD,OAAO,WAAW,UAAU,GAAG,SAAS;GACzC,EAAC;GACF,KAAK,KAAK,OAAO;EAClB;AACD,MAAI,CAAC,KAAK,OAAO;GACf,MAAMC,KAAiB,qCAAc,KAAK,IAAI;GAC9C,KAAK,QAAQ,MAAM,GAAG,YAAY,KAAK,WAAW,MAAM,EACtD,MAAM,KAAK,KACZ,EAAC;AAEF;EACD;EACD,MAAM,KAAK,MAAM,IAAI,KAAK;CAC3B;;;;;;;;CASD,MAAM,gCACJC,OACAC,GAC+B;AAC/B,MAAI,CAAC,KAAK,MACR,OAAM,IAAI,MACR;EAGJ,MAAM,UAAU,MAAM,KAAK,MACxB,OAAO,CACP,UAAU,MAAM,CAChB,MAAM,EAAE,CACR,SAAS;EAEZ,MAAMC,eAAqC,CAAE;EAC7C,QAAQ,QAAQ,CAAC,SAAS;GACxB,MAAMC,WAAoC,CAAE;GAC5C,OAAO,KAAK,KAAK,CAAC,QAAQ,CAAC,QAAQ;AACjC,QAAI,QAAQ,YAAY,QAAQ,WAAW,QAAQ,KAAK,SACtD,SAAS,OAAO,KAAK;GAExB,EAAC;GAEF,aAAa,KAAK,CAChB,IAAIC,oCAAS;IACX,aAAa,KAAK,KAAK;IACvB;GACD,IACD,KAAK,KACN,EAAC;EACH,EAAC;AACF,SAAO;CACR;;;;;;;;;CAUD,aAAa,UACXC,OACAC,WACAZ,YACAa,UACkB;EAClB,MAAMC,OAAmB,CAAE;AAC3B,OAAK,IAAI,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,GAAG;GACxC,MAAM,WAAW,MAAM,QAAQ,UAAU,GAAG,UAAU,KAAK;GAC3D,MAAM,SAAS,IAAIJ,oCAAS;IAC1B,aAAa,MAAM;IACnB;GACD;GACD,KAAK,KAAK,OAAO;EAClB;AACD,SAAO,QAAQ,cAAc,MAAM,YAAY,SAAS;CACzD;;;;;;;;CASD,aAAa,cACXI,MACAd,YACAa,UACkB;EAClB,MAAM,WAAW,IAAI,KAAK,YAAY;EACtC,MAAM,SAAS,aAAa,KAAK;AACjC,SAAO;CACR;AACF"}