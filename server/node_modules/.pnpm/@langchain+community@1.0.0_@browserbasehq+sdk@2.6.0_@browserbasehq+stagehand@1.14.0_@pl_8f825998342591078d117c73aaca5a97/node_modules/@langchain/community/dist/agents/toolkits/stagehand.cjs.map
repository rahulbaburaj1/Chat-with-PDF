{"version":3,"file":"stagehand.cjs","names":["Tool","stagehandInstance?: Stagehand","Stagehand","error: unknown","input: string","StructuredTool","z","input: {\n    instruction: string;\n    schema: z.AnyZodObject;\n  }","Toolkit","stagehand?: Stagehand","stagehand: Stagehand"],"sources":["../../../src/agents/toolkits/stagehand.ts"],"sourcesContent":["import {\n  Tool,\n  BaseToolkit as Toolkit,\n  StructuredTool,\n  StructuredToolInterface,\n} from \"@langchain/core/tools\";\nimport { Stagehand } from \"@browserbasehq/stagehand\";\nimport { z } from \"zod/v3\";\n\n//  Documentation is here:\n//  https://js.langchain.com/docs/integrations/tools/stagehand\n\nabstract class StagehandToolBase extends Tool {\n  protected stagehand?: Stagehand;\n\n  private localStagehand?: Stagehand;\n\n  constructor(stagehandInstance?: Stagehand) {\n    super();\n    this.stagehand = stagehandInstance;\n  }\n\n  protected async getStagehand(): Promise<Stagehand> {\n    if (this.stagehand) return this.stagehand;\n\n    if (!this.localStagehand) {\n      this.localStagehand = new Stagehand({\n        env: \"LOCAL\",\n        enableCaching: true,\n      });\n      await this.localStagehand.init();\n    }\n    return this.localStagehand;\n  }\n}\n\nfunction isErrorWithMessage(error: unknown): error is { message: string } {\n  return (\n    typeof error === \"object\" &&\n    error !== null &&\n    \"message\" in error &&\n    typeof (error as { message: unknown }).message === \"string\"\n  );\n}\n\nexport class StagehandNavigateTool extends StagehandToolBase {\n  name = \"stagehand_navigate\";\n\n  description =\n    \"Use this tool to navigate to a specific URL using Stagehand. The input should be a valid URL as a string.\";\n\n  async _call(input: string): Promise<string> {\n    const stagehand = await this.getStagehand();\n    try {\n      await stagehand.page.goto(input);\n      return `Successfully navigated to ${input}.`;\n    } catch (error: unknown) {\n      const message = isErrorWithMessage(error) ? error.message : String(error);\n      return `Failed to navigate: ${message}`;\n    }\n  }\n}\n\nexport class StagehandActTool extends StagehandToolBase {\n  name = \"stagehand_act\";\n\n  description =\n    \"Use this tool to perform an action on the current web page using Stagehand. The input should be a string describing the action to perform.\";\n\n  async _call(input: string): Promise<string> {\n    const stagehand = await this.getStagehand();\n    const result = await stagehand.act({ action: input });\n    if (result.success) {\n      return `Action performed successfully: ${result.message}`;\n    } else {\n      return `Failed to perform action: ${result.message}`;\n    }\n  }\n}\n\nexport class StagehandExtractTool extends StructuredTool {\n  name = \"stagehand_extract\";\n\n  description =\n    \"Use this tool to extract structured information from the current web page using Stagehand. The input should include an 'instruction' string and a 'schema' object representing the extraction schema in JSON Schema format.\";\n\n  // Define the input schema for the tool\n  schema = z.object({\n    instruction: z.string().describe(\"Instruction on what to extract\"),\n    schema: z\n      .record(z.any())\n      .describe(\"Extraction schema in JSON Schema format\"),\n  });\n\n  private stagehand?: Stagehand;\n\n  constructor(stagehandInstance?: Stagehand) {\n    super();\n    this.stagehand = stagehandInstance;\n  }\n\n  async _call(input: {\n    instruction: string;\n    schema: z.AnyZodObject;\n  }): Promise<string> {\n    const stagehand = await this.getStagehand();\n    const { instruction, schema } = input;\n\n    try {\n      const result = await stagehand.extract({\n        instruction,\n        schema, // Assuming Stagehand accepts the schema in JSON Schema format\n      });\n      return JSON.stringify(result);\n    } catch (error: unknown) {\n      const message = isErrorWithMessage(error) ? error.message : String(error);\n      return `Failed to extract information: ${message}`;\n    }\n  }\n\n  protected async getStagehand(): Promise<Stagehand> {\n    if (this.stagehand) return this.stagehand;\n\n    // Initialize local Stagehand instance if not provided\n    this.stagehand = new Stagehand({\n      env: \"LOCAL\",\n      enableCaching: true,\n    });\n    await this.stagehand.init();\n    return this.stagehand;\n  }\n}\n\nexport class StagehandObserveTool extends StagehandToolBase {\n  name = \"stagehand_observe\";\n\n  description =\n    \"Use this tool to observe the current web page and retrieve possible actions using Stagehand. The input can be an optional instruction string.\";\n\n  async _call(input: string): Promise<string> {\n    const stagehand = await this.getStagehand();\n    const instruction = input || undefined;\n\n    try {\n      const result = await stagehand.observe({ instruction });\n      return JSON.stringify(result);\n    } catch (error: unknown) {\n      const message = isErrorWithMessage(error) ? error.message : String(error);\n      return `Failed to observe: ${message}`;\n    }\n  }\n}\n\nexport class StagehandToolkit extends Toolkit {\n  tools: StructuredToolInterface[];\n\n  stagehand?: Stagehand;\n\n  constructor(stagehand?: Stagehand) {\n    super();\n    this.stagehand = stagehand;\n    this.tools = this.initializeTools();\n  }\n\n  private initializeTools(): StructuredToolInterface[] {\n    return [\n      new StagehandNavigateTool(this.stagehand),\n      new StagehandActTool(this.stagehand),\n      new StagehandExtractTool(this.stagehand),\n      new StagehandObserveTool(this.stagehand),\n    ];\n  }\n\n  static async fromStagehand(stagehand: Stagehand): Promise<StagehandToolkit> {\n    return new StagehandToolkit(stagehand);\n  }\n}\n"],"mappings":"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"}