{"version":3,"file":"googlevertexai-connection.d.cts","names":["BaseLanguageModelCallOptions","AsyncCaller","AsyncCallerCallOptions","GoogleVertexAIBaseLLMInput","GoogleVertexAIBasePrediction","GoogleVertexAIConnectionParams","GoogleVertexAILLMPredictions","GoogleVertexAIModelParams","GoogleResponse","GoogleAbstractedClient","GoogleAbstractedClientOpsMethod","GoogleConnection","Promise","CallOptions","ResponseType","GoogleVertexAIConnection","AuthOptions","complexValue","simpleValue","GoogleVertexAILLMConnection","PredictionType","GoogleVertexAILLMResponse","InstanceType","GoogleVertexAIStream"],"sources":["../../src/utils/googlevertexai-connection.d.ts"],"sourcesContent":["import { BaseLanguageModelCallOptions } from \"@langchain/core/language_models/base\";\nimport { AsyncCaller, AsyncCallerCallOptions } from \"@langchain/core/utils/async_caller\";\nimport type { GoogleVertexAIBaseLLMInput, GoogleVertexAIBasePrediction, GoogleVertexAIConnectionParams, GoogleVertexAILLMPredictions, GoogleVertexAIModelParams, GoogleResponse, GoogleAbstractedClient, GoogleAbstractedClientOpsMethod } from \"../types/googlevertexai-types.js\";\nexport declare abstract class GoogleConnection<CallOptions extends AsyncCallerCallOptions, ResponseType extends GoogleResponse> {\n    caller: AsyncCaller;\n    client: GoogleAbstractedClient;\n    streaming: boolean;\n    constructor(caller: AsyncCaller, client: GoogleAbstractedClient, streaming?: boolean);\n    abstract buildUrl(): Promise<string>;\n    abstract buildMethod(): GoogleAbstractedClientOpsMethod;\n    _request(data: unknown | undefined, options: CallOptions): Promise<ResponseType>;\n}\nexport declare abstract class GoogleVertexAIConnection<CallOptions extends AsyncCallerCallOptions, ResponseType extends GoogleResponse, AuthOptions> extends GoogleConnection<CallOptions, ResponseType> implements GoogleVertexAIConnectionParams<AuthOptions> {\n    endpoint: string;\n    location: string;\n    apiVersion: string;\n    constructor(fields: GoogleVertexAIConnectionParams<AuthOptions> | undefined, caller: AsyncCaller, client: GoogleAbstractedClient, streaming?: boolean);\n    buildMethod(): GoogleAbstractedClientOpsMethod;\n}\nexport declare function complexValue(value: unknown): unknown;\nexport declare function simpleValue(val: unknown): unknown;\nexport declare class GoogleVertexAILLMConnection<CallOptions extends BaseLanguageModelCallOptions, InstanceType, PredictionType extends GoogleVertexAIBasePrediction, AuthOptions> extends GoogleVertexAIConnection<CallOptions, GoogleVertexAILLMResponse<PredictionType>, AuthOptions> implements GoogleVertexAIBaseLLMInput<AuthOptions> {\n    model: string;\n    client: GoogleAbstractedClient;\n    customModelURL: string;\n    constructor(fields: GoogleVertexAIBaseLLMInput<AuthOptions> | undefined, caller: AsyncCaller, client: GoogleAbstractedClient, streaming?: boolean);\n    buildUrl(): Promise<string>;\n    formatStreamingData(inputs: InstanceType[], parameters: GoogleVertexAIModelParams): unknown;\n    formatStandardData(instances: InstanceType[], parameters: GoogleVertexAIModelParams): unknown;\n    formatData(instances: InstanceType[], parameters: GoogleVertexAIModelParams): unknown;\n    request(instances: InstanceType[], parameters: GoogleVertexAIModelParams, options: CallOptions): Promise<GoogleVertexAILLMResponse<PredictionType>>;\n}\nexport interface GoogleVertexAILLMResponse<PredictionType extends GoogleVertexAIBasePrediction> extends GoogleResponse {\n    data: GoogleVertexAIStream | GoogleVertexAILLMPredictions<PredictionType>;\n}\nexport declare class GoogleVertexAIStream {\n    _buffer: string;\n    _bufferOpen: boolean;\n    _firstRun: boolean;\n    /**\n     * Add data to the buffer. This may cause chunks to be generated, if available.\n     * @param data\n     */\n    appendBuffer(data: string): void;\n    /**\n     * Indicate there is no more data that will be added to the text buffer.\n     * This should be called when all the data has been read and added to indicate\n     * that we should process everything remaining in the buffer.\n     */\n    closeBuffer(): void;\n    /**\n     * Skip characters in the buffer till we get to the start of an object.\n     * Then attempt to read a full object.\n     * If we do read a full object, turn it into a chunk and send it to the chunk handler.\n     * Repeat this for as much as we can.\n     */\n    _parseBuffer(): void;\n    /**\n     * If the string is present, move the start of the buffer to the first occurrence\n     * of that string. This is useful for skipping over elements or parts that we're not\n     * really interested in parsing. (ie - the opening characters, comma separators, etc.)\n     * @param start The string to start the buffer with\n     */\n    _skipTo(start: string): void;\n    /**\n     * Given what is in the buffer, parse a single object out of it.\n     * If a complete object isn't available, return null.\n     * Assumes that we are at the start of an object to parse.\n     */\n    _getFullObject(): object | null;\n    _simplifyObject(obj: unknown): object;\n    // Set up a potential Promise that the handler can resolve.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _chunkResolution: (chunk: any) => void;\n    // If there is no Promise (it is null), the handler must add it to the queue\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _chunkPending: Promise<any> | null;\n    // A queue that will collect chunks while there is no Promise\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _chunkQueue: any[];\n    /**\n     * Register that we have another chunk available for consumption.\n     * If we are waiting for a chunk, resolve the promise waiting for it immediately.\n     * If not, then add it to the queue.\n     * @param chunk\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _handleChunk(chunk: any): void;\n    /**\n     * Get the next chunk that is coming from the stream.\n     * This chunk may be null, usually indicating the last chunk in the stream.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    nextChunk(): Promise<any>;\n    /**\n     * Is the stream done?\n     * A stream is only done if all of the following are true:\n     * - There is no more data to be added to the text buffer\n     * - There is no more data in the text buffer\n     * - There are no chunks that are waiting to be consumed\n     */\n    get streamDone(): boolean;\n}\n"],"mappings":";;;;;uBAG8BW,qCAAqCT,6CAA6CM;UACpGP;EADkBU,MAAAA,EAElBF,sBAFkC;EAAA,SAAA,EAAA,OAAA;EAAA,WAAqBP,CAAAA,MAAAA,EAI3CD,WAJ2CC,EAAAA,MAAAA,EAItBO,sBAJsBP,EAAAA,SAAAA,CAAAA,EAAAA,OAAAA;EAAsB,SAAuBM,QAAAA,CAAAA,CAAAA,EAKvFI,OALuFJ,CAAAA,MAAAA,CAAAA;EAAc,SAClHP,WAAAA,CAAAA,CAAAA,EAKgBS,+BALhBT;EAAW,QACXQ,CAAAA,IAAAA,EAAAA,OAAAA,GAAAA,SAAAA,EAAAA,OAAAA,EAKqCI,WALrCJ,CAAAA,EAKmDG,OALnDH,CAK2DK,YAL3DL,CAAAA;;AAEiCA,uBAKfM,wBALeN,CAAAA,oBAK8BP,sBAL9BO,EAAAA,qBAK2ED,cAL3EC,EAAAA,WAAAA,CAAAA,SAKgHE,gBALhHF,CAKiII,WALjIJ,EAK8IK,YAL9IL,CAAAA,YAKuKJ,8BALvKI,CAKsMO,WALtMP,CAAAA,CAAAA;EAAsB,QAC1CG,EAAAA,MAAAA;EAAO,QACJF,EAAAA,MAAAA;EAA+B,UACVG,EAAAA,MAAAA;EAAW,WAAWC,CAAAA,MAAAA,EAM/CT,8BAN+CS,CAMhBE,WANgBF,CAAAA,GAAAA,SAAAA,EAAAA,MAAAA,EAMkBb,WANlBa,EAAAA,MAAAA,EAMuCL,sBANvCK,EAAAA,SAAAA,CAAAA,EAAAA,OAAAA;EAAY,WAApBF,CAAAA,CAAAA,EAO5CF,+BAP4CE;AAAO;AAE8IP,UAoBnMgB,yBApBmMhB,CAAAA,uBAoBlJD,4BApBkJC,CAAAA,SAoB5GG,cApB4GH,CAAAA;EAA8B,IAAA,EAqBxOkB,oBArBwO,GAqBjNjB,4BArBiN,CAqBpLc,cArBoL,CAAA;AAoBlP;AAA0C,cAGrBG,oBAAAA,CAHqB;EAAA,OAAwBnB,EAAAA,MAAAA;EAA4B,WACpFmB,EAAAA,OAAAA;EAAoB,SAAgCH,EAAAA,OAAAA;EAAc;;AAD0C;AAGtH;EAAyC,YAAA,CAAA,IAAA,EAAA,MAAA,CAAA,EAAA,IAAA;EAAA;;AA0DjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBAjBLR;;;;;;;;;;;;;;;;;eAiBFA"}