{"version":3,"file":"azure_aisearch.js","names":["embeddings: EmbeddingsInterface","config: AzureAISearchConfig","params: {\n    ids?: string | string[];\n    filter?: AzureAISearchFilterType;\n  }","filter: AzureAISearchFilterType","docs: AzureAISearchDocument[]","deleteResults: IndexingResult[]","ids: string | string[]","docs: { id: string }[]","documents: Document[]","options?: AzureAISearchAddDocumentsOptions","embeddings: number[][]","vectors: number[][]","entities: AzureAISearchDocument[]","query: string","filter: this[\"FilterType\"] | undefined","queryVector?: number[]","docsWithScore: [Document, number][]","query: number[]","k: number","filter?: this[\"FilterType\"]","options: MaxMarginalRelevanceSearchOptions<this[\"FilterType\"]>","indexClient: SearchIndexClient","indexName: string","texts: string[]","metadatas: object[] | object","docs: Document<AzureAISearchDocumentMetadata>[]","docs: Document[]"],"sources":["../../src/vectorstores/azure_aisearch.ts"],"sourcesContent":["import * as uuid from \"uuid\";\nimport {\n  SearchClient,\n  SearchIndexClient,\n  AzureKeyCredential,\n  IndexingResult,\n  SearchIndex,\n  SearchIndexingBufferedSender,\n  VectorFilterMode,\n} from \"@azure/search-documents\";\nimport type { KeyCredential, TokenCredential } from \"@azure/core-auth\";\nimport {\n  MaxMarginalRelevanceSearchOptions,\n  VectorStore,\n} from \"@langchain/core/vectorstores\";\nimport type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { Document } from \"@langchain/core/documents\";\nimport { maximalMarginalRelevance } from \"@langchain/core/utils/math\";\nimport { getEnvironmentVariable } from \"@langchain/core/utils/env\";\n\n/**\n * Azure AI Search query type.\n */\nexport const AzureAISearchQueryType = {\n  /** Vector search. */\n  Similarity: \"similarity\",\n  /** Hybrid full text and vector search. */\n  SimilarityHybrid: \"similarity_hybrid\",\n  /** Hybrid full text and vector search with semantic ranking. */\n  SemanticHybrid: \"semantic_hybrid\",\n} as const;\n\n/**\n * Azure AI Search query type.\n */\nexport type AzureAISearchQueryType =\n  (typeof AzureAISearchQueryType)[keyof typeof AzureAISearchQueryType];\n\n/**\n * Azure AI Search settings.\n */\nexport interface AzureAISearchQueryOptions {\n  readonly type?: AzureAISearchQueryType;\n  readonly semanticConfigurationName?: string;\n}\n\n/**\n * Configuration options for the `AzureAISearchStore` constructor.\n */\nexport interface AzureAISearchConfig {\n  readonly client?: SearchClient<AzureAISearchDocument>;\n  readonly indexName?: string;\n  readonly endpoint?: string;\n  readonly key?: string;\n  readonly credentials?: KeyCredential | TokenCredential;\n  readonly search?: AzureAISearchQueryOptions;\n}\n\n/**\n * Azure AI Search options metadata schema.\n * If yout want to add custom data, use the attributes property.\n */\nexport type AzureAISearchDocumentMetadata = {\n  source: string;\n  attributes?: Array<{ key: string; value: string }>;\n  embedding?: number[];\n};\n\n/**\n * Azure AI Search indexed document.\n */\nexport type AzureAISearchDocument = {\n  id: string;\n  content: string;\n  content_vector: number[];\n  metadata: AzureAISearchDocumentMetadata;\n};\n\n/**\n * Azure AI Search options for adding documents.\n */\nexport type AzureAISearchAddDocumentsOptions = {\n  ids?: string[];\n};\n\n/**\n * Azure AI Search filter type.\n */\nexport type AzureAISearchFilterType = {\n  /** OData filter. */\n  filterExpression?: string;\n  /** Determines whether or not filters are applied before or after the vector search is performed. */\n  vectorFilterMode?: VectorFilterMode;\n  /** Determines whether or not to include the embeddings in the search results. */\n  includeEmbeddings?: boolean;\n};\n\nconst USER_AGENT_PREFIX = \"langchainjs-azure-aisearch\";\nconst DEFAULT_FIELD_ID = \"id\";\nconst DEFAULT_FIELD_CONTENT = \"content\";\nconst DEFAULT_FIELD_CONTENT_VECTOR = \"content_vector\";\nconst DEFAULT_FIELD_METADATA = \"metadata\";\nconst DEFAULT_FIELD_METADATA_SOURCE = \"source\";\nconst DEFAULT_FIELD_METADATA_ATTRS = \"attributes\";\n\n/**\n * Azure AI Search vector store.\n * To use this, you should have:\n * - the `@azure/search-documents` NPM package installed\n * - an endpoint and key to the Azure AI Search instance\n *\n * If you directly provide a `SearchClient` instance, you need to ensure that\n * an index has been created. When using and endpoint and key, the index will\n * be created automatically if it does not exist.\n */\nexport class AzureAISearchVectorStore extends VectorStore {\n  declare FilterType: AzureAISearchFilterType;\n\n  get lc_secrets(): { [key: string]: string } {\n    return {\n      endpoint: \"AZURE_AISEARCH_ENDPOINT\",\n      key: \"AZURE_AISEARCH_KEY\",\n    };\n  }\n\n  _vectorstoreType(): string {\n    return \"azure_aisearch\";\n  }\n\n  private readonly initPromise: Promise<void>;\n\n  private readonly client: SearchClient<AzureAISearchDocument>;\n\n  private readonly indexName: string;\n\n  private readonly options: AzureAISearchQueryOptions;\n\n  constructor(embeddings: EmbeddingsInterface, config: AzureAISearchConfig) {\n    super(embeddings, config);\n\n    const endpoint =\n      config.endpoint ?? getEnvironmentVariable(\"AZURE_AISEARCH_ENDPOINT\");\n    const key = config.key ?? getEnvironmentVariable(\"AZURE_AISEARCH_KEY\");\n    let { credentials } = config;\n\n    if (!config.client && (!endpoint || (!key && !credentials))) {\n      throw new Error(\n        \"Azure AI Search client or endpoint and key/credentials must be set.\"\n      );\n    }\n\n    this.indexName = config.indexName ?? \"vectorsearch\";\n\n    if (!config.client) {\n      credentials ??= new AzureKeyCredential(key!);\n      this.client = new SearchClient(endpoint!, this.indexName, credentials, {\n        userAgentOptions: { userAgentPrefix: USER_AGENT_PREFIX },\n      });\n      const indexClient = new SearchIndexClient(endpoint!, credentials, {\n        userAgentOptions: { userAgentPrefix: USER_AGENT_PREFIX },\n      });\n\n      // Start initialization, but don't wait for it to finish here\n      this.initPromise = this.ensureIndexExists(indexClient).catch((error) => {\n        console.error(\n          \"Error during Azure AI Search index initialization:\",\n          error\n        );\n      });\n    } else {\n      this.client = config.client;\n    }\n\n    this.options = config.search ?? {};\n    this.embeddings = embeddings;\n  }\n\n  /**\n   * Removes specified documents from the AzureAISearchVectorStore using IDs or a filter.\n   * @param params Object that includes either an array of IDs or a filter for the data to be deleted.\n   * @returns A promise that resolves when the documents have been removed.\n   */\n  async delete(params: {\n    ids?: string | string[];\n    filter?: AzureAISearchFilterType;\n  }) {\n    if (!params.ids && !params.filter) {\n      throw new Error(\n        `Azure AI Search delete requires either \"ids\" or \"filter\" to be set in the params object`\n      );\n    }\n\n    await this.initPromise;\n\n    if (params.ids) {\n      await this.deleteById(params.ids);\n    }\n    if (params.filter) {\n      await this.deleteMany(params.filter);\n    }\n  }\n\n  /**\n   * Removes specified documents from the AzureAISearchVectorStore using a filter.\n   * @param filter Filter options to find documents to delete.\n   * @returns A promise that resolves when the documents have been removed.\n   */\n  private async deleteMany(\n    filter: AzureAISearchFilterType\n  ): Promise<IndexingResult[]> {\n    if (!filter.filterExpression) {\n      throw new Error(\n        `Azure AI Search deleteMany requires \"filterExpression\" to be set in the filter object`\n      );\n    }\n\n    const { results } = await this.client.search(\"*\", {\n      filter: filter.filterExpression,\n    });\n\n    const docs: AzureAISearchDocument[] = [];\n    for await (const item of results) {\n      docs.push(item.document);\n    }\n\n    const deleteResults: IndexingResult[] = [];\n    const bufferedClient =\n      new SearchIndexingBufferedSender<AzureAISearchDocument>(\n        this.client,\n        (entity) => entity.id\n      );\n    bufferedClient.on(\"batchSucceeded\", (response) => {\n      deleteResults.push(...response.results);\n    });\n    bufferedClient.on(\"batchFailed\", (response) => {\n      throw new Error(\n        `Azure AI Search deleteDocuments batch failed: ${response}`\n      );\n    });\n\n    await bufferedClient.deleteDocuments(docs);\n    await bufferedClient.flush();\n    await bufferedClient.dispose();\n\n    return deleteResults;\n  }\n\n  /**\n   * Removes specified documents from the AzureAISearchVectorStore.\n   * @param ids IDs of the documents to be removed.\n   * @returns A promise that resolves when the documents have been removed.\n   */\n  private async deleteById(ids: string | string[]): Promise<IndexingResult[]> {\n    const docsIds = Array.isArray(ids) ? ids : [ids];\n    const docs: { id: string }[] = docsIds.map((id) => ({ id }));\n\n    const deleteResults: IndexingResult[] = [];\n    const bufferedClient = new SearchIndexingBufferedSender<{ id: string }>(\n      this.client,\n      (entity) => entity.id\n    );\n    bufferedClient.on(\"batchSucceeded\", (response) => {\n      deleteResults.push(...response.results);\n    });\n    bufferedClient.on(\"batchFailed\", (response) => {\n      throw new Error(\n        `Azure AI Search deleteDocuments batch failed: ${response}`\n      );\n    });\n\n    await bufferedClient.deleteDocuments(docs);\n    await bufferedClient.flush();\n    await bufferedClient.dispose();\n\n    return deleteResults;\n  }\n\n  /**\n   * Adds documents to the AzureAISearchVectorStore.\n   * @param documents The documents to add.\n   * @param options Options for adding documents.\n   * @returns A promise that resolves to the ids of the added documents.\n   */\n  async addDocuments(\n    documents: Document[],\n    options?: AzureAISearchAddDocumentsOptions\n  ) {\n    const texts = documents.map(({ pageContent }) => pageContent);\n    const embeddings: number[][] = await this.embeddings.embedDocuments(texts);\n    const results = await this.addVectors(embeddings, documents, options);\n\n    return results;\n  }\n\n  /**\n   * Adds vectors to the AzureAISearchVectorStore.\n   * @param vectors Vectors to be added.\n   * @param documents Corresponding documents to be added.\n   * @param options Options for adding documents.\n   * @returns A promise that resolves to the ids of the added documents.\n   */\n  async addVectors(\n    vectors: number[][],\n    documents: Document[],\n    options?: AzureAISearchAddDocumentsOptions\n  ): Promise<string[]> {\n    const ids = options?.ids ?? documents.map(() => uuid.v4());\n    const entities: AzureAISearchDocument[] = documents.map((doc, idx) => ({\n      id: ids[idx],\n      content: doc.pageContent,\n      content_vector: vectors[idx],\n      metadata: {\n        source: doc.metadata?.source,\n        attributes: doc.metadata?.attributes ?? [],\n      },\n    }));\n\n    await this.initPromise;\n\n    const bufferedClient =\n      new SearchIndexingBufferedSender<AzureAISearchDocument>(\n        this.client,\n        (entity) => entity.id\n      );\n    bufferedClient.on(\"batchFailed\", (response) => {\n      throw new Error(\n        `Azure AI Search uploadDocuments batch failed: ${response}`\n      );\n    });\n\n    await bufferedClient.uploadDocuments(entities);\n    await bufferedClient.flush();\n    await bufferedClient.dispose();\n\n    return ids;\n  }\n\n  /**\n   * Performs a similarity search using query type specified in configuration.\n   * If the query type is not specified, it defaults to similarity search.\n   * @param query Query text for the similarity search.\n   * @param k=4 Number of nearest neighbors to return.\n   * @param filter Optional filter options for the documents.\n   * @returns Promise that resolves to a list of documents.\n   */\n  async similaritySearch(\n    query: string,\n    k = 4,\n    filter: this[\"FilterType\"] | undefined = undefined\n  ): Promise<Document[]> {\n    const results = await this.similaritySearchWithScore(query, k, filter);\n\n    return results.map((result) => result[0]);\n  }\n\n  /**\n   * Performs a similarity search using query type specified in configuration.\n   * If the query type is not specified, it defaults to similarity hybrid search.\n   * @param query Query text for the similarity search.\n   * @param k=4 Number of nearest neighbors to return.\n   * @param filter Optional filter options for the documents.\n   * @returns Promise that resolves to a list of documents and their corresponding similarity scores.\n   */\n  async similaritySearchWithScore(\n    query: string,\n    k = 4,\n    filter: this[\"FilterType\"] | undefined = undefined\n  ): Promise<[Document, number][]> {\n    const searchType =\n      this.options.type ?? AzureAISearchQueryType.SimilarityHybrid;\n\n    if (searchType === AzureAISearchQueryType.Similarity) {\n      return this.similaritySearchVectorWithScore(\n        await this.embeddings.embedQuery(query),\n        k,\n        filter\n      );\n    } else if (searchType === AzureAISearchQueryType.SimilarityHybrid) {\n      return this.hybridSearchVectorWithScore(\n        query,\n        await this.embeddings.embedQuery(query),\n        k,\n        filter\n      );\n    } else if (searchType === AzureAISearchQueryType.SemanticHybrid) {\n      return this.semanticHybridSearchVectorWithScore(\n        query,\n        await this.embeddings.embedQuery(query),\n        k,\n        filter\n      );\n    }\n\n    throw new Error(`Unrecognized search type '${searchType}'`);\n  }\n\n  /**\n   * Performs a hybrid search using query text.\n   * @param query Query text for the similarity search.\n   * @param queryVector Query vector for the similarity search.\n   *    If not provided, the query text will be embedded.\n   * @param k=4 Number of nearest neighbors to return.\n   * @param filter Optional filter options for the documents.\n   * @returns Promise that resolves to a list of documents and their corresponding similarity scores.\n   */\n  async hybridSearchVectorWithScore(\n    query: string,\n    queryVector?: number[],\n    k = 4,\n    filter: this[\"FilterType\"] | undefined = undefined\n  ): Promise<[Document, number][]> {\n    const vector = queryVector ?? (await this.embeddings.embedQuery(query));\n\n    await this.initPromise;\n    const { results } = await this.client.search(query, {\n      vectorSearchOptions: {\n        queries: [\n          {\n            kind: \"vector\",\n            vector,\n            kNearestNeighborsCount: k,\n            fields: [DEFAULT_FIELD_CONTENT_VECTOR],\n          },\n        ],\n        filterMode: filter?.vectorFilterMode,\n      },\n      filter: filter?.filterExpression,\n      top: k,\n    });\n\n    const docsWithScore: [Document, number][] = [];\n\n    for await (const item of results) {\n      const document = new Document<AzureAISearchDocumentMetadata>({\n        pageContent: item.document[DEFAULT_FIELD_CONTENT],\n        metadata: {\n          ...item.document[DEFAULT_FIELD_METADATA],\n        },\n      });\n      if (filter?.includeEmbeddings) {\n        document.metadata.embedding =\n          item.document[DEFAULT_FIELD_CONTENT_VECTOR];\n      }\n      docsWithScore.push([document, item.score]);\n    }\n\n    return docsWithScore;\n  }\n\n  /**\n   * Performs a hybrid search with semantic reranker using query text.\n   * @param query Query text for the similarity search.\n   * @param queryVector Query vector for the similarity search.\n   *    If not provided, the query text will be embedded.\n   * @param k=4 Number of nearest neighbors to return.\n   * @param filter Optional filter options for the documents.\n   * @returns Promise that resolves to a list of documents and their corresponding similarity scores.\n   */\n  async semanticHybridSearchVectorWithScore(\n    query: string,\n    queryVector?: number[],\n    k = 4,\n    filter: this[\"FilterType\"] | undefined = undefined\n  ): Promise<[Document, number][]> {\n    const vector = queryVector ?? (await this.embeddings.embedQuery(query));\n\n    await this.initPromise;\n    const { results } = await this.client.search(query, {\n      vectorSearchOptions: {\n        queries: [\n          {\n            kind: \"vector\",\n            vector,\n            kNearestNeighborsCount: k,\n            fields: [DEFAULT_FIELD_CONTENT_VECTOR],\n          },\n        ],\n        filterMode: filter?.vectorFilterMode,\n      },\n      filter: filter?.filterExpression,\n      top: k,\n      queryType: \"semantic\",\n      semanticSearchOptions: {\n        configurationName:\n          this.options.semanticConfigurationName ?? \"semantic-search-config\",\n      },\n    });\n\n    const docsWithScore: [Document, number][] = [];\n\n    for await (const item of results) {\n      const document = new Document<AzureAISearchDocumentMetadata>({\n        pageContent: item.document[DEFAULT_FIELD_CONTENT],\n        metadata: {\n          ...item.document[DEFAULT_FIELD_METADATA],\n        },\n      });\n      if (filter?.includeEmbeddings) {\n        document.metadata.embedding =\n          item.document[DEFAULT_FIELD_CONTENT_VECTOR];\n      }\n      docsWithScore.push([document, item.score]);\n    }\n\n    return docsWithScore;\n  }\n\n  /**\n   * Performs a similarity search on the vectors stored in the collection.\n   * @param queryVector Query vector for the similarity search.\n   * @param k=4 Number of nearest neighbors to return.\n   * @param filter Optional filter options for the documents.\n   * @returns Promise that resolves to a list of documents and their corresponding similarity scores.\n   */\n  async similaritySearchVectorWithScore(\n    query: number[],\n    k: number,\n    filter?: this[\"FilterType\"]\n  ): Promise<[Document, number][]> {\n    await this.initPromise;\n\n    const { results } = await this.client.search(\"*\", {\n      vectorSearchOptions: {\n        queries: [\n          {\n            kind: \"vector\",\n            vector: query,\n            kNearestNeighborsCount: k,\n            fields: [DEFAULT_FIELD_CONTENT_VECTOR],\n          },\n        ],\n        filterMode: filter?.vectorFilterMode,\n      },\n      filter: filter?.filterExpression,\n    });\n\n    const docsWithScore: [Document, number][] = [];\n\n    for await (const item of results) {\n      const document = new Document<AzureAISearchDocumentMetadata>({\n        pageContent: item.document[DEFAULT_FIELD_CONTENT],\n        metadata: {\n          ...item.document[DEFAULT_FIELD_METADATA],\n        },\n      });\n      if (filter?.includeEmbeddings) {\n        document.metadata.embedding =\n          item.document[DEFAULT_FIELD_CONTENT_VECTOR];\n      }\n      docsWithScore.push([document, item.score]);\n    }\n\n    return docsWithScore;\n  }\n\n  /**\n   * Return documents selected using the maximal marginal relevance.\n   * Maximal marginal relevance optimizes for similarity to the query AND\n   * diversity among selected documents.\n   * @param query Text to look up documents similar to.\n   * @param options.k Number of documents to return.\n   * @param options.fetchK=20 Number of documents to fetch before passing to\n   *     the MMR algorithm.\n   * @param options.lambda=0.5 Number between 0 and 1 that determines the\n   *     degree of diversity among the results, where 0 corresponds to maximum\n   *     diversity and 1 to minimum diversity.\n   * @returns List of documents selected by maximal marginal relevance.\n   */\n  async maxMarginalRelevanceSearch(\n    query: string,\n    options: MaxMarginalRelevanceSearchOptions<this[\"FilterType\"]>\n  ): Promise<Document[]> {\n    const { k, fetchK = 20, lambda = 0.5 } = options;\n    const includeEmbeddingsFlag = options.filter?.includeEmbeddings || false;\n\n    const queryEmbedding = await this.embeddings.embedQuery(query);\n    const docs = await this.similaritySearchVectorWithScore(\n      queryEmbedding,\n      fetchK,\n      {\n        ...options.filter,\n        includeEmbeddings: true,\n      }\n    );\n    const embeddingList = docs.map((doc) => doc[0].metadata.embedding);\n\n    // Re-rank the results using MMR\n    const mmrIndexes = maximalMarginalRelevance(\n      queryEmbedding,\n      embeddingList,\n      lambda,\n      k\n    );\n\n    return mmrIndexes.map((index) => {\n      const doc = docs[index][0];\n\n      // Remove embeddings if they were not requested originally\n      if (!includeEmbeddingsFlag) {\n        delete doc.metadata.embedding;\n      }\n      return doc;\n    });\n  }\n\n  /**\n   * Ensures that an index exists on the AzureAISearchVectorStore.\n   * @param indexClient The Azure AI Search index client.\n   * @returns A promise that resolves when the AzureAISearchVectorStore index has been initialized.\n   * @protected\n   */\n  protected async ensureIndexExists(\n    indexClient: SearchIndexClient\n  ): Promise<void> {\n    try {\n      await indexClient.getIndex(this.indexName);\n    } catch {\n      // Index does not exists, create it\n      const searchIndex = await this.createSearchIndexDefinition(\n        this.indexName\n      );\n      await indexClient.createIndex(searchIndex);\n    }\n  }\n\n  /**\n   * Prepares the search index definition for Azure AI Search.\n   * @param indexName The name of the index.\n   * @returns The SearchIndex object.\n   * @protected\n   */\n  protected async createSearchIndexDefinition(\n    indexName: string\n  ): Promise<SearchIndex> {\n    // Embed a test query to get the embedding dimensions\n    const testEmbedding = await this.embeddings.embedQuery(\"test\");\n    const embeddingDimensions = testEmbedding.length;\n    return {\n      name: indexName,\n      vectorSearch: {\n        algorithms: [\n          {\n            name: \"vector-search-algorithm\",\n            kind: \"hnsw\",\n            parameters: {\n              m: 4,\n              efSearch: 500,\n              metric: \"cosine\",\n              efConstruction: 400,\n            },\n          },\n        ],\n        profiles: [\n          {\n            name: \"vector-search-profile\",\n            algorithmConfigurationName: \"vector-search-algorithm\",\n          },\n        ],\n      },\n      semanticSearch: {\n        defaultConfigurationName: \"semantic-search-config\",\n        configurations: [\n          {\n            name: \"semantic-search-config\",\n            prioritizedFields: {\n              contentFields: [\n                {\n                  name: DEFAULT_FIELD_CONTENT,\n                },\n              ],\n              keywordsFields: [\n                {\n                  name: DEFAULT_FIELD_CONTENT,\n                },\n              ],\n            },\n          },\n        ],\n      },\n      fields: [\n        {\n          name: DEFAULT_FIELD_ID,\n          filterable: true,\n          key: true,\n          type: \"Edm.String\",\n        },\n        {\n          name: DEFAULT_FIELD_CONTENT,\n          searchable: true,\n          filterable: true,\n          type: \"Edm.String\",\n        },\n        {\n          name: DEFAULT_FIELD_CONTENT_VECTOR,\n          searchable: true,\n          type: \"Collection(Edm.Single)\",\n          vectorSearchDimensions: embeddingDimensions,\n          vectorSearchProfileName: \"vector-search-profile\",\n        },\n        {\n          name: DEFAULT_FIELD_METADATA,\n          type: \"Edm.ComplexType\",\n          fields: [\n            {\n              name: DEFAULT_FIELD_METADATA_SOURCE,\n              type: \"Edm.String\",\n              filterable: true,\n            },\n            {\n              name: DEFAULT_FIELD_METADATA_ATTRS,\n              type: \"Collection(Edm.ComplexType)\",\n              fields: [\n                {\n                  name: \"key\",\n                  type: \"Edm.String\",\n                  filterable: true,\n                },\n                {\n                  name: \"value\",\n                  type: \"Edm.String\",\n                  filterable: true,\n                },\n              ],\n            },\n          ],\n        },\n      ],\n    };\n  }\n\n  /**\n   * Static method to create an instance of AzureAISearchVectorStore from a\n   * list of texts. It first converts the texts to vectors and then adds\n   * them to the collection.\n   * @param texts List of texts to be converted to vectors.\n   * @param metadatas Metadata for the texts.\n   * @param embeddings Embeddings to be used for conversion.\n   * @param config Database configuration for Azure AI Search.\n   * @returns Promise that resolves to a new instance of AzureAISearchVectorStore.\n   */\n  static async fromTexts(\n    texts: string[],\n    metadatas: object[] | object,\n    embeddings: EmbeddingsInterface,\n    config: AzureAISearchConfig\n  ): Promise<AzureAISearchVectorStore> {\n    const docs: Document<AzureAISearchDocumentMetadata>[] = [];\n    for (let i = 0; i < texts.length; i += 1) {\n      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;\n      const newDoc = new Document({\n        pageContent: texts[i],\n        metadata,\n      });\n      docs.push(newDoc);\n    }\n    return AzureAISearchVectorStore.fromDocuments(docs, embeddings, config);\n  }\n\n  /**\n   * Static method to create an instance of AzureAISearchVectorStore from a\n   * list of documents. It first converts the documents to vectors and then\n   * adds them to the database.\n   * @param docs List of documents to be converted to vectors.\n   * @param embeddings Embeddings to be used for conversion.\n   * @param config Database configuration for Azure AI Search.\n   * @returns Promise that resolves to a new instance of AzureAISearchVectorStore.\n   */\n  static async fromDocuments(\n    docs: Document[],\n    embeddings: EmbeddingsInterface,\n    config: AzureAISearchConfig,\n    options?: AzureAISearchAddDocumentsOptions\n  ): Promise<AzureAISearchVectorStore> {\n    const instance = new this(embeddings, config);\n    await instance.addDocuments(docs, options);\n    return instance;\n  }\n}\n"],"mappings":"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"}