{"version":3,"file":"hf.js","names":["fields?: HuggingFaceInferenceEmbeddingsParams","texts: string[]","document: string","documents: string[]"],"sources":["../../src/embeddings/hf.ts"],"sourcesContent":["import {\n  InferenceClient,\n  InferenceProviderOrPolicy,\n} from \"@huggingface/inference\";\nimport { Embeddings, type EmbeddingsParams } from \"@langchain/core/embeddings\";\nimport { getEnvironmentVariable } from \"@langchain/core/utils/env\";\n\n/**\n * Interface that extends EmbeddingsParams and defines additional\n * parameters specific to the HuggingFaceInferenceEmbeddings class.\n */\nexport interface HuggingFaceInferenceEmbeddingsParams extends EmbeddingsParams {\n  apiKey?: string;\n  model?: string;\n  endpointUrl?: string;\n  provider?: InferenceProviderOrPolicy;\n}\n\n/**\n * Class that extends the Embeddings class and provides methods for\n * generating embeddings using Hugging Face models through the\n * HuggingFaceInference API.\n */\nexport class HuggingFaceInferenceEmbeddings\n  extends Embeddings\n  implements HuggingFaceInferenceEmbeddingsParams\n{\n  apiKey?: string;\n\n  model: string;\n\n  endpointUrl?: string;\n\n  provider?: InferenceProviderOrPolicy;\n\n  client: InferenceClient;\n\n  constructor(fields?: HuggingFaceInferenceEmbeddingsParams) {\n    super(fields ?? {});\n\n    if (fields?.model) {\n      this.model = fields.model;\n    } else {\n      console.warn(\n        '[HuggingFaceInferenceEmbeddings] No \"model\" provided. Using default: \"BAAI/bge-base-en-v1.5\".'\n      );\n      this.model = \"BAAI/bge-base-en-v1.5\";\n    }\n    this.apiKey =\n      fields?.apiKey ?? getEnvironmentVariable(\"HUGGINGFACEHUB_API_KEY\");\n    this.endpointUrl = fields?.endpointUrl;\n    this.provider = fields?.provider;\n    this.client = this.endpointUrl\n      ? new InferenceClient(this.apiKey).endpoint(this.endpointUrl)\n      : new InferenceClient(this.apiKey);\n  }\n\n  async _embed(texts: string[]): Promise<number[][]> {\n    // replace newlines, which can negatively affect performance.\n    const clean = texts.map((text) => text.replace(/\\n/g, \" \"));\n    return this.caller.call(() =>\n      this.client.featureExtraction({\n        model: this.model,\n        inputs: clean,\n        provider: this.provider,\n      })\n    ) as Promise<number[][]>;\n  }\n\n  /**\n   * Method that takes a document as input and returns a promise that\n   * resolves to an embedding for the document. It calls the _embed method\n   * with the document as the input and returns the first embedding in the\n   * resulting array.\n   * @param document Document to generate an embedding for.\n   * @returns Promise that resolves to an embedding for the document.\n   */\n  embedQuery(document: string): Promise<number[]> {\n    return this._embed([document]).then((embeddings) => embeddings[0]);\n  }\n\n  /**\n   * Method that takes an array of documents as input and returns a promise\n   * that resolves to a 2D array of embeddings for each document. It calls\n   * the _embed method with the documents as the input.\n   * @param documents Array of documents to generate embeddings for.\n   * @returns Promise that resolves to a 2D array of embeddings for each document.\n   */\n  embedDocuments(documents: string[]): Promise<number[][]> {\n    return this._embed(documents);\n  }\n}\n"],"mappings":";;;;;;;;;;;;;AAuBA,IAAa,iCAAb,cACU,WAEV;CACE;CAEA;CAEA;CAEA;CAEA;CAEA,YAAYA,QAA+C;EACzD,MAAM,UAAU,CAAE,EAAC;AAEnB,MAAI,QAAQ,OACV,KAAK,QAAQ,OAAO;OACf;GACL,QAAQ,KACN,oGACD;GACD,KAAK,QAAQ;EACd;EACD,KAAK,SACH,QAAQ,UAAU,uBAAuB,yBAAyB;EACpE,KAAK,cAAc,QAAQ;EAC3B,KAAK,WAAW,QAAQ;EACxB,KAAK,SAAS,KAAK,cACf,IAAI,gBAAgB,KAAK,QAAQ,SAAS,KAAK,YAAY,GAC3D,IAAI,gBAAgB,KAAK;CAC9B;CAED,MAAM,OAAOC,OAAsC;EAEjD,MAAM,QAAQ,MAAM,IAAI,CAAC,SAAS,KAAK,QAAQ,OAAO,IAAI,CAAC;AAC3D,SAAO,KAAK,OAAO,KAAK,MACtB,KAAK,OAAO,kBAAkB;GAC5B,OAAO,KAAK;GACZ,QAAQ;GACR,UAAU,KAAK;EAChB,EAAC,CACH;CACF;;;;;;;;;CAUD,WAAWC,UAAqC;AAC9C,SAAO,KAAK,OAAO,CAAC,QAAS,EAAC,CAAC,KAAK,CAAC,eAAe,WAAW,GAAG;CACnE;;;;;;;;CASD,eAAeC,WAA0C;AACvD,SAAO,KAAK,OAAO,UAAU;CAC9B;AACF"}