'use strict';


const require_rolldown_runtime = require('../../../../../_virtual/rolldown_runtime.cjs');
const require_index = require('../../../retry@0.13.1/node_modules/retry/index.cjs');

//#region ../../node_modules/.pnpm/p-retry@4.6.2/node_modules/p-retry/index.js
var require_p_retry = /* @__PURE__ */ require_rolldown_runtime.__commonJS({ "../../node_modules/.pnpm/p-retry@4.6.2/node_modules/p-retry/index.js": ((exports, module) => {
	const retry = require_index.require_retry();
	const networkErrorMsgs = [
		"Failed to fetch",
		"NetworkError when attempting to fetch resource.",
		"The Internet connection appears to be offline.",
		"Network request failed"
	];
	var AbortError = class extends Error {
		constructor(message) {
			super();
			if (message instanceof Error) {
				this.originalError = message;
				({message} = message);
			} else {
				this.originalError = new Error(message);
				this.originalError.stack = this.stack;
			}
			this.name = "AbortError";
			this.message = message;
		}
	};
	const decorateErrorWithCounts = (error, attemptNumber, options) => {
		const retriesLeft = options.retries - (attemptNumber - 1);
		error.attemptNumber = attemptNumber;
		error.retriesLeft = retriesLeft;
		return error;
	};
	const isNetworkError = (errorMessage) => networkErrorMsgs.includes(errorMessage);
	const pRetry = (input, options) => new Promise((resolve, reject) => {
		options = {
			onFailedAttempt: () => {},
			retries: 10,
			...options
		};
		const operation = retry.operation(options);
		operation.attempt(async (attemptNumber) => {
			try {
				resolve(await input(attemptNumber));
			} catch (error) {
				if (!(error instanceof Error)) {
					reject(/* @__PURE__ */ new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
					return;
				}
				if (error instanceof AbortError) {
					operation.stop();
					reject(error.originalError);
				} else if (error instanceof TypeError && !isNetworkError(error.message)) {
					operation.stop();
					reject(error);
				} else {
					decorateErrorWithCounts(error, attemptNumber, options);
					try {
						await options.onFailedAttempt(error);
					} catch (error$1) {
						reject(error$1);
						return;
					}
					if (!operation.retry(error)) reject(operation.mainError());
				}
			}
		});
	});
	module.exports = pRetry;
	module.exports.default = pRetry;
	module.exports.AbortError = AbortError;
}) });

//#endregion
Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function () {
    return require_p_retry();
  }
});
//# sourceMappingURL=index.cjs.map