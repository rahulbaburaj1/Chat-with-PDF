{"version":3,"file":"client.js","names":["serializePayloadForTracing","body","batch","attachments","datasetId_","datasetName_","response","examples"],"sources":["../../../../../../../../../node_modules/.pnpm/langsmith@0.3.74_@opentelemetry+api@1.9.0_openai@5.12.2_ws@8.18.3_bufferutil@4.0.9_utf-8-validate@6.0.5__zod@3.25.76_/node_modules/langsmith/dist/client.js"],"sourcesContent":["import * as uuid from \"uuid\";\nimport { LangSmithToOTELTranslator, } from \"./experimental/otel/translator.js\";\nimport { getDefaultOTLPTracerComponents, getOTELTrace, getOTELContext, } from \"./singletons/otel.js\";\nimport { AsyncCaller } from \"./utils/async_caller.js\";\nimport { convertLangChainMessageToExample, isLangChainMessage, } from \"./utils/messages.js\";\nimport { getEnvironmentVariable, getLangSmithEnvVarsMetadata, getLangSmithEnvironmentVariable, getRuntimeEnvironment, getOtelEnabled, getEnv, } from \"./utils/env.js\";\nimport { __version__ } from \"./index.js\";\nimport { assertUuid } from \"./utils/_uuid.js\";\nimport { warnOnce } from \"./utils/warn.js\";\nimport { parsePromptIdentifier } from \"./utils/prompts.js\";\nimport { raiseForStatus } from \"./utils/error.js\";\nimport { _globalFetchImplementationIsNodeFetch, _getFetchImplementation, } from \"./singletons/fetch.js\";\nimport { serialize as serializePayloadForTracing } from \"./utils/fast-safe-stringify/index.js\";\nexport function mergeRuntimeEnvIntoRun(run, cachedEnvVars) {\n    const runtimeEnv = getRuntimeEnvironment();\n    const envVars = cachedEnvVars ?? getLangSmithEnvVarsMetadata();\n    const extra = run.extra ?? {};\n    const metadata = extra.metadata;\n    run.extra = {\n        ...extra,\n        runtime: {\n            ...runtimeEnv,\n            ...extra?.runtime,\n        },\n        metadata: {\n            ...envVars,\n            ...(envVars.revision_id || (\"revision_id\" in run && run.revision_id)\n                ? {\n                    revision_id: (\"revision_id\" in run ? run.revision_id : undefined) ??\n                        envVars.revision_id,\n                }\n                : {}),\n            ...metadata,\n        },\n    };\n    return run;\n}\nconst getTracingSamplingRate = (configRate) => {\n    const samplingRateStr = configRate?.toString() ??\n        getLangSmithEnvironmentVariable(\"TRACING_SAMPLING_RATE\");\n    if (samplingRateStr === undefined) {\n        return undefined;\n    }\n    const samplingRate = parseFloat(samplingRateStr);\n    if (samplingRate < 0 || samplingRate > 1) {\n        throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n    }\n    return samplingRate;\n};\n// utility functions\nconst isLocalhost = (url) => {\n    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n    return (hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\");\n};\nasync function toArray(iterable) {\n    const result = [];\n    for await (const item of iterable) {\n        result.push(item);\n    }\n    return result;\n}\nfunction trimQuotes(str) {\n    if (str === undefined) {\n        return undefined;\n    }\n    return str\n        .trim()\n        .replace(/^\"(.*)\"$/, \"$1\")\n        .replace(/^'(.*)'$/, \"$1\");\n}\nconst handle429 = async (response) => {\n    if (response?.status === 429) {\n        const retryAfter = parseInt(response.headers.get(\"retry-after\") ?? \"10\", 10) * 1000;\n        if (retryAfter > 0) {\n            await new Promise((resolve) => setTimeout(resolve, retryAfter));\n            // Return directly after calling this check\n            return true;\n        }\n    }\n    // Fall back to existing status checks\n    return false;\n};\nfunction _formatFeedbackScore(score) {\n    if (typeof score === \"number\") {\n        // Truncate at 4 decimal places\n        return Number(score.toFixed(4));\n    }\n    return score;\n}\nexport class AutoBatchQueue {\n    constructor() {\n        Object.defineProperty(this, \"items\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"sizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n    }\n    peek() {\n        return this.items[0];\n    }\n    push(item) {\n        let itemPromiseResolve;\n        const itemPromise = new Promise((resolve) => {\n            // Setting itemPromiseResolve is synchronous with promise creation:\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n            itemPromiseResolve = resolve;\n        });\n        const size = serializePayloadForTracing(item.item, `Serializing run with id: ${item.item.id}`).length;\n        this.items.push({\n            action: item.action,\n            payload: item.item,\n            otelContext: item.otelContext,\n            apiKey: item.apiKey,\n            apiUrl: item.apiUrl,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            itemPromiseResolve: itemPromiseResolve,\n            itemPromise,\n            size,\n        });\n        this.sizeBytes += size;\n        return itemPromise;\n    }\n    pop({ upToSizeBytes, upToSize, }) {\n        if (upToSizeBytes < 1) {\n            throw new Error(\"Number of bytes to pop off may not be less than 1.\");\n        }\n        const popped = [];\n        let poppedSizeBytes = 0;\n        // Pop items until we reach or exceed the size limit\n        while (poppedSizeBytes + (this.peek()?.size ?? 0) < upToSizeBytes &&\n            this.items.length > 0 &&\n            popped.length < upToSize) {\n            const item = this.items.shift();\n            if (item) {\n                popped.push(item);\n                poppedSizeBytes += item.size;\n                this.sizeBytes -= item.size;\n            }\n        }\n        // If there is an item on the queue we were unable to pop,\n        // just return it as a single batch.\n        if (popped.length === 0 && this.items.length > 0) {\n            const item = this.items.shift();\n            popped.push(item);\n            poppedSizeBytes += item.size;\n            this.sizeBytes -= item.size;\n        }\n        return [\n            popped.map((it) => ({\n                action: it.action,\n                item: it.payload,\n                otelContext: it.otelContext,\n                apiKey: it.apiKey,\n                apiUrl: it.apiUrl,\n            })),\n            () => popped.forEach((it) => it.itemPromiseResolve()),\n        ];\n    }\n}\nexport const DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES = 24 * 1024 * 1024;\nconst SERVER_INFO_REQUEST_TIMEOUT_MS = 10000;\n/** Maximum number of operations to batch in a single request. */\nconst DEFAULT_BATCH_SIZE_LIMIT = 100;\nconst DEFAULT_API_URL = \"https://api.smith.langchain.com\";\nexport class Client {\n    get _fetch() {\n        return this.fetchImplementation || _getFetchImplementation(this.debug);\n    }\n    constructor(config = {}) {\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"webUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"workspaceId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"batchIngestCaller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout_ms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tenantId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"hideInputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hideOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingSampleRate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"filteredPostUuids\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        Object.defineProperty(this, \"autoBatchTracing\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"autoBatchQueue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new AutoBatchQueue()\n        });\n        Object.defineProperty(this, \"autoBatchTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 250\n        });\n        Object.defineProperty(this, \"batchSizeBytesLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"batchSizeLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fetchOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"settings\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"blockOnRootRunFinalization\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: getEnvironmentVariable(\"LANGSMITH_TRACING_BACKGROUND\") === \"false\"\n        });\n        Object.defineProperty(this, \"traceBatchConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 5\n        });\n        Object.defineProperty(this, \"_serverInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_getServerInfoPromise\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"manualFlushMode\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"langSmithToOTELTranslator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fetchImplementation\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cachedLSEnvVarsForMetadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"multipartStreamingDisabled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"debug\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: getEnvironmentVariable(\"LANGSMITH_DEBUG\") === \"true\"\n        });\n        const defaultConfig = Client.getDefaultClientConfig();\n        this.tracingSampleRate = getTracingSamplingRate(config.tracingSamplingRate);\n        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n        if (this.apiUrl.endsWith(\"/\")) {\n            this.apiUrl = this.apiUrl.slice(0, -1);\n        }\n        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n        if (this.webUrl?.endsWith(\"/\")) {\n            this.webUrl = this.webUrl.slice(0, -1);\n        }\n        this.workspaceId = trimQuotes(config.workspaceId ?? getLangSmithEnvironmentVariable(\"WORKSPACE_ID\"));\n        this.timeout_ms = config.timeout_ms ?? 90_000;\n        this.caller = new AsyncCaller({\n            ...(config.callerOptions ?? {}),\n            maxRetries: 4,\n            debug: config.debug ?? this.debug,\n        });\n        this.traceBatchConcurrency =\n            config.traceBatchConcurrency ?? this.traceBatchConcurrency;\n        if (this.traceBatchConcurrency < 1) {\n            throw new Error(\"Trace batch concurrency must be positive.\");\n        }\n        this.debug = config.debug ?? this.debug;\n        this.fetchImplementation = config.fetchImplementation;\n        this.batchIngestCaller = new AsyncCaller({\n            maxRetries: 2,\n            maxConcurrency: this.traceBatchConcurrency,\n            ...(config.callerOptions ?? {}),\n            onFailedResponseHook: handle429,\n            debug: config.debug ?? this.debug,\n        });\n        this.hideInputs =\n            config.hideInputs ?? config.anonymizer ?? defaultConfig.hideInputs;\n        this.hideOutputs =\n            config.hideOutputs ?? config.anonymizer ?? defaultConfig.hideOutputs;\n        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n        this.blockOnRootRunFinalization =\n            config.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization;\n        this.batchSizeBytesLimit = config.batchSizeBytesLimit;\n        this.batchSizeLimit = config.batchSizeLimit;\n        this.fetchOptions = config.fetchOptions || {};\n        this.manualFlushMode = config.manualFlushMode ?? this.manualFlushMode;\n        if (getOtelEnabled()) {\n            this.langSmithToOTELTranslator = new LangSmithToOTELTranslator();\n        }\n        // Cache metadata env vars once during construction to avoid repeatedly scanning process.env\n        this.cachedLSEnvVarsForMetadata = getLangSmithEnvVarsMetadata();\n    }\n    static getDefaultClientConfig() {\n        const apiKey = getLangSmithEnvironmentVariable(\"API_KEY\");\n        const apiUrl = getLangSmithEnvironmentVariable(\"ENDPOINT\") ?? DEFAULT_API_URL;\n        const hideInputs = getLangSmithEnvironmentVariable(\"HIDE_INPUTS\") === \"true\";\n        const hideOutputs = getLangSmithEnvironmentVariable(\"HIDE_OUTPUTS\") === \"true\";\n        return {\n            apiUrl: apiUrl,\n            apiKey: apiKey,\n            webUrl: undefined,\n            hideInputs: hideInputs,\n            hideOutputs: hideOutputs,\n        };\n    }\n    getHostUrl() {\n        if (this.webUrl) {\n            return this.webUrl;\n        }\n        else if (isLocalhost(this.apiUrl)) {\n            this.webUrl = \"http://localhost:3000\";\n            return this.webUrl;\n        }\n        else if (this.apiUrl.endsWith(\"/api/v1\")) {\n            this.webUrl = this.apiUrl.replace(\"/api/v1\", \"\");\n            return this.webUrl;\n        }\n        else if (this.apiUrl.includes(\"/api\") &&\n            !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n            this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n            this.webUrl = \"https://dev.smith.langchain.com\";\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"eu\")) {\n            this.webUrl = \"https://eu.smith.langchain.com\";\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"beta\")) {\n            this.webUrl = \"https://beta.smith.langchain.com\";\n            return this.webUrl;\n        }\n        else {\n            this.webUrl = \"https://smith.langchain.com\";\n            return this.webUrl;\n        }\n    }\n    get headers() {\n        const headers = {\n            \"User-Agent\": `langsmith-js/${__version__}`,\n        };\n        if (this.apiKey) {\n            headers[\"x-api-key\"] = `${this.apiKey}`;\n        }\n        if (this.workspaceId) {\n            headers[\"x-tenant-id\"] = this.workspaceId;\n        }\n        return headers;\n    }\n    _getPlatformEndpointPath(path) {\n        // Check if apiUrl already ends with /v1 or /v1/ to avoid double /v1/v1/ paths\n        const needsV1Prefix = this.apiUrl.slice(-3) !== \"/v1\" && this.apiUrl.slice(-4) !== \"/v1/\";\n        return needsV1Prefix ? `/v1/platform/${path}` : `/platform/${path}`;\n    }\n    async processInputs(inputs) {\n        if (this.hideInputs === false) {\n            return inputs;\n        }\n        if (this.hideInputs === true) {\n            return {};\n        }\n        if (typeof this.hideInputs === \"function\") {\n            return this.hideInputs(inputs);\n        }\n        return inputs;\n    }\n    async processOutputs(outputs) {\n        if (this.hideOutputs === false) {\n            return outputs;\n        }\n        if (this.hideOutputs === true) {\n            return {};\n        }\n        if (typeof this.hideOutputs === \"function\") {\n            return this.hideOutputs(outputs);\n        }\n        return outputs;\n    }\n    async prepareRunCreateOrUpdateInputs(run) {\n        const runParams = { ...run };\n        if (runParams.inputs !== undefined) {\n            runParams.inputs = await this.processInputs(runParams.inputs);\n        }\n        if (runParams.outputs !== undefined) {\n            runParams.outputs = await this.processOutputs(runParams.outputs);\n        }\n        return runParams;\n    }\n    async _getResponse(path, queryParams) {\n        const paramsString = queryParams?.toString() ?? \"\";\n        const url = `${this.apiUrl}${path}?${paramsString}`;\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(url, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, `fetch ${path}`);\n            return res;\n        });\n        return response;\n    }\n    async _get(path, queryParams) {\n        const response = await this._getResponse(path, queryParams);\n        return response.json();\n    }\n    async *_getPaginated(path, queryParams = new URLSearchParams(), transform) {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while (true) {\n            queryParams.set(\"offset\", String(offset));\n            queryParams.set(\"limit\", String(limit));\n            const url = `${this.apiUrl}${path}?${queryParams}`;\n            const response = await this.caller.call(async () => {\n                const res = await this._fetch(url, {\n                    method: \"GET\",\n                    headers: this.headers,\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                });\n                await raiseForStatus(res, `fetch ${path}`);\n                return res;\n            });\n            const items = transform\n                ? transform(await response.json())\n                : await response.json();\n            if (items.length === 0) {\n                break;\n            }\n            yield items;\n            if (items.length < limit) {\n                break;\n            }\n            offset += items.length;\n        }\n    }\n    async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n        const bodyParams = body ? { ...body } : {};\n        while (true) {\n            const body = JSON.stringify(bodyParams);\n            const response = await this.caller.call(async () => {\n                const res = await this._fetch(`${this.apiUrl}${path}`, {\n                    method: requestMethod,\n                    headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                    body,\n                });\n                await raiseForStatus(res, `fetch ${path}`);\n                return res;\n            });\n            const responseBody = await response.json();\n            if (!responseBody) {\n                break;\n            }\n            if (!responseBody[dataKey]) {\n                break;\n            }\n            yield responseBody[dataKey];\n            const cursors = responseBody.cursors;\n            if (!cursors) {\n                break;\n            }\n            if (!cursors.next) {\n                break;\n            }\n            bodyParams.cursor = cursors.next;\n        }\n    }\n    // Allows mocking for tests\n    _shouldSample() {\n        if (this.tracingSampleRate === undefined) {\n            return true;\n        }\n        return Math.random() < this.tracingSampleRate;\n    }\n    _filterForSampling(runs, patch = false) {\n        if (this.tracingSampleRate === undefined) {\n            return runs;\n        }\n        if (patch) {\n            const sampled = [];\n            for (const run of runs) {\n                if (!this.filteredPostUuids.has(run.trace_id)) {\n                    sampled.push(run);\n                }\n                else if (run.id === run.trace_id) {\n                    this.filteredPostUuids.delete(run.trace_id);\n                }\n            }\n            return sampled;\n        }\n        else {\n            // For new runs, sample at trace level to maintain consistency\n            const sampled = [];\n            for (const run of runs) {\n                const traceId = run.trace_id ?? run.id;\n                // If we've already made a decision about this trace, follow it\n                if (this.filteredPostUuids.has(traceId)) {\n                    continue;\n                }\n                // For new traces, apply sampling\n                if (run.id === traceId) {\n                    if (this._shouldSample()) {\n                        sampled.push(run);\n                    }\n                    else {\n                        this.filteredPostUuids.add(traceId);\n                    }\n                }\n                else {\n                    // Child runs follow their trace's sampling decision\n                    sampled.push(run);\n                }\n            }\n            return sampled;\n        }\n    }\n    async _getBatchSizeLimitBytes() {\n        const serverInfo = await this._ensureServerInfo();\n        return (this.batchSizeBytesLimit ??\n            serverInfo.batch_ingest_config?.size_limit_bytes ??\n            DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES);\n    }\n    /**\n     * Get the maximum number of operations to batch in a single request.\n     */\n    async _getBatchSizeLimit() {\n        const serverInfo = await this._ensureServerInfo();\n        return (this.batchSizeLimit ??\n            serverInfo.batch_ingest_config?.size_limit ??\n            DEFAULT_BATCH_SIZE_LIMIT);\n    }\n    async _getDatasetExamplesMultiPartSupport() {\n        const serverInfo = await this._ensureServerInfo();\n        return (serverInfo.instance_flags?.dataset_examples_multipart_enabled ?? false);\n    }\n    drainAutoBatchQueue({ batchSizeLimitBytes, batchSizeLimit, }) {\n        const promises = [];\n        while (this.autoBatchQueue.items.length > 0) {\n            const [batch, done] = this.autoBatchQueue.pop({\n                upToSizeBytes: batchSizeLimitBytes,\n                upToSize: batchSizeLimit,\n            });\n            if (!batch.length) {\n                done();\n                break;\n            }\n            const batchesByDestination = batch.reduce((acc, item) => {\n                const apiUrl = item.apiUrl ?? this.apiUrl;\n                const apiKey = item.apiKey ?? this.apiKey;\n                const isDefault = item.apiKey === this.apiKey && item.apiUrl === this.apiUrl;\n                const batchKey = isDefault ? \"default\" : `${apiUrl}|${apiKey}`;\n                if (!acc[batchKey]) {\n                    acc[batchKey] = [];\n                }\n                acc[batchKey].push(item);\n                return acc;\n            }, {});\n            const batchPromises = [];\n            for (const [batchKey, batch] of Object.entries(batchesByDestination)) {\n                const batchPromise = this._processBatch(batch, {\n                    apiUrl: batchKey === \"default\" ? undefined : batchKey.split(\"|\")[0],\n                    apiKey: batchKey === \"default\" ? undefined : batchKey.split(\"|\")[1],\n                });\n                batchPromises.push(batchPromise);\n            }\n            // Wait for all batches to complete, then call the overall done callback\n            const allBatchesPromise = Promise.all(batchPromises).finally(done);\n            promises.push(allBatchesPromise);\n        }\n        return Promise.all(promises);\n    }\n    async _processBatch(batch, options) {\n        if (!batch.length) {\n            return;\n        }\n        try {\n            if (this.langSmithToOTELTranslator !== undefined) {\n                this._sendBatchToOTELTranslator(batch);\n            }\n            else {\n                const ingestParams = {\n                    runCreates: batch\n                        .filter((item) => item.action === \"create\")\n                        .map((item) => item.item),\n                    runUpdates: batch\n                        .filter((item) => item.action === \"update\")\n                        .map((item) => item.item),\n                };\n                const serverInfo = await this._ensureServerInfo();\n                if (serverInfo?.batch_ingest_config?.use_multipart_endpoint) {\n                    const useGzip = serverInfo?.instance_flags?.gzip_body_enabled;\n                    await this.multipartIngestRuns(ingestParams, { ...options, useGzip });\n                }\n                else {\n                    await this.batchIngestRuns(ingestParams, options);\n                }\n            }\n        }\n        catch (e) {\n            console.error(\"Error exporting batch:\", e);\n        }\n    }\n    _sendBatchToOTELTranslator(batch) {\n        if (this.langSmithToOTELTranslator !== undefined) {\n            const otelContextMap = new Map();\n            const operations = [];\n            for (const item of batch) {\n                if (item.item.id && item.otelContext) {\n                    otelContextMap.set(item.item.id, item.otelContext);\n                    if (item.action === \"create\") {\n                        operations.push({\n                            operation: \"post\",\n                            id: item.item.id,\n                            trace_id: item.item.trace_id ?? item.item.id,\n                            run: item.item,\n                        });\n                    }\n                    else {\n                        operations.push({\n                            operation: \"patch\",\n                            id: item.item.id,\n                            trace_id: item.item.trace_id ?? item.item.id,\n                            run: item.item,\n                        });\n                    }\n                }\n            }\n            this.langSmithToOTELTranslator.exportBatch(operations, otelContextMap);\n        }\n    }\n    async processRunOperation(item) {\n        clearTimeout(this.autoBatchTimeout);\n        this.autoBatchTimeout = undefined;\n        item.item = mergeRuntimeEnvIntoRun(item.item, this.cachedLSEnvVarsForMetadata);\n        const itemPromise = this.autoBatchQueue.push(item);\n        if (this.manualFlushMode) {\n            // Rely on manual flushing in serverless environments\n            return itemPromise;\n        }\n        const sizeLimitBytes = await this._getBatchSizeLimitBytes();\n        const sizeLimit = await this._getBatchSizeLimit();\n        if (this.autoBatchQueue.sizeBytes > sizeLimitBytes ||\n            this.autoBatchQueue.items.length > sizeLimit) {\n            void this.drainAutoBatchQueue({\n                batchSizeLimitBytes: sizeLimitBytes,\n                batchSizeLimit: sizeLimit,\n            });\n        }\n        if (this.autoBatchQueue.items.length > 0) {\n            this.autoBatchTimeout = setTimeout(() => {\n                this.autoBatchTimeout = undefined;\n                void this.drainAutoBatchQueue({\n                    batchSizeLimitBytes: sizeLimitBytes,\n                    batchSizeLimit: sizeLimit,\n                });\n            }, this.autoBatchAggregationDelayMs);\n        }\n        return itemPromise;\n    }\n    async _getServerInfo() {\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/info`, {\n                method: \"GET\",\n                headers: { Accept: \"application/json\" },\n                signal: AbortSignal.timeout(SERVER_INFO_REQUEST_TIMEOUT_MS),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"get server info\");\n            return res;\n        });\n        const json = await response.json();\n        if (this.debug) {\n            console.log(\"\\n=== LangSmith Server Configuration ===\\n\" +\n                JSON.stringify(json, null, 2) +\n                \"\\n\");\n        }\n        return json;\n    }\n    async _ensureServerInfo() {\n        if (this._getServerInfoPromise === undefined) {\n            this._getServerInfoPromise = (async () => {\n                if (this._serverInfo === undefined) {\n                    try {\n                        this._serverInfo = await this._getServerInfo();\n                    }\n                    catch (e) {\n                        console.warn(`[LANGSMITH]: Failed to fetch info on supported operations. Falling back to batch operations and default limits. Info: ${e.status ?? \"Unspecified status code\"} ${e.message}`);\n                    }\n                }\n                return this._serverInfo ?? {};\n            })();\n        }\n        return this._getServerInfoPromise.then((serverInfo) => {\n            if (this._serverInfo === undefined) {\n                this._getServerInfoPromise = undefined;\n            }\n            return serverInfo;\n        });\n    }\n    async _getSettings() {\n        if (!this.settings) {\n            this.settings = this._get(\"/settings\");\n        }\n        return await this.settings;\n    }\n    /**\n     * Flushes current queued traces.\n     */\n    async flush() {\n        const sizeLimitBytes = await this._getBatchSizeLimitBytes();\n        const sizeLimit = await this._getBatchSizeLimit();\n        await this.drainAutoBatchQueue({\n            batchSizeLimitBytes: sizeLimitBytes,\n            batchSizeLimit: sizeLimit,\n        });\n    }\n    _cloneCurrentOTELContext() {\n        const otel_trace = getOTELTrace();\n        const otel_context = getOTELContext();\n        if (this.langSmithToOTELTranslator !== undefined) {\n            const currentSpan = otel_trace.getActiveSpan();\n            if (currentSpan) {\n                return otel_trace.setSpan(otel_context.active(), currentSpan);\n            }\n        }\n        return undefined;\n    }\n    async createRun(run, options) {\n        if (!this._filterForSampling([run]).length) {\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n        };\n        const session_name = run.project_name;\n        delete run.project_name;\n        const runCreate = await this.prepareRunCreateOrUpdateInputs({\n            session_name,\n            ...run,\n            start_time: run.start_time ?? Date.now(),\n        });\n        if (this.autoBatchTracing &&\n            runCreate.trace_id !== undefined &&\n            runCreate.dotted_order !== undefined) {\n            const otelContext = this._cloneCurrentOTELContext();\n            void this.processRunOperation({\n                action: \"create\",\n                item: runCreate,\n                otelContext,\n                apiKey: options?.apiKey,\n                apiUrl: options?.apiUrl,\n            }).catch(console.error);\n            return;\n        }\n        const mergedRunCreateParam = mergeRuntimeEnvIntoRun(runCreate, this.cachedLSEnvVarsForMetadata);\n        if (options?.apiKey !== undefined) {\n            headers[\"x-api-key\"] = options.apiKey;\n        }\n        if (options?.workspaceId !== undefined) {\n            headers[\"x-tenant-id\"] = options.workspaceId;\n        }\n        const body = serializePayloadForTracing(mergedRunCreateParam, `Creating run with id: ${mergedRunCreateParam.id}`);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs`, {\n                method: \"POST\",\n                headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"create run\", true);\n            return res;\n        });\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */\n    async batchIngestRuns({ runCreates, runUpdates, }, options) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        let preparedCreateParams = await Promise.all(runCreates?.map((create) => this.prepareRunCreateOrUpdateInputs(create)) ?? []);\n        let preparedUpdateParams = await Promise.all(runUpdates?.map((update) => this.prepareRunCreateOrUpdateInputs(update)) ?? []);\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run) => {\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams) {\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam,\n                    };\n                }\n                else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        const rawBatch = {\n            post: preparedCreateParams,\n            patch: preparedUpdateParams,\n        };\n        if (!rawBatch.post.length && !rawBatch.patch.length) {\n            return;\n        }\n        const batchChunks = {\n            post: [],\n            patch: [],\n        };\n        for (const k of [\"post\", \"patch\"]) {\n            const key = k;\n            const batchItems = rawBatch[key].reverse();\n            let batchItem = batchItems.pop();\n            while (batchItem !== undefined) {\n                // Type is wrong but this is a deprecated code path anyway\n                batchChunks[key].push(batchItem);\n                batchItem = batchItems.pop();\n            }\n        }\n        if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {\n            const runIds = batchChunks.post\n                .map((item) => item.id)\n                .concat(batchChunks.patch.map((item) => item.id))\n                .join(\",\");\n            await this._postBatchIngestRuns(serializePayloadForTracing(batchChunks, `Ingesting runs with ids: ${runIds}`), options);\n        }\n    }\n    async _postBatchIngestRuns(body, options) {\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\",\n        };\n        if (options?.apiKey !== undefined) {\n            headers[\"x-api-key\"] = options.apiKey;\n        }\n        await this.batchIngestCaller.call(async () => {\n            const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/batch`, {\n                method: \"POST\",\n                headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"batch create run\", true);\n            return res;\n        });\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */\n    async multipartIngestRuns({ runCreates, runUpdates, }, options) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        // transform and convert to dicts\n        const allAttachments = {};\n        let preparedCreateParams = [];\n        for (const create of runCreates ?? []) {\n            const preparedCreate = await this.prepareRunCreateOrUpdateInputs(create);\n            if (preparedCreate.id !== undefined &&\n                preparedCreate.attachments !== undefined) {\n                allAttachments[preparedCreate.id] = preparedCreate.attachments;\n            }\n            delete preparedCreate.attachments;\n            preparedCreateParams.push(preparedCreate);\n        }\n        let preparedUpdateParams = [];\n        for (const update of runUpdates ?? []) {\n            preparedUpdateParams.push(await this.prepareRunCreateOrUpdateInputs(update));\n        }\n        // require trace_id and dotted_order\n        const invalidRunCreate = preparedCreateParams.find((runCreate) => {\n            return (runCreate.trace_id === undefined || runCreate.dotted_order === undefined);\n        });\n        if (invalidRunCreate !== undefined) {\n            throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when creating a run`);\n        }\n        const invalidRunUpdate = preparedUpdateParams.find((runUpdate) => {\n            return (runUpdate.trace_id === undefined || runUpdate.dotted_order === undefined);\n        });\n        if (invalidRunUpdate !== undefined) {\n            throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when updating a run`);\n        }\n        // combine post and patch dicts where possible\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run) => {\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams) {\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam,\n                    };\n                }\n                else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        if (preparedCreateParams.length === 0 &&\n            preparedUpdateParams.length === 0) {\n            return;\n        }\n        // send the runs in multipart requests\n        const accumulatedContext = [];\n        const accumulatedParts = [];\n        for (const [method, payloads] of [\n            [\"post\", preparedCreateParams],\n            [\"patch\", preparedUpdateParams],\n        ]) {\n            for (const originalPayload of payloads) {\n                // collect fields to be sent as separate parts\n                const { inputs, outputs, events, extra, error, serialized, attachments, ...payload } = originalPayload;\n                const fields = { inputs, outputs, events, extra, error, serialized };\n                // encode the main run payload\n                const stringifiedPayload = serializePayloadForTracing(payload, `Serializing for multipart ingestion of run with id: ${payload.id}`);\n                accumulatedParts.push({\n                    name: `${method}.${payload.id}`,\n                    payload: new Blob([stringifiedPayload], {\n                        type: `application/json; length=${stringifiedPayload.length}`, // encoding=gzip\n                    }),\n                });\n                // encode the fields we collected\n                for (const [key, value] of Object.entries(fields)) {\n                    if (value === undefined) {\n                        continue;\n                    }\n                    const stringifiedValue = serializePayloadForTracing(value, `Serializing ${key} for multipart ingestion of run with id: ${payload.id}`);\n                    accumulatedParts.push({\n                        name: `${method}.${payload.id}.${key}`,\n                        payload: new Blob([stringifiedValue], {\n                            type: `application/json; length=${stringifiedValue.length}`,\n                        }),\n                    });\n                }\n                // encode the attachments\n                if (payload.id !== undefined) {\n                    const attachments = allAttachments[payload.id];\n                    if (attachments) {\n                        delete allAttachments[payload.id];\n                        for (const [name, attachment] of Object.entries(attachments)) {\n                            let contentType;\n                            let content;\n                            if (Array.isArray(attachment)) {\n                                [contentType, content] = attachment;\n                            }\n                            else {\n                                contentType = attachment.mimeType;\n                                content = attachment.data;\n                            }\n                            // Validate that the attachment name doesn't contain a '.'\n                            if (name.includes(\".\")) {\n                                console.warn(`Skipping attachment '${name}' for run ${payload.id}: Invalid attachment name. ` +\n                                    `Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);\n                                continue;\n                            }\n                            accumulatedParts.push({\n                                name: `attachment.${payload.id}.${name}`,\n                                payload: new Blob([content], {\n                                    type: `${contentType}; length=${content.byteLength}`,\n                                }),\n                            });\n                        }\n                    }\n                }\n                // compute context\n                accumulatedContext.push(`trace=${payload.trace_id},id=${payload.id}`);\n            }\n        }\n        await this._sendMultipartRequest(accumulatedParts, accumulatedContext.join(\"; \"), options);\n    }\n    async _createNodeFetchBody(parts, boundary) {\n        // Create multipart form data manually using Blobs\n        const chunks = [];\n        for (const part of parts) {\n            // Add field boundary\n            chunks.push(new Blob([`--${boundary}\\r\\n`]));\n            chunks.push(new Blob([\n                `Content-Disposition: form-data; name=\"${part.name}\"\\r\\n`,\n                `Content-Type: ${part.payload.type}\\r\\n\\r\\n`,\n            ]));\n            chunks.push(part.payload);\n            chunks.push(new Blob([\"\\r\\n\"]));\n        }\n        // Add final boundary\n        chunks.push(new Blob([`--${boundary}--\\r\\n`]));\n        // Combine all chunks into a single Blob\n        const body = new Blob(chunks);\n        // Convert Blob to ArrayBuffer for compatibility\n        const arrayBuffer = await body.arrayBuffer();\n        return arrayBuffer;\n    }\n    async _createMultipartStream(parts, boundary) {\n        const encoder = new TextEncoder();\n        // Create a ReadableStream for streaming the multipart data\n        // Only do special handling if we're using node-fetch\n        const stream = new ReadableStream({\n            async start(controller) {\n                // Helper function to write a chunk to the stream\n                const writeChunk = async (chunk) => {\n                    if (typeof chunk === \"string\") {\n                        controller.enqueue(encoder.encode(chunk));\n                    }\n                    else {\n                        controller.enqueue(chunk);\n                    }\n                };\n                // Write each part to the stream\n                for (const part of parts) {\n                    // Write boundary and headers\n                    await writeChunk(`--${boundary}\\r\\n`);\n                    await writeChunk(`Content-Disposition: form-data; name=\"${part.name}\"\\r\\n`);\n                    await writeChunk(`Content-Type: ${part.payload.type}\\r\\n\\r\\n`);\n                    // Write the payload\n                    const payloadStream = part.payload.stream();\n                    const reader = payloadStream.getReader();\n                    try {\n                        let result;\n                        while (!(result = await reader.read()).done) {\n                            controller.enqueue(result.value);\n                        }\n                    }\n                    finally {\n                        reader.releaseLock();\n                    }\n                    await writeChunk(\"\\r\\n\");\n                }\n                // Write final boundary\n                await writeChunk(`--${boundary}--\\r\\n`);\n                controller.close();\n            },\n        });\n        return stream;\n    }\n    async _sendMultipartRequest(parts, context, options) {\n        // Create multipart form data boundary\n        const boundary = \"----LangSmithFormBoundary\" + Math.random().toString(36).slice(2);\n        const isNodeFetch = _globalFetchImplementationIsNodeFetch();\n        const buildBuffered = () => this._createNodeFetchBody(parts, boundary);\n        const buildStream = () => this._createMultipartStream(parts, boundary);\n        const sendWithRetry = async (bodyFactory) => {\n            return this.batchIngestCaller.call(async () => {\n                const body = await bodyFactory();\n                const headers = {\n                    ...this.headers,\n                    \"Content-Type\": `multipart/form-data; boundary=${boundary}`,\n                };\n                if (options?.apiKey !== undefined) {\n                    headers[\"x-api-key\"] = options.apiKey;\n                }\n                let transformedBody = body;\n                if (options?.useGzip &&\n                    typeof body === \"object\" &&\n                    \"pipeThrough\" in body) {\n                    transformedBody = body.pipeThrough(new CompressionStream(\"gzip\"));\n                    headers[\"Content-Encoding\"] = \"gzip\";\n                }\n                const response = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/multipart`, {\n                    method: \"POST\",\n                    headers,\n                    body: transformedBody,\n                    duplex: \"half\",\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                });\n                await raiseForStatus(response, `Failed to send multipart request`, true);\n                return response;\n            });\n        };\n        try {\n            let res;\n            let streamedAttempt = false;\n            // attempt stream only if not disabled and not using node-fetch or Bun\n            if (!isNodeFetch &&\n                !this.multipartStreamingDisabled &&\n                getEnv() !== \"bun\") {\n                streamedAttempt = true;\n                res = await sendWithRetry(buildStream);\n            }\n            else {\n                res = await sendWithRetry(buildBuffered);\n            }\n            // if stream fails, fallback to buffered body\n            if ((!this.multipartStreamingDisabled || streamedAttempt) &&\n                res.status === 422 &&\n                (options?.apiUrl ?? this.apiUrl) !== DEFAULT_API_URL) {\n                console.warn(`Streaming multipart upload to ${options?.apiUrl ?? this.apiUrl}/runs/multipart failed. ` +\n                    `This usually means the host does not support chunked uploads. ` +\n                    `Retrying with a buffered upload for operation \"${context}\".`);\n                // Disable streaming for future requests\n                this.multipartStreamingDisabled = true;\n                // retry with fully-buffered body\n                res = await sendWithRetry(buildBuffered);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            console.warn(`${e.message.trim()}\\n\\nContext: ${context}`);\n        }\n    }\n    async updateRun(runId, run, options) {\n        assertUuid(runId);\n        if (run.inputs) {\n            run.inputs = await this.processInputs(run.inputs);\n        }\n        if (run.outputs) {\n            run.outputs = await this.processOutputs(run.outputs);\n        }\n        // TODO: Untangle types\n        const data = { ...run, id: runId };\n        if (!this._filterForSampling([data], true).length) {\n            return;\n        }\n        if (this.autoBatchTracing &&\n            data.trace_id !== undefined &&\n            data.dotted_order !== undefined) {\n            const otelContext = this._cloneCurrentOTELContext();\n            if (run.end_time !== undefined &&\n                data.parent_run_id === undefined &&\n                this.blockOnRootRunFinalization &&\n                !this.manualFlushMode) {\n                // Trigger batches as soon as a root trace ends and wait to ensure trace finishes\n                // in serverless environments.\n                await this.processRunOperation({\n                    action: \"update\",\n                    item: data,\n                    otelContext,\n                    apiKey: options?.apiKey,\n                    apiUrl: options?.apiUrl,\n                }).catch(console.error);\n                return;\n            }\n            else {\n                void this.processRunOperation({\n                    action: \"update\",\n                    item: data,\n                    otelContext,\n                    apiKey: options?.apiKey,\n                    apiUrl: options?.apiUrl,\n                }).catch(console.error);\n            }\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n        };\n        if (options?.apiKey !== undefined) {\n            headers[\"x-api-key\"] = options.apiKey;\n        }\n        if (options?.workspaceId !== undefined) {\n            headers[\"x-tenant-id\"] = options.workspaceId;\n        }\n        const body = serializePayloadForTracing(run, `Serializing payload to update run with id: ${runId}`);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/${runId}`, {\n                method: \"PATCH\",\n                headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"update run\", true);\n            return res;\n        });\n    }\n    async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {\n        assertUuid(runId);\n        let run = await this._get(`/runs/${runId}`);\n        if (loadChildRuns) {\n            run = await this._loadChildRuns(run);\n        }\n        return run;\n    }\n    async getRunUrl({ runId, run, projectOpts, }) {\n        if (run !== undefined) {\n            let sessionId;\n            if (run.session_id) {\n                sessionId = run.session_id;\n            }\n            else if (projectOpts?.projectName) {\n                sessionId = (await this.readProject({ projectName: projectOpts?.projectName })).id;\n            }\n            else if (projectOpts?.projectId) {\n                sessionId = projectOpts?.projectId;\n            }\n            else {\n                const project = await this.readProject({\n                    projectName: getLangSmithEnvironmentVariable(\"PROJECT\") || \"default\",\n                });\n                sessionId = project.id;\n            }\n            const tenantId = await this._getTenantId();\n            return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n        }\n        else if (runId !== undefined) {\n            const run_ = await this.readRun(runId);\n            if (!run_.app_path) {\n                throw new Error(`Run ${runId} has no app_path`);\n            }\n            const baseUrl = this.getHostUrl();\n            return `${baseUrl}${run_.app_path}`;\n        }\n        else {\n            throw new Error(\"Must provide either runId or run\");\n        }\n    }\n    async _loadChildRuns(run) {\n        const childRuns = await toArray(this.listRuns({\n            isRoot: false,\n            projectId: run.session_id,\n            traceId: run.trace_id,\n        }));\n        const treemap = {};\n        const runs = {};\n        // TODO: make dotted order required when the migration finishes\n        childRuns.sort((a, b) => (a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n        for (const childRun of childRuns) {\n            if (childRun.parent_run_id === null ||\n                childRun.parent_run_id === undefined) {\n                throw new Error(`Child run ${childRun.id} has no parent`);\n            }\n            if (childRun.dotted_order?.startsWith(run.dotted_order ?? \"\") &&\n                childRun.id !== run.id) {\n                if (!(childRun.parent_run_id in treemap)) {\n                    treemap[childRun.parent_run_id] = [];\n                }\n                treemap[childRun.parent_run_id].push(childRun);\n                runs[childRun.id] = childRun;\n            }\n        }\n        run.child_runs = treemap[run.id] || [];\n        for (const runId in treemap) {\n            if (runId !== run.id) {\n                runs[runId].child_runs = treemap[runId];\n            }\n        }\n        return run;\n    }\n    /**\n     * List runs from the LangSmith server.\n     * @param projectId - The ID of the project to filter by.\n     * @param projectName - The name of the project to filter by.\n     * @param parentRunId - The ID of the parent run to filter by.\n     * @param traceId - The ID of the trace to filter by.\n     * @param referenceExampleId - The ID of the reference example to filter by.\n     * @param startTime - The start time to filter by.\n     * @param isRoot - Indicates whether to only return root runs.\n     * @param runType - The run type to filter by.\n     * @param error - Indicates whether to filter by error runs.\n     * @param id - The ID of the run to filter by.\n     * @param query - The query string to filter by.\n     * @param filter - The filter string to apply to the run spans.\n     * @param traceFilter - The filter string to apply on the root run of the trace.\n     * @param treeFilter - The filter string to apply on other runs in the trace.\n     * @param limit - The maximum number of runs to retrieve.\n     * @returns {AsyncIterable<Run>} - The runs.\n     *\n     * @example\n     * // List all runs in a project\n     * const projectRuns = client.listRuns({ projectName: \"<your_project>\" });\n     *\n     * @example\n     * // List LLM and Chat runs in the last 24 hours\n     * const todaysLLMRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),\n     *   run_type: \"llm\",\n     * });\n     *\n     * @example\n     * // List traces in a project\n     * const rootRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   execution_order: 1,\n     * });\n     *\n     * @example\n     * // List runs without errors\n     * const correctRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   error: false,\n     * });\n     *\n     * @example\n     * // List runs by run ID\n     * const runIds = [\n     *   \"a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836\",\n     *   \"9398e6be-964f-4aa4-8ae9-ad78cd4b7074\",\n     * ];\n     * const selectedRuns = client.listRuns({ run_ids: runIds });\n     *\n     * @example\n     * // List all \"chain\" type runs that took more than 10 seconds and had `total_tokens` greater than 5000\n     * const chainRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(eq(run_type, \"chain\"), gt(latency, 10), gt(total_tokens, 5000))',\n     * });\n     *\n     * @example\n     * // List all runs called \"extractor\" whose root of the trace was assigned feedback \"user_score\" score of 1\n     * const goodExtractorRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'eq(name, \"extractor\")',\n     *   traceFilter: 'and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))',\n     * });\n     *\n     * @example\n     * // List all runs that started after a specific timestamp and either have \"error\" not equal to null or a \"Correctness\" feedback score equal to 0\n     * const complexRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(gt(start_time, \"2023-07-15T12:34:56Z\"), or(neq(error, null), and(eq(feedback_key, \"Correctness\"), eq(feedback_score, 0.0))))',\n     * });\n     *\n     * @example\n     * // List all runs where `tags` include \"experimental\" or \"beta\" and `latency` is greater than 2 seconds\n     * const taggedRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(or(has(tags, \"experimental\"), has(tags, \"beta\")), gt(latency, 2))',\n     * });\n     */\n    async *listRuns(props) {\n        const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, isRoot, runType, error, id, query, filter, traceFilter, treeFilter, limit, select, order, } = props;\n        let projectIds = [];\n        if (projectId) {\n            projectIds = Array.isArray(projectId) ? projectId : [projectId];\n        }\n        if (projectName) {\n            const projectNames = Array.isArray(projectName)\n                ? projectName\n                : [projectName];\n            const projectIds_ = await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)));\n            projectIds.push(...projectIds_);\n        }\n        const default_select = [\n            \"app_path\",\n            \"completion_cost\",\n            \"completion_tokens\",\n            \"dotted_order\",\n            \"end_time\",\n            \"error\",\n            \"events\",\n            \"extra\",\n            \"feedback_stats\",\n            \"first_token_time\",\n            \"id\",\n            \"inputs\",\n            \"name\",\n            \"outputs\",\n            \"parent_run_id\",\n            \"parent_run_ids\",\n            \"prompt_cost\",\n            \"prompt_tokens\",\n            \"reference_example_id\",\n            \"run_type\",\n            \"session_id\",\n            \"start_time\",\n            \"status\",\n            \"tags\",\n            \"total_cost\",\n            \"total_tokens\",\n            \"trace_id\",\n        ];\n        const body = {\n            session: projectIds.length ? projectIds : null,\n            run_type: runType,\n            reference_example: referenceExampleId,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            execution_order: executionOrder,\n            parent_run: parentRunId,\n            start_time: startTime ? startTime.toISOString() : null,\n            error,\n            id,\n            limit,\n            trace: traceId,\n            select: select ? select : default_select,\n            is_root: isRoot,\n            order,\n        };\n        if (body.select.includes(\"child_run_ids\")) {\n            warnOnce(\"Deprecated: 'child_run_ids' in the listRuns select parameter is deprecated and will be removed in a future version.\");\n        }\n        let runsYielded = 0;\n        for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)) {\n            if (limit) {\n                if (runsYielded >= limit) {\n                    break;\n                }\n                if (runs.length + runsYielded > limit) {\n                    const newRuns = runs.slice(0, limit - runsYielded);\n                    yield* newRuns;\n                    break;\n                }\n                runsYielded += runs.length;\n                yield* runs;\n            }\n            else {\n                yield* runs;\n            }\n        }\n    }\n    async *listGroupRuns(props) {\n        const { projectId, projectName, groupBy, filter, startTime, endTime, limit, offset, } = props;\n        const sessionId = projectId || (await this.readProject({ projectName })).id;\n        const baseBody = {\n            session_id: sessionId,\n            group_by: groupBy,\n            filter,\n            start_time: startTime ? startTime.toISOString() : null,\n            end_time: endTime ? endTime.toISOString() : null,\n            limit: Number(limit) || 100,\n        };\n        let currentOffset = Number(offset) || 0;\n        const path = \"/runs/group\";\n        const url = `${this.apiUrl}${path}`;\n        while (true) {\n            const currentBody = {\n                ...baseBody,\n                offset: currentOffset,\n            };\n            // Remove undefined values from the payload\n            const filteredPayload = Object.fromEntries(Object.entries(currentBody).filter(([_, value]) => value !== undefined));\n            const body = JSON.stringify(filteredPayload);\n            const response = await this.caller.call(async () => {\n                const res = await this._fetch(url, {\n                    method: \"POST\",\n                    headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                    body,\n                });\n                await raiseForStatus(res, `Failed to fetch ${path}`);\n                return res;\n            });\n            const items = await response.json();\n            const { groups, total } = items;\n            if (groups.length === 0) {\n                break;\n            }\n            for (const thread of groups) {\n                yield thread;\n            }\n            currentOffset += groups.length;\n            if (currentOffset >= total) {\n                break;\n            }\n        }\n    }\n    async getRunStats({ id, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime, endTime, error, query, filter, traceFilter, treeFilter, isRoot, dataSourceType, }) {\n        let projectIds_ = projectIds || [];\n        if (projectNames) {\n            projectIds_ = [\n                ...(projectIds || []),\n                ...(await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)))),\n            ];\n        }\n        const payload = {\n            id,\n            trace,\n            parent_run: parentRun,\n            run_type: runType,\n            session: projectIds_,\n            reference_example: referenceExampleIds,\n            start_time: startTime,\n            end_time: endTime,\n            error,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            is_root: isRoot,\n            data_source_type: dataSourceType,\n        };\n        // Remove undefined values from the payload\n        const filteredPayload = Object.fromEntries(Object.entries(payload).filter(([_, value]) => value !== undefined));\n        const body = JSON.stringify(filteredPayload);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/runs/stats`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"get run stats\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async shareRun(runId, { shareId } = {}) {\n        const data = {\n            run_id: runId,\n            share_token: shareId || uuid.v4(),\n        };\n        assertUuid(runId);\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {\n                method: \"PUT\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"share run\");\n            return res;\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            throw new Error(\"Invalid response from server\");\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async unshareRun(runId) {\n        assertUuid(runId);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"unshare run\", true);\n            return res;\n        });\n    }\n    async readRunSharedLink(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"read run shared link\");\n            return res;\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            return undefined;\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async listSharedRuns(shareToken, { runIds, } = {}) {\n        const queryParams = new URLSearchParams({\n            share_token: shareToken,\n        });\n        if (runIds !== undefined) {\n            for (const runId of runIds) {\n                queryParams.append(\"id\", runId);\n            }\n        }\n        assertUuid(shareToken);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"list shared runs\");\n            return res;\n        });\n        const runs = await response.json();\n        return runs;\n    }\n    async readDatasetSharedSchema(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        assertUuid(datasetId);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"read dataset shared schema\");\n            return res;\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async shareDataset(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        const data = {\n            dataset_id: datasetId,\n        };\n        assertUuid(datasetId);\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {\n                method: \"PUT\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"share dataset\");\n            return res;\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async unshareDataset(datasetId) {\n        assertUuid(datasetId);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"unshare dataset\", true);\n            return res;\n        });\n    }\n    async readSharedDataset(shareToken) {\n        assertUuid(shareToken);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/datasets`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"read shared dataset\");\n            return res;\n        });\n        const dataset = await response.json();\n        return dataset;\n    }\n    /**\n     * Get shared examples.\n     *\n     * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.\n     * @param {Object} [options] Additional options for listing the examples.\n     * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.\n     * @returns {Promise<Example[]>} The shared examples.\n     */\n    async listSharedExamples(shareToken, options) {\n        const params = {};\n        if (options?.exampleIds) {\n            params.id = options.exampleIds;\n        }\n        const urlParams = new URLSearchParams();\n        Object.entries(params).forEach(([key, value]) => {\n            if (Array.isArray(value)) {\n                value.forEach((v) => urlParams.append(key, v));\n            }\n            else {\n                urlParams.append(key, value);\n            }\n        });\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/examples?${urlParams.toString()}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"list shared examples\");\n            return res;\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            if (\"detail\" in result) {\n                throw new Error(`Failed to list shared examples.\\nStatus: ${response.status}\\nMessage: ${Array.isArray(result.detail)\n                    ? result.detail.join(\"\\n\")\n                    : \"Unspecified error\"}`);\n            }\n            throw new Error(`Failed to list shared examples: ${response.status} ${response.statusText}`);\n        }\n        return result.map((example) => ({\n            ...example,\n            _hostUrl: this.getHostUrl(),\n        }));\n    }\n    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null, }) {\n        const upsert_ = upsert ? `?upsert=true` : \"\";\n        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n        const extra = projectExtra || {};\n        if (metadata) {\n            extra[\"metadata\"] = metadata;\n        }\n        const body = {\n            name: projectName,\n            extra,\n            description,\n        };\n        if (referenceDatasetId !== null) {\n            body[\"reference_dataset_id\"] = referenceDatasetId;\n        }\n        const serializedBody = JSON.stringify(body);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(endpoint, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody,\n            });\n            await raiseForStatus(res, \"create project\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null, }) {\n        const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n        let extra = projectExtra;\n        if (metadata) {\n            extra = { ...(extra || {}), metadata };\n        }\n        const body = JSON.stringify({\n            name,\n            extra,\n            description,\n            end_time: endTime ? new Date(endTime).toISOString() : null,\n        });\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(endpoint, {\n                method: \"PATCH\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"update project\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async hasProject({ projectId, projectName, }) {\n        // TODO: Add a head request\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}${path}?${params}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"has project\");\n            return res;\n        });\n        // consume the response body to release the connection\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        try {\n            const result = await response.json();\n            if (!response.ok) {\n                return false;\n            }\n            // If it's OK and we're querying by name, need to check the list is not empty\n            if (Array.isArray(result)) {\n                return result.length > 0;\n            }\n            // projectId querying\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    async readProject({ projectId, projectName, includeStats, }) {\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async getProjectUrl({ projectId, projectName, }) {\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide either projectName or projectId\");\n        }\n        const project = await this.readProject({ projectId, projectName });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;\n    }\n    async getDatasetUrl({ datasetId, datasetName, }) {\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const dataset = await this.readDataset({ datasetId, datasetName });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;\n    }\n    async _getTenantId() {\n        if (this._tenantId !== null) {\n            return this._tenantId;\n        }\n        const queryParams = new URLSearchParams({ limit: \"1\" });\n        for await (const projects of this._getPaginated(\"/sessions\", queryParams)) {\n            this._tenantId = projects[0].tenant_id;\n            return projects[0].tenant_id;\n        }\n        throw new Error(\"No projects found to resolve tenant.\");\n    }\n    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, includeStats, datasetVersion, referenceFree, metadata, } = {}) {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n            for (const projectId of projectIds) {\n                params.append(\"id\", projectId);\n            }\n        }\n        if (name !== undefined) {\n            params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n            params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n            params.append(\"reference_dataset\", referenceDatasetId);\n        }\n        else if (referenceDatasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName: referenceDatasetName,\n            });\n            params.append(\"reference_dataset\", dataset.id);\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        if (datasetVersion !== undefined) {\n            params.append(\"dataset_version\", datasetVersion);\n        }\n        if (referenceFree !== undefined) {\n            params.append(\"reference_free\", referenceFree.toString());\n        }\n        if (metadata !== undefined) {\n            params.append(\"metadata\", JSON.stringify(metadata));\n        }\n        for await (const projects of this._getPaginated(\"/sessions\", params)) {\n            yield* projects;\n        }\n    }\n    async deleteProject({ projectId, projectName, }) {\n        let projectId_;\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        else if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId === undefined) {\n            projectId_ = (await this.readProject({ projectName })).id;\n        }\n        else {\n            projectId_ = projectId;\n        }\n        assertUuid(projectId_);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/sessions/${projectId_}`, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, `delete session ${projectId_} (${projectName})`, true);\n            return res;\n        });\n    }\n    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name, }) {\n        const url = `${this.apiUrl}/datasets/upload`;\n        const formData = new FormData();\n        formData.append(\"file\", csvFile, fileName);\n        inputKeys.forEach((key) => {\n            formData.append(\"input_keys\", key);\n        });\n        outputKeys.forEach((key) => {\n            formData.append(\"output_keys\", key);\n        });\n        if (description) {\n            formData.append(\"description\", description);\n        }\n        if (dataType) {\n            formData.append(\"data_type\", dataType);\n        }\n        if (name) {\n            formData.append(\"name\", name);\n        }\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(url, {\n                method: \"POST\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: formData,\n            });\n            await raiseForStatus(res, \"upload CSV\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async createDataset(name, { description, dataType, inputsSchema, outputsSchema, metadata, } = {}) {\n        const body = {\n            name,\n            description,\n            extra: metadata ? { metadata } : undefined,\n        };\n        if (dataType) {\n            body.data_type = dataType;\n        }\n        if (inputsSchema) {\n            body.inputs_schema_definition = inputsSchema;\n        }\n        if (outputsSchema) {\n            body.outputs_schema_definition = outputsSchema;\n        }\n        const serializedBody = JSON.stringify(body);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody,\n            });\n            await raiseForStatus(res, \"create dataset\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async readDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        // limit to 1 result\n        const params = new URLSearchParams({ limit: \"1\" });\n        if (datasetId && datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId) {\n            assertUuid(datasetId);\n            path += `/${datasetId}`;\n        }\n        else if (datasetName) {\n            params.append(\"name\", datasetName);\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async hasDataset({ datasetId, datasetName, }) {\n        try {\n            await this.readDataset({ datasetId, datasetName });\n            return true;\n        }\n        catch (e) {\n            if (\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            e instanceof Error &&\n                e.message.toLocaleLowerCase().includes(\"not found\")) {\n                return false;\n            }\n            throw e;\n        }\n    }\n    async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion, }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const urlParams = new URLSearchParams({\n            from_version: typeof fromVersion === \"string\"\n                ? fromVersion\n                : fromVersion.toISOString(),\n            to_version: typeof toVersion === \"string\" ? toVersion : toVersion.toISOString(),\n        });\n        const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);\n        return response;\n    }\n    async readDatasetOpenaiFinetuning({ datasetId, datasetName, }) {\n        const path = \"/datasets\";\n        if (datasetId !== undefined) {\n            // do nothing\n        }\n        else if (datasetName !== undefined) {\n            datasetId = (await this.readDataset({ datasetName })).id;\n        }\n        else {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n        const datasetText = await response.text();\n        const dataset = datasetText\n            .trim()\n            .split(\"\\n\")\n            .map((line) => JSON.parse(line));\n        return dataset;\n    }\n    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, metadata, } = {}) {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString(),\n        });\n        if (datasetIds !== undefined) {\n            for (const id_ of datasetIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n            params.append(\"name_contains\", datasetNameContains);\n        }\n        if (metadata !== undefined) {\n            params.append(\"metadata\", JSON.stringify(metadata));\n        }\n        for await (const datasets of this._getPaginated(path, params)) {\n            yield* datasets;\n        }\n    }\n    /**\n     * Update a dataset\n     * @param props The dataset details to update\n     * @returns The updated dataset\n     */\n    async updateDataset(props) {\n        const { datasetId, datasetName, ...update } = props;\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;\n        assertUuid(_datasetId);\n        const body = JSON.stringify(update);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${_datasetId}`, {\n                method: \"PATCH\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"update dataset\");\n            return res;\n        });\n        return (await response.json());\n    }\n    /**\n     * Updates a tag on a dataset.\n     *\n     * If the tag is already assigned to a different version of this dataset,\n     * the tag will be moved to the new version. The as_of parameter is used to\n     * determine which version of the dataset to apply the new tags to.\n     *\n     * It must be an exact version of the dataset to succeed. You can\n     * use the \"readDatasetVersion\" method to find the exact version\n     * to apply the tags to.\n     * @param params.datasetId The ID of the dataset to update. Must be provided if \"datasetName\" is not provided.\n     * @param params.datasetName The name of the dataset to update. Must be provided if \"datasetId\" is not provided.\n     * @param params.asOf The timestamp of the dataset to apply the new tags to.\n     * @param params.tag The new tag to apply to the dataset.\n     */\n    async updateDatasetTag(props) {\n        const { datasetId, datasetName, asOf, tag } = props;\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;\n        assertUuid(_datasetId);\n        const body = JSON.stringify({\n            as_of: typeof asOf === \"string\" ? asOf : asOf.toISOString(),\n            tag,\n        });\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${_datasetId}/tags`, {\n                method: \"PUT\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"update dataset tags\", true);\n            return res;\n        });\n    }\n    async deleteDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        let datasetId_ = datasetId;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        if (datasetId_ !== undefined) {\n            assertUuid(datasetId_);\n            path += `/${datasetId_}`;\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        await this.caller.call(async () => {\n            const res = await this._fetch(this.apiUrl + path, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, `delete ${path}`, true);\n            return res;\n        });\n    }\n    async indexDataset({ datasetId, datasetName, tag, }) {\n        let datasetId_ = datasetId;\n        if (!datasetId_ && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ && datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (!datasetId_) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        assertUuid(datasetId_);\n        const data = {\n            tag: tag,\n        };\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId_}/index`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"index dataset\");\n            return res;\n        });\n        await response.json();\n    }\n    /**\n     * Lets you run a similarity search query on a dataset.\n     *\n     * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.\n     *\n     * @param inputs      The input on which to run the similarity search. Must have the\n     *                    same schema as the dataset.\n     *\n     * @param datasetId   The dataset to search for similar examples.\n     *\n     * @param limit       The maximum number of examples to return. Will return the top `limit` most\n     *                    similar examples in order of most similar to least similar. If no similar\n     *                    examples are found, random examples will be returned.\n     *\n     * @param filter      A filter string to apply to the search. Only examples will be returned that\n     *                    match the filter string. Some examples of filters\n     *\n     *                    - eq(metadata.mykey, \"value\")\n     *                    - and(neq(metadata.my.nested.key, \"value\"), neq(metadata.mykey, \"value\"))\n     *                    - or(eq(metadata.mykey, \"value\"), eq(metadata.mykey, \"othervalue\"))\n     *\n     * @returns           A list of similar examples.\n     *\n     *\n     * @example\n     * dataset_id = \"123e4567-e89b-12d3-a456-426614174000\"\n     * inputs = {\"text\": \"How many people live in Berlin?\"}\n     * limit = 5\n     * examples = await client.similarExamples(inputs, dataset_id, limit)\n     */\n    async similarExamples(inputs, datasetId, limit, { filter, } = {}) {\n        const data = {\n            limit: limit,\n            inputs: inputs,\n        };\n        if (filter !== undefined) {\n            data[\"filter\"] = filter;\n        }\n        assertUuid(datasetId);\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/search`, {\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                method: \"POST\",\n                body,\n            });\n            await raiseForStatus(res, \"fetch similar examples\");\n            return res;\n        });\n        const result = await response.json();\n        return result[\"examples\"];\n    }\n    async createExample(inputsOrUpdate, outputs, options) {\n        if (isExampleCreate(inputsOrUpdate)) {\n            if (outputs !== undefined || options !== undefined) {\n                throw new Error(\"Cannot provide outputs or options when using ExampleCreate object\");\n            }\n        }\n        let datasetId_ = outputs ? options?.datasetId : inputsOrUpdate.dataset_id;\n        const datasetName_ = outputs\n            ? options?.datasetName\n            : inputsOrUpdate.dataset_name;\n        if (datasetId_ === undefined && datasetName_ === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName: datasetName_ });\n            datasetId_ = dataset.id;\n        }\n        const createdAt_ = (outputs ? options?.createdAt : inputsOrUpdate.created_at) || new Date();\n        let data;\n        if (!isExampleCreate(inputsOrUpdate)) {\n            data = {\n                inputs: inputsOrUpdate,\n                outputs,\n                created_at: createdAt_?.toISOString(),\n                id: options?.exampleId,\n                metadata: options?.metadata,\n                split: options?.split,\n                source_run_id: options?.sourceRunId,\n                use_source_run_io: options?.useSourceRunIO,\n                use_source_run_attachments: options?.useSourceRunAttachments,\n                attachments: options?.attachments,\n            };\n        }\n        else {\n            data = inputsOrUpdate;\n        }\n        const response = await this._uploadExamplesMultipart(datasetId_, [data]);\n        const example = await this.readExample(response.example_ids?.[0] ?? uuid.v4());\n        return example;\n    }\n    async createExamples(propsOrUploads) {\n        if (Array.isArray(propsOrUploads)) {\n            if (propsOrUploads.length === 0) {\n                return [];\n            }\n            const uploads = propsOrUploads;\n            let datasetId_ = uploads[0].dataset_id;\n            const datasetName_ = uploads[0].dataset_name;\n            if (datasetId_ === undefined && datasetName_ === undefined) {\n                throw new Error(\"Must provide either datasetName or datasetId\");\n            }\n            else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n                throw new Error(\"Must provide either datasetName or datasetId, not both\");\n            }\n            else if (datasetId_ === undefined) {\n                const dataset = await this.readDataset({ datasetName: datasetName_ });\n                datasetId_ = dataset.id;\n            }\n            const response = await this._uploadExamplesMultipart(datasetId_, uploads);\n            const examples = await Promise.all(response.example_ids.map((id) => this.readExample(id)));\n            return examples;\n        }\n        const { inputs, outputs, metadata, splits, sourceRunIds, useSourceRunIOs, useSourceRunAttachments, attachments, exampleIds, datasetId, datasetName, } = propsOrUploads;\n        if (inputs === undefined) {\n            throw new Error(\"Must provide inputs when using legacy parameters\");\n        }\n        let datasetId_ = datasetId;\n        const datasetName_ = datasetName;\n        if (datasetId_ === undefined && datasetName_ === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName: datasetName_ });\n            datasetId_ = dataset.id;\n        }\n        const formattedExamples = inputs.map((input, idx) => {\n            return {\n                dataset_id: datasetId_,\n                inputs: input,\n                outputs: outputs?.[idx],\n                metadata: metadata?.[idx],\n                split: splits?.[idx],\n                id: exampleIds?.[idx],\n                attachments: attachments?.[idx],\n                source_run_id: sourceRunIds?.[idx],\n                use_source_run_io: useSourceRunIOs?.[idx],\n                use_source_run_attachments: useSourceRunAttachments?.[idx],\n            };\n        });\n        const response = await this._uploadExamplesMultipart(datasetId_, formattedExamples);\n        const examples = await Promise.all(response.example_ids.map((id) => this.readExample(id)));\n        return examples;\n    }\n    async createLLMExample(input, generation, options) {\n        return this.createExample({ input }, { output: generation }, options);\n    }\n    async createChatExample(input, generations, options) {\n        const finalInput = input.map((message) => {\n            if (isLangChainMessage(message)) {\n                return convertLangChainMessageToExample(message);\n            }\n            return message;\n        });\n        const finalOutput = isLangChainMessage(generations)\n            ? convertLangChainMessageToExample(generations)\n            : generations;\n        return this.createExample({ input: finalInput }, { output: finalOutput }, options);\n    }\n    async readExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        const rawExample = await this._get(path);\n        const { attachment_urls, ...rest } = rawExample;\n        const example = rest;\n        if (attachment_urls) {\n            example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {\n                acc[key.slice(\"attachment.\".length)] = {\n                    presigned_url: value.presigned_url,\n                    mime_type: value.mime_type,\n                };\n                return acc;\n            }, {});\n        }\n        return example;\n    }\n    async *listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, limit, offset, filter, includeAttachments, } = {}) {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId !== undefined) {\n            datasetId_ = datasetId;\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({ dataset: datasetId_ });\n        const dataset_version = asOf\n            ? typeof asOf === \"string\"\n                ? asOf\n                : asOf?.toISOString()\n            : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const inlineS3Urls_ = inlineS3Urls ?? true;\n        params.append(\"inline_s3_urls\", inlineS3Urls_.toString());\n        if (exampleIds !== undefined) {\n            for (const id_ of exampleIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        if (splits !== undefined) {\n            for (const split of splits) {\n                params.append(\"splits\", split);\n            }\n        }\n        if (metadata !== undefined) {\n            const serializedMetadata = JSON.stringify(metadata);\n            params.append(\"metadata\", serializedMetadata);\n        }\n        if (limit !== undefined) {\n            params.append(\"limit\", limit.toString());\n        }\n        if (offset !== undefined) {\n            params.append(\"offset\", offset.toString());\n        }\n        if (filter !== undefined) {\n            params.append(\"filter\", filter);\n        }\n        if (includeAttachments === true) {\n            [\"attachment_urls\", \"outputs\", \"metadata\"].forEach((field) => params.append(\"select\", field));\n        }\n        let i = 0;\n        for await (const rawExamples of this._getPaginated(\"/examples\", params)) {\n            for (const rawExample of rawExamples) {\n                const { attachment_urls, ...rest } = rawExample;\n                const example = rest;\n                if (attachment_urls) {\n                    example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {\n                        acc[key.slice(\"attachment.\".length)] = {\n                            presigned_url: value.presigned_url,\n                            mime_type: value.mime_type || undefined,\n                        };\n                        return acc;\n                    }, {});\n                }\n                yield example;\n                i++;\n            }\n            if (limit !== undefined && i >= limit) {\n                break;\n            }\n        }\n    }\n    async deleteExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        await this.caller.call(async () => {\n            const res = await this._fetch(this.apiUrl + path, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, `delete ${path}`, true);\n            return res;\n        });\n    }\n    async updateExample(exampleIdOrUpdate, update) {\n        let exampleId;\n        if (update) {\n            exampleId = exampleIdOrUpdate;\n        }\n        else {\n            exampleId = exampleIdOrUpdate.id;\n        }\n        assertUuid(exampleId);\n        let updateToUse;\n        if (update) {\n            updateToUse = { id: exampleId, ...update };\n        }\n        else {\n            updateToUse = exampleIdOrUpdate;\n        }\n        let datasetId;\n        if (updateToUse.dataset_id !== undefined) {\n            datasetId = updateToUse.dataset_id;\n        }\n        else {\n            const example = await this.readExample(exampleId);\n            datasetId = example.dataset_id;\n        }\n        return this._updateExamplesMultipart(datasetId, [updateToUse]);\n    }\n    async updateExamples(update) {\n        // We will naively get dataset id from first example and assume it works for all\n        let datasetId;\n        if (update[0].dataset_id === undefined) {\n            const example = await this.readExample(update[0].id);\n            datasetId = example.dataset_id;\n        }\n        else {\n            datasetId = update[0].dataset_id;\n        }\n        return this._updateExamplesMultipart(datasetId, update);\n    }\n    /**\n     * Get dataset version by closest date or exact tag.\n     *\n     * Use this to resolve the nearest version to a given timestamp or for a given tag.\n     *\n     * @param options The options for getting the dataset version\n     * @param options.datasetId The ID of the dataset\n     * @param options.datasetName The name of the dataset\n     * @param options.asOf The timestamp of the dataset to retrieve\n     * @param options.tag The tag of the dataset to retrieve\n     * @returns The dataset version\n     */\n    async readDatasetVersion({ datasetId, datasetName, asOf, tag, }) {\n        let resolvedDatasetId;\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            resolvedDatasetId = dataset.id;\n        }\n        else {\n            resolvedDatasetId = datasetId;\n        }\n        assertUuid(resolvedDatasetId);\n        if ((asOf && tag) || (!asOf && !tag)) {\n            throw new Error(\"Exactly one of asOf and tag must be specified.\");\n        }\n        const params = new URLSearchParams();\n        if (asOf !== undefined) {\n            params.append(\"as_of\", typeof asOf === \"string\" ? asOf : asOf.toISOString());\n        }\n        if (tag !== undefined) {\n            params.append(\"tag\", tag);\n        }\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${resolvedDatasetId}/version?${params.toString()}`, {\n                method: \"GET\",\n                headers: { ...this.headers },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"read dataset version\");\n            return res;\n        });\n        return await response.json();\n    }\n    async listDatasetSplits({ datasetId, datasetName, asOf, }) {\n        let datasetId_;\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide dataset name or ID\");\n        }\n        else if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            datasetId_ = datasetId;\n        }\n        assertUuid(datasetId_);\n        const params = new URLSearchParams();\n        const dataset_version = asOf\n            ? typeof asOf === \"string\"\n                ? asOf\n                : asOf?.toISOString()\n            : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const response = await this._get(`/datasets/${datasetId_}/splits`, params);\n        return response;\n    }\n    async updateDatasetSplits({ datasetId, datasetName, splitName, exampleIds, remove = false, }) {\n        let datasetId_;\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide dataset name or ID\");\n        }\n        else if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            datasetId_ = datasetId;\n        }\n        assertUuid(datasetId_);\n        const data = {\n            split_name: splitName,\n            examples: exampleIds.map((id) => {\n                assertUuid(id);\n                return id;\n            }),\n            remove,\n        };\n        const body = JSON.stringify(data);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId_}/splits`, {\n                method: \"PUT\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"update dataset splits\", true);\n            return res;\n        });\n    }\n    /**\n     * @deprecated This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.\n     */\n    async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample, } = { loadChildRuns: false }) {\n        warnOnce(\"This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.\");\n        let run_;\n        if (typeof run === \"string\") {\n            run_ = await this.readRun(run, { loadChildRuns });\n        }\n        else if (typeof run === \"object\" && \"id\" in run) {\n            run_ = run;\n        }\n        else {\n            throw new Error(`Invalid run type: ${typeof run}`);\n        }\n        if (run_.reference_example_id !== null &&\n            run_.reference_example_id !== undefined) {\n            referenceExample = await this.readExample(run_.reference_example_id);\n        }\n        const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n        const [_, feedbacks] = await this._logEvaluationFeedback(feedbackResult, run_, sourceInfo);\n        return feedbacks[0];\n    }\n    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"api\", sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId, }) {\n        if (!runId && !projectId) {\n            throw new Error(\"One of runId or projectId must be provided\");\n        }\n        if (runId && projectId) {\n            throw new Error(\"Only one of runId or projectId can be provided\");\n        }\n        const feedback_source = {\n            type: feedbackSourceType ?? \"api\",\n            metadata: sourceInfo ?? {},\n        };\n        if (sourceRunId !== undefined &&\n            feedback_source?.metadata !== undefined &&\n            !feedback_source.metadata[\"__run\"]) {\n            feedback_source.metadata[\"__run\"] = { run_id: sourceRunId };\n        }\n        if (feedback_source?.metadata !== undefined &&\n            feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n            assertUuid(feedback_source.metadata[\"__run\"].run_id);\n        }\n        const feedback = {\n            id: feedbackId ?? uuid.v4(),\n            run_id: runId,\n            key,\n            score: _formatFeedbackScore(score),\n            value,\n            correction,\n            comment,\n            feedback_source: feedback_source,\n            comparative_experiment_id: comparativeExperimentId,\n            feedbackConfig,\n            session_id: projectId,\n        };\n        const body = JSON.stringify(feedback);\n        const url = `${this.apiUrl}/feedback`;\n        await this.caller.call(async () => {\n            const res = await this._fetch(url, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"create feedback\", true);\n            return res;\n        });\n        return feedback;\n    }\n    async updateFeedback(feedbackId, { score, value, correction, comment, }) {\n        const feedbackUpdate = {};\n        if (score !== undefined && score !== null) {\n            feedbackUpdate[\"score\"] = _formatFeedbackScore(score);\n        }\n        if (value !== undefined && value !== null) {\n            feedbackUpdate[\"value\"] = value;\n        }\n        if (correction !== undefined && correction !== null) {\n            feedbackUpdate[\"correction\"] = correction;\n        }\n        if (comment !== undefined && comment !== null) {\n            feedbackUpdate[\"comment\"] = comment;\n        }\n        assertUuid(feedbackId);\n        const body = JSON.stringify(feedbackUpdate);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/feedback/${feedbackId}`, {\n                method: \"PATCH\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"update feedback\", true);\n            return res;\n        });\n    }\n    async readFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this._get(path);\n        return response;\n    }\n    async deleteFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        await this.caller.call(async () => {\n            const res = await this._fetch(this.apiUrl + path, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, `delete ${path}`, true);\n            return res;\n        });\n    }\n    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes, } = {}) {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n            for (const runId of runIds) {\n                assertUuid(runId);\n                queryParams.append(\"run\", runId);\n            }\n        }\n        if (feedbackKeys) {\n            for (const key of feedbackKeys) {\n                queryParams.append(\"key\", key);\n            }\n        }\n        if (feedbackSourceTypes) {\n            for (const type of feedbackSourceTypes) {\n                queryParams.append(\"source\", type);\n            }\n        }\n        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)) {\n            yield* feedbacks;\n        }\n    }\n    /**\n     * Creates a presigned feedback token and URL.\n     *\n     * The token can be used to authorize feedback metrics without\n     * needing an API key. This is useful for giving browser-based\n     * applications the ability to submit feedback without needing\n     * to expose an API key.\n     *\n     * @param runId The ID of the run.\n     * @param feedbackKey The feedback key.\n     * @param options Additional options for the token.\n     * @param options.expiration The expiration time for the token.\n     *\n     * @returns A promise that resolves to a FeedbackIngestToken.\n     */\n    async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig, } = {}) {\n        const body = {\n            run_id: runId,\n            feedback_key: feedbackKey,\n            feedback_config: feedbackConfig,\n        };\n        if (expiration) {\n            if (typeof expiration === \"string\") {\n                body[\"expires_at\"] = expiration;\n            }\n            else if (expiration?.hours || expiration?.minutes || expiration?.days) {\n                body[\"expires_in\"] = expiration;\n            }\n        }\n        else {\n            body[\"expires_in\"] = {\n                hours: 3,\n            };\n        }\n        const serializedBody = JSON.stringify(body);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/feedback/tokens`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody,\n            });\n            await raiseForStatus(res, \"create presigned feedback token\");\n            return res;\n        });\n        return await response.json();\n    }\n    async createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id, }) {\n        if (experimentIds.length === 0) {\n            throw new Error(\"At least one experiment is required\");\n        }\n        if (!referenceDatasetId) {\n            referenceDatasetId = (await this.readProject({\n                projectId: experimentIds[0],\n            })).reference_dataset_id;\n        }\n        if (!referenceDatasetId == null) {\n            throw new Error(\"A reference dataset is required\");\n        }\n        const body = {\n            id,\n            name,\n            experiment_ids: experimentIds,\n            reference_dataset_id: referenceDatasetId,\n            description,\n            created_at: (createdAt ?? new Date())?.toISOString(),\n            extra: {},\n        };\n        if (metadata)\n            body.extra[\"metadata\"] = metadata;\n        const serializedBody = JSON.stringify(body);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/comparative`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody,\n            });\n            await raiseForStatus(res, \"create comparative experiment\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Retrieves a list of presigned feedback tokens for a given run ID.\n     * @param runId The ID of the run.\n     * @returns An async iterable of FeedbackIngestToken objects.\n     */\n    async *listPresignedFeedbackTokens(runId) {\n        assertUuid(runId);\n        const params = new URLSearchParams({ run_id: runId });\n        for await (const tokens of this._getPaginated(\"/feedback/tokens\", params)) {\n            yield* tokens;\n        }\n    }\n    _selectEvalResults(results) {\n        let results_;\n        if (\"results\" in results) {\n            results_ = results.results;\n        }\n        else if (Array.isArray(results)) {\n            results_ = results;\n        }\n        else {\n            results_ = [results];\n        }\n        return results_;\n    }\n    async _logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n        const evalResults = this._selectEvalResults(evaluatorResponse);\n        const feedbacks = [];\n        for (const res of evalResults) {\n            let sourceInfo_ = sourceInfo || {};\n            if (res.evaluatorInfo) {\n                sourceInfo_ = { ...res.evaluatorInfo, ...sourceInfo_ };\n            }\n            let runId_ = null;\n            if (res.targetRunId) {\n                runId_ = res.targetRunId;\n            }\n            else if (run) {\n                runId_ = run.id;\n            }\n            feedbacks.push(await this.createFeedback(runId_, res.key, {\n                score: res.score,\n                value: res.value,\n                comment: res.comment,\n                correction: res.correction,\n                sourceInfo: sourceInfo_,\n                sourceRunId: res.sourceRunId,\n                feedbackConfig: res.feedbackConfig,\n                feedbackSourceType: \"model\",\n            }));\n        }\n        return [evalResults, feedbacks];\n    }\n    async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n        const [results] = await this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);\n        return results;\n    }\n    /**\n     * API for managing annotation queues\n     */\n    /**\n     * List the annotation queues on the LangSmith API.\n     * @param options - The options for listing annotation queues\n     * @param options.queueIds - The IDs of the queues to filter by\n     * @param options.name - The name of the queue to filter by\n     * @param options.nameContains - The substring that the queue name should contain\n     * @param options.limit - The maximum number of queues to return\n     * @returns An iterator of AnnotationQueue objects\n     */\n    async *listAnnotationQueues(options = {}) {\n        const { queueIds, name, nameContains, limit } = options;\n        const params = new URLSearchParams();\n        if (queueIds) {\n            queueIds.forEach((id, i) => {\n                assertUuid(id, `queueIds[${i}]`);\n                params.append(\"ids\", id);\n            });\n        }\n        if (name)\n            params.append(\"name\", name);\n        if (nameContains)\n            params.append(\"name_contains\", nameContains);\n        params.append(\"limit\", (limit !== undefined ? Math.min(limit, 100) : 100).toString());\n        let count = 0;\n        for await (const queues of this._getPaginated(\"/annotation-queues\", params)) {\n            yield* queues;\n            count++;\n            if (limit !== undefined && count >= limit)\n                break;\n        }\n    }\n    /**\n     * Create an annotation queue on the LangSmith API.\n     * @param options - The options for creating an annotation queue\n     * @param options.name - The name of the annotation queue\n     * @param options.description - The description of the annotation queue\n     * @param options.queueId - The ID of the annotation queue\n     * @returns The created AnnotationQueue object\n     */\n    async createAnnotationQueue(options) {\n        const { name, description, queueId, rubricInstructions } = options;\n        const body = {\n            name,\n            description,\n            id: queueId || uuid.v4(),\n            rubric_instructions: rubricInstructions,\n        };\n        const serializedBody = JSON.stringify(Object.fromEntries(Object.entries(body).filter(([_, v]) => v !== undefined)));\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody,\n            });\n            await raiseForStatus(res, \"create annotation queue\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Read an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to read\n     * @returns The AnnotationQueueWithDetails object\n     */\n    async readAnnotationQueue(queueId) {\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"read annotation queue\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Update an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to update\n     * @param options - The options for updating the annotation queue\n     * @param options.name - The new name for the annotation queue\n     * @param options.description - The new description for the annotation queue\n     */\n    async updateAnnotationQueue(queueId, options) {\n        const { name, description, rubricInstructions } = options;\n        const body = JSON.stringify({\n            name,\n            description,\n            rubric_instructions: rubricInstructions,\n        });\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}`, {\n                method: \"PATCH\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"update annotation queue\", true);\n            return res;\n        });\n    }\n    /**\n     * Delete an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to delete\n     */\n    async deleteAnnotationQueue(queueId) {\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}`, {\n                method: \"DELETE\",\n                headers: { ...this.headers, Accept: \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"delete annotation queue\", true);\n            return res;\n        });\n    }\n    /**\n     * Add runs to an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue\n     * @param runIds - The IDs of the runs to be added to the annotation queue\n     */\n    async addRunsToAnnotationQueue(queueId, runIds) {\n        const body = JSON.stringify(runIds.map((id, i) => assertUuid(id, `runIds[${i}]`).toString()));\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}/runs`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"add runs to annotation queue\", true);\n            return res;\n        });\n    }\n    /**\n     * Get a run from an annotation queue at the specified index.\n     * @param queueId - The ID of the annotation queue\n     * @param index - The index of the run to retrieve\n     * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object\n     * @throws {Error} If the run is not found at the given index or for other API-related errors\n     */\n    async getRunFromAnnotationQueue(queueId, index) {\n        const baseUrl = `/annotation-queues/${assertUuid(queueId, \"queueId\")}/run`;\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}${baseUrl}/${index}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"get run from annotation queue\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Delete a run from an an annotation queue.\n     * @param queueId - The ID of the annotation queue to delete the run from\n     * @param queueRunId - The ID of the run to delete from the annotation queue\n     */\n    async deleteRunFromAnnotationQueue(queueId, queueRunId) {\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}/runs/${assertUuid(queueRunId, \"queueRunId\")}`, {\n                method: \"DELETE\",\n                headers: { ...this.headers, Accept: \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"delete run from annotation queue\", true);\n            return res;\n        });\n    }\n    /**\n     * Get the size of an annotation queue.\n     * @param queueId - The ID of the annotation queue\n     */\n    async getSizeFromAnnotationQueue(queueId) {\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}/size`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"get size from annotation queue\");\n            return res;\n        });\n        return response.json();\n    }\n    async _currentTenantIsOwner(owner) {\n        const settings = await this._getSettings();\n        return owner == \"-\" || settings.tenant_handle === owner;\n    }\n    async _ownerConflictError(action, owner) {\n        const settings = await this._getSettings();\n        return new Error(`Cannot ${action} for another tenant.\\n\n      Current tenant: ${settings.tenant_handle}\\n\n      Requested tenant: ${owner}`);\n    }\n    async _getLatestCommitHash(promptOwnerAndName) {\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/commits/${promptOwnerAndName}/?limit=${1}&offset=${0}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"get latest commit hash\");\n            return res;\n        });\n        const json = await response.json();\n        if (json.commits.length === 0) {\n            return undefined;\n        }\n        return json.commits[0].commit_hash;\n    }\n    async _likeOrUnlikePrompt(promptIdentifier, like) {\n        const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);\n        const body = JSON.stringify({ like: like });\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/likes/${owner}/${promptName}`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, `${like ? \"like\" : \"unlike\"} prompt`);\n            return res;\n        });\n        return response.json();\n    }\n    async _getPromptUrl(promptIdentifier) {\n        const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            if (commitHash !== \"latest\") {\n                return `${this.getHostUrl()}/hub/${owner}/${promptName}/${commitHash.substring(0, 8)}`;\n            }\n            else {\n                return `${this.getHostUrl()}/hub/${owner}/${promptName}`;\n            }\n        }\n        else {\n            const settings = await this._getSettings();\n            if (commitHash !== \"latest\") {\n                return `${this.getHostUrl()}/prompts/${promptName}/${commitHash.substring(0, 8)}?organizationId=${settings.id}`;\n            }\n            else {\n                return `${this.getHostUrl()}/prompts/${promptName}?organizationId=${settings.id}`;\n            }\n        }\n    }\n    async promptExists(promptIdentifier) {\n        const prompt = await this.getPrompt(promptIdentifier);\n        return !!prompt;\n    }\n    async likePrompt(promptIdentifier) {\n        return this._likeOrUnlikePrompt(promptIdentifier, true);\n    }\n    async unlikePrompt(promptIdentifier) {\n        return this._likeOrUnlikePrompt(promptIdentifier, false);\n    }\n    async *listCommits(promptOwnerAndName) {\n        for await (const commits of this._getPaginated(`/commits/${promptOwnerAndName}/`, new URLSearchParams(), (res) => res.commits)) {\n            yield* commits;\n        }\n    }\n    async *listPrompts(options) {\n        const params = new URLSearchParams();\n        params.append(\"sort_field\", options?.sortField ?? \"updated_at\");\n        params.append(\"sort_direction\", \"desc\");\n        params.append(\"is_archived\", (!!options?.isArchived).toString());\n        if (options?.isPublic !== undefined) {\n            params.append(\"is_public\", options.isPublic.toString());\n        }\n        if (options?.query) {\n            params.append(\"query\", options.query);\n        }\n        for await (const prompts of this._getPaginated(\"/repos\", params, (res) => res.repos)) {\n            yield* prompts;\n        }\n    }\n    async getPrompt(promptIdentifier) {\n        const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            if (res?.status === 404) {\n                return null;\n            }\n            await raiseForStatus(res, \"get prompt\");\n            return res;\n        });\n        const result = await response?.json();\n        if (result?.repo) {\n            return result.repo;\n        }\n        else {\n            return null;\n        }\n    }\n    async createPrompt(promptIdentifier, options) {\n        const settings = await this._getSettings();\n        if (options?.isPublic && !settings.tenant_handle) {\n            throw new Error(`Cannot create a public prompt without first\\n\n        creating a LangChain Hub handle.\n        You can add a handle by creating a public prompt at:\\n\n        https://smith.langchain.com/prompts`);\n        }\n        const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            throw await this._ownerConflictError(\"create a prompt\", owner);\n        }\n        const data = {\n            repo_handle: promptName,\n            ...(options?.description && { description: options.description }),\n            ...(options?.readme && { readme: options.readme }),\n            ...(options?.tags && { tags: options.tags }),\n            is_public: !!options?.isPublic,\n        };\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/repos/`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"create prompt\");\n            return res;\n        });\n        const { repo } = await response.json();\n        return repo;\n    }\n    async createCommit(promptIdentifier, object, options) {\n        if (!(await this.promptExists(promptIdentifier))) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);\n        const resolvedParentCommitHash = options?.parentCommitHash === \"latest\" || !options?.parentCommitHash\n            ? await this._getLatestCommitHash(`${owner}/${promptName}`)\n            : options?.parentCommitHash;\n        const payload = {\n            manifest: JSON.parse(JSON.stringify(object)),\n            parent_commit: resolvedParentCommitHash,\n        };\n        const body = JSON.stringify(payload);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/commits/${owner}/${promptName}`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"create commit\");\n            return res;\n        });\n        const result = await response.json();\n        return this._getPromptUrl(`${owner}/${promptName}${result.commit_hash ? `:${result.commit_hash}` : \"\"}`);\n    }\n    /**\n     * Update examples with attachments using multipart form data.\n     * @param updates List of ExampleUpdateWithAttachments objects to upsert\n     * @returns Promise with the update response\n     */\n    async updateExamplesMultipart(datasetId, updates = []) {\n        return this._updateExamplesMultipart(datasetId, updates);\n    }\n    async _updateExamplesMultipart(datasetId, updates = []) {\n        if (!(await this._getDatasetExamplesMultiPartSupport())) {\n            throw new Error(\"Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.\");\n        }\n        const formData = new FormData();\n        for (const example of updates) {\n            const exampleId = example.id;\n            // Prepare the main example body\n            const exampleBody = {\n                ...(example.metadata && { metadata: example.metadata }),\n                ...(example.split && { split: example.split }),\n            };\n            // Add main example data\n            const stringifiedExample = serializePayloadForTracing(exampleBody, `Serializing body for example with id: ${exampleId}`);\n            const exampleBlob = new Blob([stringifiedExample], {\n                type: \"application/json\",\n            });\n            formData.append(exampleId, exampleBlob);\n            // Add inputs if present\n            if (example.inputs) {\n                const stringifiedInputs = serializePayloadForTracing(example.inputs, `Serializing inputs for example with id: ${exampleId}`);\n                const inputsBlob = new Blob([stringifiedInputs], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.inputs`, inputsBlob);\n            }\n            // Add outputs if present\n            if (example.outputs) {\n                const stringifiedOutputs = serializePayloadForTracing(example.outputs, `Serializing outputs whle updating example with id: ${exampleId}`);\n                const outputsBlob = new Blob([stringifiedOutputs], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.outputs`, outputsBlob);\n            }\n            // Add attachments if present\n            if (example.attachments) {\n                for (const [name, attachment] of Object.entries(example.attachments)) {\n                    let mimeType;\n                    let data;\n                    if (Array.isArray(attachment)) {\n                        [mimeType, data] = attachment;\n                    }\n                    else {\n                        mimeType = attachment.mimeType;\n                        data = attachment.data;\n                    }\n                    const attachmentBlob = new Blob([data], {\n                        type: `${mimeType}; length=${data.byteLength}`,\n                    });\n                    formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);\n                }\n            }\n            if (example.attachments_operations) {\n                const stringifiedAttachmentsOperations = serializePayloadForTracing(example.attachments_operations, `Serializing attachments while updating example with id: ${exampleId}`);\n                const attachmentsOperationsBlob = new Blob([stringifiedAttachmentsOperations], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.attachments_operations`, attachmentsOperationsBlob);\n            }\n        }\n        const datasetIdToUse = datasetId ?? updates[0]?.dataset_id;\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetIdToUse}/examples`)}`, {\n                method: \"PATCH\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: formData,\n            });\n            await raiseForStatus(res, \"update examples\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Upload examples with attachments using multipart form data.\n     * @param uploads List of ExampleUploadWithAttachments objects to upload\n     * @returns Promise with the upload response\n     * @deprecated This method is deprecated and will be removed in future LangSmith versions, please use `createExamples` instead\n     */\n    async uploadExamplesMultipart(datasetId, uploads = []) {\n        return this._uploadExamplesMultipart(datasetId, uploads);\n    }\n    async _uploadExamplesMultipart(datasetId, uploads = []) {\n        if (!(await this._getDatasetExamplesMultiPartSupport())) {\n            throw new Error(\"Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.\");\n        }\n        const formData = new FormData();\n        for (const example of uploads) {\n            const exampleId = (example.id ?? uuid.v4()).toString();\n            // Prepare the main example body\n            const exampleBody = {\n                created_at: example.created_at,\n                ...(example.metadata && { metadata: example.metadata }),\n                ...(example.split && { split: example.split }),\n                ...(example.source_run_id && { source_run_id: example.source_run_id }),\n                ...(example.use_source_run_io && {\n                    use_source_run_io: example.use_source_run_io,\n                }),\n                ...(example.use_source_run_attachments && {\n                    use_source_run_attachments: example.use_source_run_attachments,\n                }),\n            };\n            // Add main example data\n            const stringifiedExample = serializePayloadForTracing(exampleBody, `Serializing body for uploaded example with id: ${exampleId}`);\n            const exampleBlob = new Blob([stringifiedExample], {\n                type: \"application/json\",\n            });\n            formData.append(exampleId, exampleBlob);\n            // Add inputs if present\n            if (example.inputs) {\n                const stringifiedInputs = serializePayloadForTracing(example.inputs, `Serializing inputs for uploaded example with id: ${exampleId}`);\n                const inputsBlob = new Blob([stringifiedInputs], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.inputs`, inputsBlob);\n            }\n            // Add outputs if present\n            if (example.outputs) {\n                const stringifiedOutputs = serializePayloadForTracing(example.outputs, `Serializing outputs for uploaded example with id: ${exampleId}`);\n                const outputsBlob = new Blob([stringifiedOutputs], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.outputs`, outputsBlob);\n            }\n            // Add attachments if present\n            if (example.attachments) {\n                for (const [name, attachment] of Object.entries(example.attachments)) {\n                    let mimeType;\n                    let data;\n                    if (Array.isArray(attachment)) {\n                        [mimeType, data] = attachment;\n                    }\n                    else {\n                        mimeType = attachment.mimeType;\n                        data = attachment.data;\n                    }\n                    const attachmentBlob = new Blob([data], {\n                        type: `${mimeType}; length=${data.byteLength}`,\n                    });\n                    formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);\n                }\n            }\n        }\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetId}/examples`)}`, {\n                method: \"POST\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: formData,\n            });\n            await raiseForStatus(res, \"upload examples\");\n            return res;\n        });\n        return response.json();\n    }\n    async updatePrompt(promptIdentifier, options) {\n        if (!(await this.promptExists(promptIdentifier))) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName] = parsePromptIdentifier(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            throw await this._ownerConflictError(\"update a prompt\", owner);\n        }\n        const payload = {};\n        if (options?.description !== undefined)\n            payload.description = options.description;\n        if (options?.readme !== undefined)\n            payload.readme = options.readme;\n        if (options?.tags !== undefined)\n            payload.tags = options.tags;\n        if (options?.isPublic !== undefined)\n            payload.is_public = options.isPublic;\n        if (options?.isArchived !== undefined)\n            payload.is_archived = options.isArchived;\n        // Check if payload is empty\n        if (Object.keys(payload).length === 0) {\n            throw new Error(\"No valid update options provided\");\n        }\n        const body = JSON.stringify(payload);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {\n                method: \"PATCH\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\",\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"update prompt\");\n            return res;\n        });\n        return response.json();\n    }\n    async deletePrompt(promptIdentifier) {\n        if (!(await this.promptExists(promptIdentifier))) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            throw await this._ownerConflictError(\"delete a prompt\", owner);\n        }\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"delete prompt\");\n            return res;\n        });\n        return response.json();\n    }\n    async pullPromptCommit(promptIdentifier, options) {\n        const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/commits/${owner}/${promptName}/${commitHash}${options?.includeModel ? \"?include_model=true\" : \"\"}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"pull prompt commit\");\n            return res;\n        });\n        const result = await response.json();\n        return {\n            owner,\n            repo: promptName,\n            commit_hash: result.commit_hash,\n            manifest: result.manifest,\n            examples: result.examples,\n        };\n    }\n    /**\n     * This method should not be used directly, use `import { pull } from \"langchain/hub\"` instead.\n     * Using this method directly returns the JSON string of the prompt rather than a LangChain object.\n     * @private\n     */\n    async _pullPrompt(promptIdentifier, options) {\n        const promptObject = await this.pullPromptCommit(promptIdentifier, {\n            includeModel: options?.includeModel,\n        });\n        const prompt = JSON.stringify(promptObject.manifest);\n        return prompt;\n    }\n    async pushPrompt(promptIdentifier, options) {\n        // Create or update prompt metadata\n        if (await this.promptExists(promptIdentifier)) {\n            if (options && Object.keys(options).some((key) => key !== \"object\")) {\n                await this.updatePrompt(promptIdentifier, {\n                    description: options?.description,\n                    readme: options?.readme,\n                    tags: options?.tags,\n                    isPublic: options?.isPublic,\n                });\n            }\n        }\n        else {\n            await this.createPrompt(promptIdentifier, {\n                description: options?.description,\n                readme: options?.readme,\n                tags: options?.tags,\n                isPublic: options?.isPublic,\n            });\n        }\n        if (!options?.object) {\n            return await this._getPromptUrl(promptIdentifier);\n        }\n        // Create a commit with the new manifest\n        const url = await this.createCommit(promptIdentifier, options?.object, {\n            parentCommitHash: options?.parentCommitHash,\n        });\n        return url;\n    }\n    /**\n     * Clone a public dataset to your own langsmith tenant.\n     * This operation is idempotent. If you already have a dataset with the given name,\n     * this function will do nothing.\n  \n     * @param {string} tokenOrUrl The token of the public dataset to clone.\n     * @param {Object} [options] Additional options for cloning the dataset.\n     * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.\n     * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.\n     * @returns {Promise<void>}\n     */\n    async clonePublicDataset(tokenOrUrl, options = {}) {\n        const { sourceApiUrl = this.apiUrl, datasetName } = options;\n        const [parsedApiUrl, tokenUuid] = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl);\n        const sourceClient = new Client({\n            apiUrl: parsedApiUrl,\n            // Placeholder API key not needed anymore in most cases, but\n            // some private deployments may have API key-based rate limiting\n            // that would cause this to fail if we provide no value.\n            apiKey: \"placeholder\",\n        });\n        const ds = await sourceClient.readSharedDataset(tokenUuid);\n        const finalDatasetName = datasetName || ds.name;\n        try {\n            if (await this.hasDataset({ datasetId: finalDatasetName })) {\n                console.log(`Dataset ${finalDatasetName} already exists in your tenant. Skipping.`);\n                return;\n            }\n        }\n        catch (_) {\n            // `.hasDataset` will throw an error if the dataset does not exist.\n            // no-op in that case\n        }\n        // Fetch examples first, then create the dataset\n        const examples = await sourceClient.listSharedExamples(tokenUuid);\n        const dataset = await this.createDataset(finalDatasetName, {\n            description: ds.description,\n            dataType: ds.data_type || \"kv\",\n            inputsSchema: ds.inputs_schema_definition ?? undefined,\n            outputsSchema: ds.outputs_schema_definition ?? undefined,\n        });\n        try {\n            await this.createExamples({\n                inputs: examples.map((e) => e.inputs),\n                outputs: examples.flatMap((e) => (e.outputs ? [e.outputs] : [])),\n                datasetId: dataset.id,\n            });\n        }\n        catch (e) {\n            console.error(`An error occurred while creating dataset ${finalDatasetName}. ` +\n                \"You should delete it manually.\");\n            throw e;\n        }\n    }\n    parseTokenOrUrl(urlOrToken, apiUrl, numParts = 2, kind = \"dataset\") {\n        // Try parsing as UUID\n        try {\n            assertUuid(urlOrToken); // Will throw if it's not a UUID.\n            return [apiUrl, urlOrToken];\n        }\n        catch (_) {\n            // no-op if it's not a uuid\n        }\n        // Parse as URL\n        try {\n            const parsedUrl = new URL(urlOrToken);\n            const pathParts = parsedUrl.pathname\n                .split(\"/\")\n                .filter((part) => part !== \"\");\n            if (pathParts.length >= numParts) {\n                const tokenUuid = pathParts[pathParts.length - numParts];\n                return [apiUrl, tokenUuid];\n            }\n            else {\n                throw new Error(`Invalid public ${kind} URL: ${urlOrToken}`);\n            }\n        }\n        catch (error) {\n            throw new Error(`Invalid public ${kind} URL or token: ${urlOrToken}`);\n        }\n    }\n    /**\n     * Awaits all pending trace batches. Useful for environments where\n     * you need to be sure that all tracing requests finish before execution ends,\n     * such as serverless environments.\n     *\n     * @example\n     * ```\n     * import { Client } from \"langsmith\";\n     *\n     * const client = new Client();\n     *\n     * try {\n     *   // Tracing happens here\n     *   ...\n     * } finally {\n     *   await client.awaitPendingTraceBatches();\n     * }\n     * ```\n     *\n     * @returns A promise that resolves once all currently pending traces have sent.\n     */\n    async awaitPendingTraceBatches() {\n        if (this.manualFlushMode) {\n            console.warn(\"[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches.\");\n            return Promise.resolve();\n        }\n        await Promise.all([\n            ...this.autoBatchQueue.items.map(({ itemPromise }) => itemPromise),\n            this.batchIngestCaller.queue.onIdle(),\n        ]);\n        if (this.langSmithToOTELTranslator !== undefined) {\n            await getDefaultOTLPTracerComponents()?.DEFAULT_LANGSMITH_SPAN_PROCESSOR?.forceFlush();\n        }\n    }\n}\nfunction isExampleCreate(input) {\n    return \"dataset_id\" in input || \"dataset_name\" in input;\n}\n"],"x_google_ignoreList":[0],"mappings":"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"}