{"version":3,"file":"hitl.d.ts","names":["z","ToolCall","InferInteropZodInput","AgentBuiltInState","Runtime","DescriptionFunctionSchema","Record","ZodTypeDef","ZodType","ZodUnknown","ZodTuple","ZodString","ZodPromise","ZodUnion","ZodFunction","DescriptionFactory","infer","DecisionType","ZodEnum","InterruptOnConfigSchema","ZodArray","ZodOptional","ZodAny","ZodRecord","ZodTypeAny","Promise","ZodObject","InterruptOnConfig","input","Action","ActionRequest","ReviewConfig","HITLRequest","ApproveDecision","EditDecision","RejectDecision","Decision","HITLResponse","contextSchema","ZodBoolean","ZodDefault","HumanInTheLoopMiddlewareConfig","humanInTheLoopMiddleware","NonNullable","__types_js1","AgentMiddleware"],"sources":["../../../src/agents/middleware/hitl.d.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { z } from \"zod/v3\";\nimport { ToolCall } from \"@langchain/core/messages\";\nimport { InferInteropZodInput } from \"@langchain/core/utils/types\";\nimport type { AgentBuiltInState, Runtime } from \"../runtime.js\";\ndeclare const DescriptionFunctionSchema: z.ZodFunction<z.ZodTuple<[z.ZodType<ToolCall<string, Record<string, any>>, z.ZodTypeDef, ToolCall<string, Record<string, any>>>, z.ZodType<AgentBuiltInState, z.ZodTypeDef, AgentBuiltInState>, z.ZodType<Runtime<unknown>, z.ZodTypeDef, Runtime<unknown>>], z.ZodUnknown>, z.ZodUnion<[z.ZodString, z.ZodPromise<z.ZodString>]>>;\n/**\n * Function type that dynamically generates a description for a tool call approval request.\n *\n * @param toolCall - The tool call being reviewed\n * @param state - The current agent state\n * @param runtime - The agent runtime context\n * @returns A string description or Promise that resolves to a string description\n *\n * @example\n * ```typescript\n * import { type DescriptionFactory, type ToolCall } from \"langchain\";\n *\n * const descriptionFactory: DescriptionFactory = (toolCall, state, runtime) => {\n *   return `Please review: ${toolCall.name}(${JSON.stringify(toolCall.args)})`;\n * };\n * ```\n */\nexport type DescriptionFactory = z.infer<typeof DescriptionFunctionSchema>;\ndeclare const DecisionType: z.ZodEnum<[\"approve\", \"edit\", \"reject\"]>;\nexport type DecisionType = z.infer<typeof DecisionType>;\ndeclare const InterruptOnConfigSchema: z.ZodObject<{\n    /**\n     * The decisions that are allowed for this action.\n     */\n    allowedDecisions: z.ZodArray<z.ZodEnum<[\"approve\", \"edit\", \"reject\"]>, \"many\">;\n    /**\n     * The description attached to the request for human input.\n     * Can be either:\n     * - A static string describing the approval request\n     * - A callable that dynamically generates the description based on agent state,\n     *   runtime, and tool call information\n     *\n     * @example\n     * Static string description\n     * ```typescript\n     * import type { InterruptOnConfig } from \"langchain\";\n     *\n     * const config: InterruptOnConfig = {\n     *   allowedDecisions: [\"approve\", \"reject\"],\n     *   description: \"Please review this tool execution\"\n     * };\n     * ```\n     *\n     * @example\n     * Dynamic callable description\n     * ```typescript\n     * import type {\n     *   AgentBuiltInState,\n     *   Runtime,\n     *   DescriptionFactory,\n     *   ToolCall,\n     *   InterruptOnConfig\n     * } from \"langchain\";\n     *\n     * const formatToolDescription: DescriptionFactory = (\n     *   toolCall: ToolCall,\n     *   state: AgentBuiltInState,\n     *   runtime: Runtime<unknown>\n     * ) => {\n     *   return `Tool: ${toolCall.name}\\nArguments:\\n${JSON.stringify(toolCall.args, null, 2)}`;\n     * };\n     *\n     * const config: InterruptOnConfig = {\n     *   allowedDecisions: [\"approve\", \"edit\"],\n     *   description: formatToolDescription\n     * };\n     * ```\n     */\n    description: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodFunction<z.ZodTuple<[z.ZodType<ToolCall<string, Record<string, any>>, z.ZodTypeDef, ToolCall<string, Record<string, any>>>, z.ZodType<AgentBuiltInState, z.ZodTypeDef, AgentBuiltInState>, z.ZodType<Runtime<unknown>, z.ZodTypeDef, Runtime<unknown>>], z.ZodUnknown>, z.ZodUnion<[z.ZodString, z.ZodPromise<z.ZodString>]>>]>>;\n    /**\n     * JSON schema for the arguments associated with the action, if edits are allowed.\n     */\n    argsSchema: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;\n}, \"strip\", z.ZodTypeAny, {\n    allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n    description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n    argsSchema?: Record<string, any> | undefined;\n}, {\n    allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n    description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n    argsSchema?: Record<string, any> | undefined;\n}>;\nexport type InterruptOnConfig = z.input<typeof InterruptOnConfigSchema>;\n/**\n * Represents an action with a name and arguments.\n */\nexport interface Action {\n    /**\n     * The type or name of action being requested (e.g., \"add_numbers\").\n     */\n    name: string;\n    /**\n     * Key-value pairs of arguments needed for the action (e.g., {\"a\": 1, \"b\": 2}).\n     */\n    args: Record<string, any>;\n}\n/**\n * Represents an action request with a name, arguments, and description.\n */\nexport interface ActionRequest {\n    /**\n     * The name of the action being requested.\n     */\n    name: string;\n    /**\n     * Key-value pairs of arguments needed for the action (e.g., {\"a\": 1, \"b\": 2}).\n     */\n    args: Record<string, any>;\n    /**\n     * The description of the action to be reviewed.\n     */\n    description?: string;\n}\n/**\n * Policy for reviewing a HITL request.\n */\nexport interface ReviewConfig {\n    /**\n     * Name of the action associated with this review configuration.\n     */\n    actionName: string;\n    /**\n     * The decisions that are allowed for this request.\n     */\n    allowedDecisions: DecisionType[];\n    /**\n     * JSON schema for the arguments associated with the action, if edits are allowed.\n     */\n    argsSchema?: Record<string, any>;\n}\n/**\n * Request for human feedback on a sequence of actions requested by a model.\n *\n * @example\n * ```ts\n * const hitlRequest: HITLRequest = {\n *   actionRequests: [\n *     { name: \"send_email\", args: { to: \"user@example.com\", subject: \"Hello\" } }\n *   ],\n *   reviewConfigs: [\n *     {\n *       actionName: \"send_email\",\n *       allowedDecisions: [\"approve\", \"edit\", \"reject\"],\n *       description: \"Please review the email before sending\"\n *     }\n *   ]\n * };\n * const response = interrupt(hitlRequest);\n * ```\n */\nexport interface HITLRequest {\n    /**\n     * A list of agent actions for human review.\n     */\n    actionRequests: ActionRequest[];\n    /**\n     * Review configuration for all possible actions.\n     */\n    reviewConfigs: ReviewConfig[];\n}\n/**\n * Response when a human approves the action.\n */\nexport interface ApproveDecision {\n    type: \"approve\";\n}\n/**\n * Response when a human edits the action.\n */\nexport interface EditDecision {\n    type: \"edit\";\n    /**\n     * Edited action for the agent to perform.\n     * Ex: for a tool call, a human reviewer can edit the tool name and args.\n     */\n    editedAction: Action;\n}\n/**\n * Response when a human rejects the action.\n */\nexport interface RejectDecision {\n    type: \"reject\";\n    /**\n     * The message sent to the model explaining why the action was rejected.\n     */\n    message?: string;\n}\n/**\n * Union of all possible decision types.\n */\nexport type Decision = ApproveDecision | EditDecision | RejectDecision;\n/**\n * Response payload for a HITLRequest.\n */\nexport interface HITLResponse {\n    /**\n     * The decisions made by the human.\n     */\n    decisions: Decision[];\n}\ndeclare const contextSchema: z.ZodObject<{\n    /**\n     * Mapping of tool name to allowed reviewer responses.\n     * If a tool doesn't have an entry, it's auto-approved by default.\n     *\n     * - `true` -> pause for approval and allow approve/edit/reject decisions\n     * - `false` -> auto-approve (no human review)\n     * - `InterruptOnConfig` -> explicitly specify which decisions are allowed for this tool\n     */\n    interruptOn: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodBoolean, z.ZodObject<{\n        /**\n         * The decisions that are allowed for this action.\n         */\n        allowedDecisions: z.ZodArray<z.ZodEnum<[\"approve\", \"edit\", \"reject\"]>, \"many\">;\n        /**\n         * The description attached to the request for human input.\n         * Can be either:\n         * - A static string describing the approval request\n         * - A callable that dynamically generates the description based on agent state,\n         *   runtime, and tool call information\n         *\n         * @example\n         * Static string description\n         * ```typescript\n         * import type { InterruptOnConfig } from \"langchain\";\n         *\n         * const config: InterruptOnConfig = {\n         *   allowedDecisions: [\"approve\", \"reject\"],\n         *   description: \"Please review this tool execution\"\n         * };\n         * ```\n         *\n         * @example\n         * Dynamic callable description\n         * ```typescript\n         * import type {\n         *   AgentBuiltInState,\n         *   Runtime,\n         *   DescriptionFactory,\n         *   ToolCall,\n         *   InterruptOnConfig\n         * } from \"langchain\";\n         *\n         * const formatToolDescription: DescriptionFactory = (\n         *   toolCall: ToolCall,\n         *   state: AgentBuiltInState,\n         *   runtime: Runtime<unknown>\n         * ) => {\n         *   return `Tool: ${toolCall.name}\\nArguments:\\n${JSON.stringify(toolCall.args, null, 2)}`;\n         * };\n         *\n         * const config: InterruptOnConfig = {\n         *   allowedDecisions: [\"approve\", \"edit\"],\n         *   description: formatToolDescription\n         * };\n         * ```\n         */\n        description: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodFunction<z.ZodTuple<[z.ZodType<ToolCall<string, Record<string, any>>, z.ZodTypeDef, ToolCall<string, Record<string, any>>>, z.ZodType<AgentBuiltInState, z.ZodTypeDef, AgentBuiltInState>, z.ZodType<Runtime<unknown>, z.ZodTypeDef, Runtime<unknown>>], z.ZodUnknown>, z.ZodUnion<[z.ZodString, z.ZodPromise<z.ZodString>]>>]>>;\n        /**\n         * JSON schema for the arguments associated with the action, if edits are allowed.\n         */\n        argsSchema: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;\n    }, \"strip\", z.ZodTypeAny, {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }, {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }>]>>>;\n    /**\n     * Prefix used when constructing human-facing approval messages.\n     * Provides context about the tool call being reviewed; does not change the underlying action.\n     *\n     * Note: This prefix is only applied for tools that do not provide a custom\n     * `description` via their {@link InterruptOnConfig}. If a tool specifies a custom\n     * `description`, that per-tool text is used and this prefix is ignored.\n     */\n    descriptionPrefix: z.ZodDefault<z.ZodString>;\n}, \"strip\", z.ZodTypeAny, {\n    interruptOn?: Record<string, boolean | {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }> | undefined;\n    descriptionPrefix: string;\n}, {\n    interruptOn?: Record<string, boolean | {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }> | undefined;\n    descriptionPrefix?: string | undefined;\n}>;\nexport type HumanInTheLoopMiddlewareConfig = InferInteropZodInput<typeof contextSchema>;\n/**\n * Creates a Human-in-the-Loop (HITL) middleware for tool approval and oversight.\n *\n * This middleware intercepts tool calls made by an AI agent and provides human oversight\n * capabilities before execution. It enables selective approval workflows where certain tools\n * require human intervention while others can execute automatically.\n *\n * A invocation result that has been interrupted by the middleware will have a `__interrupt__`\n * property that contains the interrupt request.\n *\n * ```ts\n * import { type HITLRequest, type HITLResponse } from \"langchain\";\n * import { type Interrupt } from \"langchain\";\n *\n * const result = await agent.invoke(request);\n * const interruptRequest = result.__interrupt__?.[0] as Interrupt<HITLRequest>;\n *\n * // Examine the action requests and review configs\n * const actionRequests = interruptRequest.value.actionRequests;\n * const reviewConfigs = interruptRequest.value.reviewConfigs;\n *\n * // Create decisions for each action\n * const resume: HITLResponse = {\n *   decisions: actionRequests.map((action, i) => {\n *     if (action.name === \"calculator\") {\n *       return { type: \"approve\" };\n *     } else if (action.name === \"write_file\") {\n *       return {\n *         type: \"edit\",\n *         editedAction: { name: \"write_file\", args: { filename: \"safe.txt\", content: \"Safe content\" } }\n *       };\n *     }\n *     return { type: \"reject\", message: \"Action not allowed\" };\n *   })\n * };\n *\n * // Resume with decisions\n * await agent.invoke(new Command({ resume }), config);\n * ```\n *\n * ## Features\n *\n * - **Selective Tool Approval**: Configure which tools require human approval\n * - **Multiple Decision Types**: Approve, edit, or reject tool calls\n * - **Asynchronous Workflow**: Uses LangGraph's interrupt mechanism for non-blocking approval\n * - **Custom Approval Messages**: Provide context-specific descriptions for approval requests\n *\n * ## Decision Types\n *\n * When a tool requires approval, the human operator can respond with:\n * - `approve`: Execute the tool with original arguments\n * - `edit`: Modify the tool name and/or arguments before execution\n * - `reject`: Provide a manual response instead of executing the tool\n *\n * @param options - Configuration options for the middleware\n * @param options.interruptOn - Per-tool configuration mapping tool names to their settings\n * @param options.interruptOn[toolName].allowedDecisions - Array of decision types allowed for this tool (e.g., [\"approve\", \"edit\", \"reject\"])\n * @param options.interruptOn[toolName].description - Custom approval message for the tool. Can be either a static string or a callable that dynamically generates the description based on agent state, runtime, and tool call information\n * @param options.interruptOn[toolName].argsSchema - JSON schema for the arguments associated with the action, if edits are allowed\n * @param options.descriptionPrefix - Default prefix for approval messages (default: \"Tool execution requires approval\"). Only used for tools that do not define a custom `description` in their InterruptOnConfig.\n *\n * @returns A middleware instance that can be passed to `createAgent`\n *\n * @example\n * Basic usage with selective tool approval\n * ```typescript\n * import { humanInTheLoopMiddleware } from \"langchain\";\n * import { createAgent } from \"langchain\";\n *\n * const hitlMiddleware = humanInTheLoopMiddleware({\n *   interruptOn: {\n *     // Interrupt write_file tool and allow edits or approvals\n *     \"write_file\": {\n *       allowedDecisions: [\"approve\", \"edit\"],\n *       description: \"⚠️ File write operation requires approval\"\n *     },\n *     // Auto-approve read_file tool\n *     \"read_file\": false\n *   }\n * });\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4\",\n *   tools: [writeFileTool, readFileTool],\n *   middleware: [hitlMiddleware]\n * });\n * ```\n *\n * @example\n * Handling approval requests\n * ```typescript\n * import { type HITLRequest, type HITLResponse, type Interrupt } from \"langchain\";\n * import { Command } from \"@langchain/langgraph\";\n *\n * // Initial agent invocation\n * const result = await agent.invoke({\n *   messages: [new HumanMessage(\"Write 'Hello' to output.txt\")]\n * }, config);\n *\n * // Check if agent is paused for approval\n * if (result.__interrupt__) {\n *   const interruptRequest = result.__interrupt__?.[0] as Interrupt<HITLRequest>;\n *\n *   // Show tool call details to user\n *   console.log(\"Actions:\", interruptRequest.value.actionRequests);\n *   console.log(\"Review configs:\", interruptRequest.value.reviewConfigs);\n *\n *   // Resume with approval\n *   const resume: HITLResponse = {\n *     decisions: [{ type: \"approve\" }]\n *   };\n *   await agent.invoke(\n *     new Command({ resume }),\n *     config\n *   );\n * }\n * ```\n *\n * @example\n * Different decision types\n * ```typescript\n * import { type HITLResponse } from \"langchain\";\n *\n * // Approve the tool call as-is\n * const resume: HITLResponse = {\n *   decisions: [{ type: \"approve\" }]\n * };\n *\n * // Edit the tool arguments\n * const resume: HITLResponse = {\n *   decisions: [{\n *     type: \"edit\",\n *     editedAction: { name: \"write_file\", args: { filename: \"safe.txt\", content: \"Modified\" } }\n *   }]\n * };\n *\n * // Reject with feedback\n * const resume: HITLResponse = {\n *   decisions: [{\n *     type: \"reject\",\n *     message: \"File operation not allowed in demo mode\"\n *   }]\n * };\n * ```\n *\n * @example\n * Production use case with database operations\n * ```typescript\n * const hitlMiddleware = humanInTheLoopMiddleware({\n *   interruptOn: {\n *     \"execute_sql\": {\n *       allowedDecisions: [\"approve\", \"edit\", \"reject\"],\n *       description: \"🚨 SQL query requires DBA approval\\nPlease review for safety and performance\"\n *     },\n *     \"read_schema\": false,  // Reading metadata is safe\n *     \"delete_records\": {\n *       allowedDecisions: [\"approve\", \"reject\"],\n *       description: \"⛔ DESTRUCTIVE OPERATION - Requires manager approval\"\n *     }\n *   },\n *   descriptionPrefix: \"Database operation pending approval\"\n * });\n * ```\n *\n * @example\n * Using dynamic callable descriptions\n * ```typescript\n * import { type DescriptionFactory, type ToolCall } from \"langchain\";\n * import type { AgentBuiltInState, Runtime } from \"langchain/agents\";\n *\n * // Define a dynamic description factory\n * const formatToolDescription: DescriptionFactory = (\n *   toolCall: ToolCall,\n *   state: AgentBuiltInState,\n *   runtime: Runtime<unknown>\n * ) => {\n *   return `Tool: ${toolCall.name}\\nArguments:\\n${JSON.stringify(toolCall.args, null, 2)}`;\n * };\n *\n * const hitlMiddleware = humanInTheLoopMiddleware({\n *   interruptOn: {\n *     \"write_file\": {\n *       allowedDecisions: [\"approve\", \"edit\"],\n *       // Use dynamic description that can access tool call, state, and runtime\n *       description: formatToolDescription\n *     },\n *     // Or use an inline function\n *     \"send_email\": {\n *       allowedDecisions: [\"approve\", \"reject\"],\n *       description: (toolCall, state, runtime) => {\n *         const { to, subject } = toolCall.args;\n *         return `Email to ${to}\\nSubject: ${subject}\\n\\nRequires approval before sending`;\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @remarks\n * - Tool calls are processed in the order they appear in the AI message\n * - Auto-approved tools execute immediately without interruption\n * - Multiple tools requiring approval are bundled into a single interrupt request\n * - The middleware operates in the `afterModel` phase, intercepting before tool execution\n * - Requires a checkpointer to maintain state across interruptions\n *\n * @see {@link createAgent} for agent creation\n * @see {@link Command} for resuming interrupted execution\n * @public\n */\nexport declare function humanInTheLoopMiddleware(options: NonNullable<HumanInTheLoopMiddlewareConfig>): import(\"./types.js\").AgentMiddleware<undefined, z.ZodObject<{\n    /**\n     * Mapping of tool name to allowed reviewer responses.\n     * If a tool doesn't have an entry, it's auto-approved by default.\n     *\n     * - `true` -> pause for approval and allow approve/edit/reject decisions\n     * - `false` -> auto-approve (no human review)\n     * - `InterruptOnConfig` -> explicitly specify which decisions are allowed for this tool\n     */\n    interruptOn: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodBoolean, z.ZodObject<{\n        /**\n         * The decisions that are allowed for this action.\n         */\n        allowedDecisions: z.ZodArray<z.ZodEnum<[\"approve\", \"edit\", \"reject\"]>, \"many\">;\n        /**\n         * The description attached to the request for human input.\n         * Can be either:\n         * - A static string describing the approval request\n         * - A callable that dynamically generates the description based on agent state,\n         *   runtime, and tool call information\n         *\n         * @example\n         * Static string description\n         * ```typescript\n         * import type { InterruptOnConfig } from \"langchain\";\n         *\n         * const config: InterruptOnConfig = {\n         *   allowedDecisions: [\"approve\", \"reject\"],\n         *   description: \"Please review this tool execution\"\n         * };\n         * ```\n         *\n         * @example\n         * Dynamic callable description\n         * ```typescript\n         * import type {\n         *   AgentBuiltInState,\n         *   Runtime,\n         *   DescriptionFactory,\n         *   ToolCall,\n         *   InterruptOnConfig\n         * } from \"langchain\";\n         *\n         * const formatToolDescription: DescriptionFactory = (\n         *   toolCall: ToolCall,\n         *   state: AgentBuiltInState,\n         *   runtime: Runtime<unknown>\n         * ) => {\n         *   return `Tool: ${toolCall.name}\\nArguments:\\n${JSON.stringify(toolCall.args, null, 2)}`;\n         * };\n         *\n         * const config: InterruptOnConfig = {\n         *   allowedDecisions: [\"approve\", \"edit\"],\n         *   description: formatToolDescription\n         * };\n         * ```\n         */\n        description: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodFunction<z.ZodTuple<[z.ZodType<ToolCall<string, Record<string, any>>, z.ZodTypeDef, ToolCall<string, Record<string, any>>>, z.ZodType<AgentBuiltInState, z.ZodTypeDef, AgentBuiltInState>, z.ZodType<Runtime<unknown>, z.ZodTypeDef, Runtime<unknown>>], z.ZodUnknown>, z.ZodUnion<[z.ZodString, z.ZodPromise<z.ZodString>]>>]>>;\n        /**\n         * JSON schema for the arguments associated with the action, if edits are allowed.\n         */\n        argsSchema: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;\n    }, \"strip\", z.ZodTypeAny, {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }, {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }>]>>>;\n    /**\n     * Prefix used when constructing human-facing approval messages.\n     * Provides context about the tool call being reviewed; does not change the underlying action.\n     *\n     * Note: This prefix is only applied for tools that do not provide a custom\n     * `description` via their {@link InterruptOnConfig}. If a tool specifies a custom\n     * `description`, that per-tool text is used and this prefix is ignored.\n     */\n    descriptionPrefix: z.ZodDefault<z.ZodString>;\n}, \"strip\", z.ZodTypeAny, {\n    interruptOn?: Record<string, boolean | {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }> | undefined;\n    descriptionPrefix: string;\n}, {\n    interruptOn?: Record<string, boolean | {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }> | undefined;\n    descriptionPrefix?: string | undefined;\n}>, any>;\nexport {};\n"],"mappings":"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"}