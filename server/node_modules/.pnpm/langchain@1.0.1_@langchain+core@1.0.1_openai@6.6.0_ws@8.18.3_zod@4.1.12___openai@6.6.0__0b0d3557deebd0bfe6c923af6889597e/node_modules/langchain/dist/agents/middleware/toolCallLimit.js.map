{"version":3,"file":"toolCallLimit.js","names":["messages: BaseMessage[]","toolName?: string","threadCount: number","runCount: number","threadLimit: number | undefined","runLimit: number | undefined","toolName: string | undefined","exceededLimits: string[]","options: ToolCallLimitConfig"],"sources":["../../../src/agents/middleware/toolCallLimit.ts"],"sourcesContent":["/**\n * Tool call limit middleware for agents.\n */\n\nimport { AIMessage, BaseMessage, HumanMessage } from \"@langchain/core/messages\";\nimport { z } from \"zod/v3\";\nimport type { InferInteropZodInput } from \"@langchain/core/utils/types\";\n\nimport { createMiddleware } from \"../middleware.js\";\n\n/**\n * Count tool calls in a list of messages.\n *\n * @param messages - List of messages to count tool calls in.\n * @param toolName - If specified, only count calls to this specific tool.\n *   If undefined, count all tool calls.\n * @returns The total number of tool calls (optionally filtered by toolName).\n */\nfunction countToolCallsInMessages(\n  messages: BaseMessage[],\n  toolName?: string\n): number {\n  let count = 0;\n  for (const message of messages) {\n    if (AIMessage.isInstance(message) && message.tool_calls) {\n      if (toolName === undefined) {\n        // Count all tool calls\n        count += message.tool_calls.length;\n      } else {\n        // Count only calls to the specified tool\n        count += message.tool_calls.filter((tc) => tc.name === toolName).length;\n      }\n    }\n  }\n  return count;\n}\n\n/**\n * Get messages from the current run (after the last HumanMessage).\n *\n * @param messages - Full list of messages.\n * @returns Messages from the current run (after last HumanMessage).\n */\nfunction getRunMessages(messages: BaseMessage[]): BaseMessage[] {\n  /**\n   * Find the last HumanMessage\n   */\n  let lastHumanIndex = -1;\n  for (let i = messages.length - 1; i >= 0; i--) {\n    if (HumanMessage.isInstance(messages[i])) {\n      lastHumanIndex = i;\n      break;\n    }\n  }\n\n  /**\n   * If no HumanMessage found, return all messages\n   */\n  if (lastHumanIndex === -1) {\n    return messages;\n  }\n\n  /**\n   * Return messages after the last HumanMessage\n   */\n  return messages.slice(lastHumanIndex + 1);\n}\n\n/**\n * Build a message indicating which tool call limits were reached.\n *\n * @param threadCount - Current thread tool call count.\n * @param runCount - Current run tool call count.\n * @param threadLimit - Thread tool call limit (if set).\n * @param runLimit - Run tool call limit (if set).\n * @param toolName - Tool name being limited (if specific tool), or undefined for all tools.\n * @returns A formatted message describing which limits were reached.\n */\nfunction buildToolLimitExceededMessage(\n  threadCount: number,\n  runCount: number,\n  threadLimit: number | undefined,\n  runLimit: number | undefined,\n  toolName: string | undefined\n): string {\n  const toolDesc = toolName ? `'${toolName}' tool call` : \"Tool call\";\n  const exceededLimits: string[] = [];\n\n  if (threadLimit !== undefined && threadCount >= threadLimit) {\n    exceededLimits.push(`thread limit reached (${threadCount}/${threadLimit})`);\n  }\n  if (runLimit !== undefined && runCount >= runLimit) {\n    exceededLimits.push(`run limit reached (${runCount}/${runLimit})`);\n  }\n\n  return `${toolDesc} limit${\n    exceededLimits.length > 1 ? \"s\" : \"\"\n  }: ${exceededLimits.join(\", \")}. Stopping to prevent further tool calls.`;\n}\n\n/**\n * Exception raised when tool call limits are exceeded.\n *\n * This exception is raised when the configured exit behavior is 'error'\n * and either the thread or run tool call limit has been exceeded.\n */\nexport class ToolCallLimitExceededError extends Error {\n  /**\n   * Current thread tool call count.\n   */\n  threadCount: number;\n  /**\n   * Current run tool call count.\n   */\n  runCount: number;\n  /**\n   * Thread tool call limit (if set).\n   */\n  threadLimit: number | undefined;\n  /**\n   * Run tool call limit (if set).\n   */\n  runLimit: number | undefined;\n  /**\n   * Tool name being limited (if specific tool), or undefined for all tools.\n   */\n  toolName: string | undefined;\n\n  constructor(\n    threadCount: number,\n    runCount: number,\n    threadLimit: number | undefined,\n    runLimit: number | undefined,\n    toolName: string | undefined = undefined\n  ) {\n    const message = buildToolLimitExceededMessage(\n      threadCount,\n      runCount,\n      threadLimit,\n      runLimit,\n      toolName\n    );\n    super(message);\n\n    this.name = \"ToolCallLimitExceededError\";\n    this.threadCount = threadCount;\n    this.runCount = runCount;\n    this.threadLimit = threadLimit;\n    this.runLimit = runLimit;\n    this.toolName = toolName;\n  }\n}\n\n/**\n * Options for configuring the Tool Call Limit middleware.\n */\nexport const ToolCallLimitOptionsSchema = z.object({\n  /**\n   * Name of the specific tool to limit. If undefined, limits apply to all tools.\n   */\n  toolName: z.string().optional(),\n  /**\n   * Maximum number of tool calls allowed per thread.\n   * undefined means no limit.\n   */\n  threadLimit: z.number().optional(),\n  /**\n   * Maximum number of tool calls allowed per run.\n   * undefined means no limit.\n   */\n  runLimit: z.number().optional(),\n  /**\n   * What to do when limits are exceeded.\n   * - \"end\": Jump to the end of the agent execution and inject an artificial\n   *   AI message indicating that the limit was exceeded.\n   * - \"error\": throws a ToolCallLimitExceededError\n   */\n  exitBehavior: z.enum([\"end\", \"error\"]).default(\"end\"),\n});\n\nexport type ToolCallLimitConfig = InferInteropZodInput<\n  typeof ToolCallLimitOptionsSchema\n>;\n\n/**\n * Middleware that tracks tool call counts and enforces limits.\n *\n * This middleware monitors the number of tool calls made during agent execution\n * and can terminate the agent when specified limits are reached. It supports\n * both thread-level and run-level call counting with configurable exit behaviors.\n *\n * Thread-level: The middleware counts all tool calls in the entire message history\n * and persists this count across multiple runs (invocations) of the agent.\n *\n * Run-level: The middleware counts tool calls made after the last HumanMessage,\n * representing the current run (invocation) of the agent.\n *\n * @param options - Configuration options for the middleware\n * @param options.toolName - Name of the specific tool to limit. If undefined, limits apply to all tools.\n * @param options.threadLimit - Maximum number of tool calls allowed per thread. undefined means no limit.\n * @param options.runLimit - Maximum number of tool calls allowed per run. undefined means no limit.\n * @param options.exitBehavior - What to do when limits are exceeded.\n *   - \"end\": Jump to the end of the agent execution and inject an artificial AI message indicating that the limit was exceeded.\n *   - \"error\": throws a ToolCallLimitExceededError\n *\n * @throws {Error} If both limits are undefined or if exitBehavior is invalid.\n *\n * @example Limit all tool calls globally\n * ```ts\n * import { toolCallLimitMiddleware } from \"@langchain/langchain/agents/middleware\";\n * import { createAgent } from \"@langchain/langchain/agents\";\n *\n * const globalLimiter = toolCallLimitMiddleware({\n *   threadLimit: 20,\n *   runLimit: 10,\n *   exitBehavior: \"end\"\n * });\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4o\",\n *   middleware: [globalLimiter]\n * });\n * ```\n *\n * @example Limit a specific tool\n * ```ts\n * import { toolCallLimitMiddleware } from \"@langchain/langchain/agents/middleware\";\n * import { createAgent } from \"@langchain/langchain/agents\";\n *\n * const searchLimiter = toolCallLimitMiddleware({\n *   toolName: \"search\",\n *   threadLimit: 5,\n *   runLimit: 3,\n *   exitBehavior: \"end\"\n * });\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4o\",\n *   middleware: [searchLimiter]\n * });\n * ```\n *\n * @example Use both in the same agent\n * ```ts\n * import { toolCallLimitMiddleware } from \"@langchain/langchain/agents/middleware\";\n * import { createAgent } from \"@langchain/langchain/agents\";\n *\n * const globalLimiter = toolCallLimitMiddleware({\n *   threadLimit: 20,\n *   runLimit: 10,\n *   exitBehavior: \"end\"\n * });\n *\n * const searchLimiter = toolCallLimitMiddleware({\n *   toolName: \"search\",\n *   threadLimit: 5,\n *   runLimit: 3,\n *   exitBehavior: \"end\"\n * });\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4o\",\n *   middleware: [globalLimiter, searchLimiter]\n * });\n * ```\n */\nexport function toolCallLimitMiddleware(options: ToolCallLimitConfig) {\n  /**\n   * Validate that at least one limit is specified\n   */\n  if (options.threadLimit === undefined && options.runLimit === undefined) {\n    throw new Error(\n      \"At least one limit must be specified (threadLimit or runLimit)\"\n    );\n  }\n\n  /**\n   * Apply default for exitBehavior and validate\n   */\n  const exitBehavior = options.exitBehavior ?? \"end\";\n  if (exitBehavior !== \"end\" && exitBehavior !== \"error\") {\n    throw new Error(\n      `Invalid exit behavior: ${exitBehavior}. Must be 'end' or 'error'`\n    );\n  }\n\n  /**\n   * Generate the middleware name based on the tool name\n   */\n  const middlewareName = options.toolName\n    ? `ToolCallLimitMiddleware[${options.toolName}]`\n    : \"ToolCallLimitMiddleware\";\n\n  return createMiddleware({\n    name: middlewareName,\n    beforeModel: {\n      canJumpTo: [\"end\"],\n      hook: (state) => {\n        const messages = state.messages;\n\n        /**\n         * Count tool calls in entire thread\n         */\n        const threadCount = countToolCallsInMessages(\n          messages,\n          options.toolName\n        );\n\n        /**\n         * Count tool calls in current run (after last HumanMessage)\n         */\n        const runMessages = getRunMessages(messages);\n        const runCount = countToolCallsInMessages(\n          runMessages,\n          options.toolName\n        );\n\n        /**\n         * Check if any limits are exceeded\n         */\n        const threadLimitExceeded =\n          options.threadLimit !== undefined &&\n          threadCount >= options.threadLimit;\n        const runLimitExceeded =\n          options.runLimit !== undefined && runCount >= options.runLimit;\n\n        if (!threadLimitExceeded && !runLimitExceeded) {\n          return undefined;\n        }\n\n        if (exitBehavior === \"error\") {\n          throw new ToolCallLimitExceededError(\n            threadCount,\n            runCount,\n            options.threadLimit,\n            options.runLimit,\n            options.toolName\n          );\n        }\n\n        /**\n         * Create a message indicating the limit was exceeded\n         */\n        const limitMessage = buildToolLimitExceededMessage(\n          threadCount,\n          runCount,\n          options.threadLimit,\n          options.runLimit,\n          options.toolName\n        );\n        const limitAiMessage = new AIMessage(limitMessage);\n\n        return {\n          jumpTo: \"end\",\n          messages: [limitAiMessage],\n        };\n      },\n    },\n  });\n}\n"],"mappings":"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"}