{"version":3,"file":"middleware.js","names":["config: {\n  /**\n   * The name of the middleware\n   */\n  name: string;\n  /**\n   * The schema of the middleware state. Middleware state is persisted between multiple invocations. It can be either:\n   * - A Zod object\n   * - A Zod optional object\n   * - A Zod default object\n   * - Undefined\n   */\n  stateSchema?: TSchema;\n  /**\n   * The schema of the middleware context. Middleware context is read-only and not persisted between multiple invocations. It can be either:\n   * - A Zod object\n   * - A Zod optional object\n   * - A Zod default object\n   * - Undefined\n   */\n  contextSchema?: TContextSchema;\n  /**\n   * Additional tools registered by the middleware.\n   */\n  tools?: (ClientTool | ServerTool)[];\n  /**\n   * Wraps tool execution with custom logic. This allows you to:\n   * - Modify tool call parameters before execution\n   * - Handle errors and retry with different parameters\n   * - Post-process tool results\n   * - Implement caching, logging, authentication, or other cross-cutting concerns\n   * - Return Command objects for advanced control flow\n   *\n   * The handler receives a ToolCallRequest containing the tool call, state, and runtime,\n   * along with a handler function to execute the actual tool.\n   *\n   * @param request - The tool call request containing toolCall, state, and runtime.\n   * @param handler - The function that executes the tool. Call this with a ToolCallRequest to get the result.\n   * @returns The tool result as a ToolMessage or a Command for advanced control flow.\n   *\n   * @example\n   * ```ts\n   * wrapToolCall: async (request, handler) => {\n   *   console.log(`Calling tool: ${request.tool.name}`);\n   *   console.log(`Tool description: ${request.tool.description}`);\n   *\n   *   try {\n   *     // Execute the tool\n   *     const result = await handler(request);\n   *     console.log(`Tool ${request.tool.name} succeeded`);\n   *     return result;\n   *   } catch (error) {\n   *     console.error(`Tool ${request.tool.name} failed:`, error);\n   *     // Could return a custom error message or retry\n   *     throw error;\n   *   }\n   * }\n   * ```\n   *\n   * @example Authentication\n   * ```ts\n   * wrapToolCall: async (request, handler) => {\n   *   // Check if user is authorized for this tool\n   *   if (!request.runtime.context.isAuthorized(request.tool.name)) {\n   *     return new ToolMessage({\n   *       content: \"Unauthorized to call this tool\",\n   *       tool_call_id: request.toolCall.id,\n   *     });\n   *   }\n   *   return handler(request);\n   * }\n   * ```\n   */\n  wrapToolCall?: WrapToolCallHook<\n    TSchema,\n    NormalizeContextSchema<TContextSchema>\n  >;\n\n  /**\n   * Wraps the model invocation with custom logic. This allows you to:\n   * - Modify the request before calling the model\n   * - Handle errors and retry with different parameters\n   * - Post-process the response\n   * - Implement custom caching, logging, or other cross-cutting concerns\n   *\n   * The request parameter contains: model, messages, systemPrompt, tools, state, and runtime.\n   *\n   * @param request - The model request containing all the parameters needed.\n   * @param handler - The function that invokes the model. Call this with a ModelRequest to get the response.\n   * @returns The response from the model (or a modified version).\n   *\n   * @example\n   * ```ts\n   * wrapModelCall: async (request, handler) => {\n   *   // Modify request before calling\n   *   const modifiedRequest = { ...request, systemPrompt: \"You are helpful\" };\n   *\n   *   try {\n   *     // Call the model\n   *     return await handler(modifiedRequest);\n   *   } catch (error) {\n   *     // Handle errors and retry with fallback\n   *     const fallbackRequest = { ...request, model: fallbackModel };\n   *     return await handler(fallbackRequest);\n   *   }\n   * }\n   * ```\n   */\n  wrapModelCall?: WrapModelCallHook<\n    TSchema,\n    NormalizeContextSchema<TContextSchema>\n  >;\n  /**\n   * The function to run before the agent execution starts. This function is called once at the start of the agent invocation.\n   * It allows to modify the state of the agent before any model calls or tool executions.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  beforeAgent?: BeforeAgentHook<\n    TSchema,\n    NormalizeContextSchema<TContextSchema>\n  >;\n\n  /**\n   * The function to run before the model call. This function is called before the model is invoked and before the `wrapModelCall` hook.\n   * It allows to modify the state of the agent.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  beforeModel?: BeforeModelHook<\n    TSchema,\n    NormalizeContextSchema<TContextSchema>\n  >;\n\n  /**\n   * The function to run after the model call. This function is called after the model is invoked and before any tools are called.\n   * It allows to modify the state of the agent after the model is invoked, e.g. to update tool call parameters.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  afterModel?: AfterModelHook<TSchema, NormalizeContextSchema<TContextSchema>>;\n\n  /**\n   * The function to run after the agent execution completes. This function is called once at the end of the agent invocation.\n   * It allows to modify the final state of the agent after all model calls and tool executions are complete.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  afterAgent?: AfterAgentHook<TSchema, NormalizeContextSchema<TContextSchema>>;\n}","middleware: AgentMiddleware<TSchema, TContextSchema, any>"],"sources":["../../src/agents/middleware.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {\n  InteropZodObject,\n  InteropZodDefault,\n  InteropZodOptional,\n  InferInteropZodOutput,\n} from \"@langchain/core/utils/types\";\n\nimport type { ClientTool, ServerTool } from \"./tools.js\";\nimport type {\n  AgentMiddleware,\n  WrapToolCallHook,\n  WrapModelCallHook,\n  BeforeAgentHook,\n  BeforeModelHook,\n  AfterModelHook,\n  AfterAgentHook,\n} from \"./middleware/types.js\";\n\n/**\n * Creates a middleware instance with automatic schema inference.\n *\n * @param config - Middleware configuration\n * @param config.name - The name of the middleware\n * @param config.stateSchema - The schema of the middleware state\n * @param config.contextSchema - The schema of the middleware context\n * @param config.wrapModelCall - The function to wrap model invocation\n * @param config.wrapToolCall - The function to wrap tool invocation\n * @param config.beforeModel - The function to run before the model call\n * @param config.afterModel - The function to run after the model call\n * @param config.beforeAgent - The function to run before the agent execution starts\n * @param config.afterAgent - The function to run after the agent execution completes\n * @returns A middleware instance\n *\n * @example\n * ```ts\n * const authMiddleware = createMiddleware({\n *   name: \"AuthMiddleware\",\n *   stateSchema: z.object({\n *     isAuthenticated: z.boolean().default(false),\n *   }),\n *   contextSchema: z.object({\n *     userId: z.string(),\n *   }),\n *   beforeModel: async (state, runtime, controls) => {\n *     if (!state.isAuthenticated) {\n *       return controls.terminate(new Error(\"Not authenticated\"));\n *     }\n *   },\n * });\n * ```\n */\nexport function createMiddleware<\n  TSchema extends InteropZodObject | undefined = undefined,\n  TContextSchema extends\n    | InteropZodObject\n    | InteropZodOptional<InteropZodObject>\n    | InteropZodDefault<InteropZodObject>\n    | undefined = undefined\n>(config: {\n  /**\n   * The name of the middleware\n   */\n  name: string;\n  /**\n   * The schema of the middleware state. Middleware state is persisted between multiple invocations. It can be either:\n   * - A Zod object\n   * - A Zod optional object\n   * - A Zod default object\n   * - Undefined\n   */\n  stateSchema?: TSchema;\n  /**\n   * The schema of the middleware context. Middleware context is read-only and not persisted between multiple invocations. It can be either:\n   * - A Zod object\n   * - A Zod optional object\n   * - A Zod default object\n   * - Undefined\n   */\n  contextSchema?: TContextSchema;\n  /**\n   * Additional tools registered by the middleware.\n   */\n  tools?: (ClientTool | ServerTool)[];\n  /**\n   * Wraps tool execution with custom logic. This allows you to:\n   * - Modify tool call parameters before execution\n   * - Handle errors and retry with different parameters\n   * - Post-process tool results\n   * - Implement caching, logging, authentication, or other cross-cutting concerns\n   * - Return Command objects for advanced control flow\n   *\n   * The handler receives a ToolCallRequest containing the tool call, state, and runtime,\n   * along with a handler function to execute the actual tool.\n   *\n   * @param request - The tool call request containing toolCall, state, and runtime.\n   * @param handler - The function that executes the tool. Call this with a ToolCallRequest to get the result.\n   * @returns The tool result as a ToolMessage or a Command for advanced control flow.\n   *\n   * @example\n   * ```ts\n   * wrapToolCall: async (request, handler) => {\n   *   console.log(`Calling tool: ${request.tool.name}`);\n   *   console.log(`Tool description: ${request.tool.description}`);\n   *\n   *   try {\n   *     // Execute the tool\n   *     const result = await handler(request);\n   *     console.log(`Tool ${request.tool.name} succeeded`);\n   *     return result;\n   *   } catch (error) {\n   *     console.error(`Tool ${request.tool.name} failed:`, error);\n   *     // Could return a custom error message or retry\n   *     throw error;\n   *   }\n   * }\n   * ```\n   *\n   * @example Authentication\n   * ```ts\n   * wrapToolCall: async (request, handler) => {\n   *   // Check if user is authorized for this tool\n   *   if (!request.runtime.context.isAuthorized(request.tool.name)) {\n   *     return new ToolMessage({\n   *       content: \"Unauthorized to call this tool\",\n   *       tool_call_id: request.toolCall.id,\n   *     });\n   *   }\n   *   return handler(request);\n   * }\n   * ```\n   */\n  wrapToolCall?: WrapToolCallHook<\n    TSchema,\n    NormalizeContextSchema<TContextSchema>\n  >;\n\n  /**\n   * Wraps the model invocation with custom logic. This allows you to:\n   * - Modify the request before calling the model\n   * - Handle errors and retry with different parameters\n   * - Post-process the response\n   * - Implement custom caching, logging, or other cross-cutting concerns\n   *\n   * The request parameter contains: model, messages, systemPrompt, tools, state, and runtime.\n   *\n   * @param request - The model request containing all the parameters needed.\n   * @param handler - The function that invokes the model. Call this with a ModelRequest to get the response.\n   * @returns The response from the model (or a modified version).\n   *\n   * @example\n   * ```ts\n   * wrapModelCall: async (request, handler) => {\n   *   // Modify request before calling\n   *   const modifiedRequest = { ...request, systemPrompt: \"You are helpful\" };\n   *\n   *   try {\n   *     // Call the model\n   *     return await handler(modifiedRequest);\n   *   } catch (error) {\n   *     // Handle errors and retry with fallback\n   *     const fallbackRequest = { ...request, model: fallbackModel };\n   *     return await handler(fallbackRequest);\n   *   }\n   * }\n   * ```\n   */\n  wrapModelCall?: WrapModelCallHook<\n    TSchema,\n    NormalizeContextSchema<TContextSchema>\n  >;\n  /**\n   * The function to run before the agent execution starts. This function is called once at the start of the agent invocation.\n   * It allows to modify the state of the agent before any model calls or tool executions.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  beforeAgent?: BeforeAgentHook<\n    TSchema,\n    NormalizeContextSchema<TContextSchema>\n  >;\n\n  /**\n   * The function to run before the model call. This function is called before the model is invoked and before the `wrapModelCall` hook.\n   * It allows to modify the state of the agent.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  beforeModel?: BeforeModelHook<\n    TSchema,\n    NormalizeContextSchema<TContextSchema>\n  >;\n\n  /**\n   * The function to run after the model call. This function is called after the model is invoked and before any tools are called.\n   * It allows to modify the state of the agent after the model is invoked, e.g. to update tool call parameters.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  afterModel?: AfterModelHook<TSchema, NormalizeContextSchema<TContextSchema>>;\n\n  /**\n   * The function to run after the agent execution completes. This function is called once at the end of the agent invocation.\n   * It allows to modify the final state of the agent after all model calls and tool executions are complete.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  afterAgent?: AfterAgentHook<TSchema, NormalizeContextSchema<TContextSchema>>;\n}): AgentMiddleware<TSchema, TContextSchema, any> {\n  const middleware: AgentMiddleware<TSchema, TContextSchema, any> = {\n    name: config.name,\n    stateSchema: config.stateSchema,\n    contextSchema: config.contextSchema,\n    wrapToolCall: config.wrapToolCall,\n    wrapModelCall: config.wrapModelCall,\n    beforeAgent: config.beforeAgent,\n    beforeModel: config.beforeModel,\n    afterModel: config.afterModel,\n    afterAgent: config.afterAgent,\n    tools: config.tools ?? [],\n  };\n\n  return middleware;\n}\n\ntype NormalizeContextSchema<\n  TContextSchema extends\n    | InteropZodObject\n    | InteropZodOptional<InteropZodObject>\n    | InteropZodDefault<InteropZodObject>\n    | undefined = undefined\n> = TContextSchema extends InteropZodObject\n  ? InferInteropZodOutput<TContextSchema>\n  : TContextSchema extends InteropZodDefault<any>\n  ? InferInteropZodOutput<TContextSchema>\n  : TContextSchema extends InteropZodOptional<any>\n  ? Partial<InferInteropZodOutput<TContextSchema>>\n  : never;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoDA,SAAgB,iBAOdA,QA6JgD;CAChD,MAAMC,aAA4D;EAChE,MAAM,OAAO;EACb,aAAa,OAAO;EACpB,eAAe,OAAO;EACtB,cAAc,OAAO;EACrB,eAAe,OAAO;EACtB,aAAa,OAAO;EACpB,aAAa,OAAO;EACpB,YAAY,OAAO;EACnB,YAAY,OAAO;EACnB,OAAO,OAAO,SAAS,CAAE;CAC1B;AAED,QAAO;AACR"}