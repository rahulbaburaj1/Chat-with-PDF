{"version":3,"file":"ReactAgent.js","names":["options: CreateAgentParams<\n      StructuredResponseFormat,\n      StateSchema,\n      ContextSchema\n    >","#toolBehaviorVersion","beforeAgentNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[]","beforeModelNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[]","afterModelNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[]","afterAgentNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[]","wrapModelCallHookMiddleware: [\n      AgentMiddleware,\n      /**\n       * ToDo: better type to get the state of middleware\n       */\n      () => any\n    ][]","#agentNode","beforeAgentNode: BeforeAgentNode | undefined","beforeModelNode: BeforeModelNode | undefined","afterModelNode: AfterModelNode | undefined","afterAgentNode: AfterAgentNode | undefined","entryNode: string","#createBeforeAgentRouter","#createBeforeModelRouter","#getModelPaths","#createModelRouter","#createAfterModelSequenceRouter","#createAfterModelRouter","#createToolsRouter","#graph","toolClasses: (ClientTool | ServerTool)[]","includeModelRequest: boolean","paths: (\"tools\" | \"model_request\" | typeof END)[]","shouldReturnDirect: Set<string>","exitNode: string | typeof END","state: any","state: BuiltInState","allowJump: boolean","state: Omit<BuiltInState, \"jumpTo\"> & { jumpTo?: JumpTo }","allowed: string[]","nextDefault: string","#initializeMiddlewareStates","state: InvokeStateParameter<StateSchema, TMiddleware>","#populatePrivateState","config?: RunnableConfig","config?: InvokeConfiguration<\n      InferContextInput<ContextSchema> &\n        InferMiddlewareContextInputs<TMiddleware>\n    >","config?: StreamConfiguration<\n      InferContextInput<ContextSchema> &\n        InferMiddlewareContextInputs<TMiddleware>\n    >","params?: {\n    withStyles?: boolean;\n    curveStyle?: string;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n    backgroundColor?: string;\n  }","config?: StreamConfiguration<\n      InferContextInput<ContextSchema> &\n        InferMiddlewareContextInputs<TMiddleware>\n    > & { version?: \"v1\" | \"v2\" }","streamOptions?: Parameters<Runnable[\"streamEvents\"]>[2]","config: RunnableConfig","options?: GetStateOptions","options?: CheckpointListOptions","namespace?: string","recurse?: boolean","inputConfig: LangGraphRunnableConfig","values: Record<string, unknown> | unknown","asNode?: string"],"sources":["../../src/agents/ReactAgent.ts"],"sourcesContent":["/* eslint-disable no-instanceof/no-instanceof */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { InteropZodObject } from \"@langchain/core/utils/types\";\n\nimport {\n  AnnotationRoot,\n  StateGraph,\n  END,\n  START,\n  Send,\n  Command,\n  CompiledStateGraph,\n  type GetStateOptions,\n  type LangGraphRunnableConfig,\n} from \"@langchain/langgraph\";\nimport type { CheckpointListOptions } from \"@langchain/langgraph-checkpoint\";\nimport { ToolMessage, AIMessage } from \"@langchain/core/messages\";\nimport { IterableReadableStream } from \"@langchain/core/utils/stream\";\nimport type { Runnable, RunnableConfig } from \"@langchain/core/runnables\";\nimport type { StreamEvent } from \"@langchain/core/tracers/log_stream\";\n\nimport { createAgentAnnotationConditional } from \"./annotation.js\";\nimport {\n  isClientTool,\n  validateLLMHasNoBoundTools,\n  wrapToolCall,\n} from \"./utils.js\";\n\nimport { AgentNode } from \"./nodes/AgentNode.js\";\nimport { ToolNode } from \"./nodes/ToolNode.js\";\nimport { BeforeAgentNode } from \"./nodes/BeforeAgentNode.js\";\nimport { BeforeModelNode } from \"./nodes/BeforeModelNode.js\";\nimport { AfterModelNode } from \"./nodes/AfterModelNode.js\";\nimport { AfterAgentNode } from \"./nodes/AfterAgentNode.js\";\nimport {\n  initializeMiddlewareStates,\n  parseJumpToTarget,\n} from \"./nodes/utils.js\";\n\nimport type { WithStateGraphNodes } from \"./types.js\";\nimport type { ClientTool, ServerTool } from \"./tools.js\";\n\nimport type {\n  CreateAgentParams,\n  BuiltInState,\n  JumpTo,\n  UserInput,\n} from \"./types.js\";\nimport type {\n  PrivateState,\n  InvokeConfiguration,\n  StreamConfiguration,\n} from \"./runtime.js\";\nimport type {\n  AgentMiddleware,\n  InferMiddlewareContextInputs,\n  InferMiddlewareStates,\n  InferMiddlewareInputStates,\n  InferContextInput,\n  AnyAnnotationRoot,\n  InferSchemaInput,\n  ToAnnotationRoot,\n} from \"./middleware/types.js\";\nimport { type ResponseFormatUndefined } from \"./responses.js\";\nimport { getHookConstraint } from \"./middleware/utils.js\";\n\n// Helper type to get the state definition with middleware states\ntype MergedAgentState<\n  StateSchema extends AnyAnnotationRoot | InteropZodObject | undefined,\n  StructuredResponseFormat extends\n    | Record<string, any>\n    | ResponseFormatUndefined,\n  TMiddleware extends readonly AgentMiddleware[]\n> = InferSchemaInput<StateSchema> &\n  (StructuredResponseFormat extends ResponseFormatUndefined\n    ? Omit<BuiltInState, \"jumpTo\">\n    : Omit<BuiltInState, \"jumpTo\"> & {\n        structuredResponse: StructuredResponseFormat;\n      }) &\n  InferMiddlewareStates<TMiddleware>;\n\ntype InvokeStateParameter<\n  StateSchema extends AnyAnnotationRoot | InteropZodObject | undefined,\n  TMiddleware extends readonly AgentMiddleware[]\n> =\n  | (UserInput<StateSchema> & InferMiddlewareInputStates<TMiddleware>)\n  | Command<any, any, any>\n  | null;\n\ntype AgentGraph<\n  StateSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject\n    | undefined = undefined,\n  StructuredResponseFormat extends\n    | Record<string, any>\n    | ResponseFormatUndefined = Record<string, any>,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  TMiddleware extends readonly AgentMiddleware[] = []\n> = CompiledStateGraph<\n  any,\n  any,\n  any,\n  any,\n  MergedAgentState<StateSchema, StructuredResponseFormat, TMiddleware>,\n  ToAnnotationRoot<ContextSchema>[\"spec\"],\n  unknown\n>;\n\nexport class ReactAgent<\n  StructuredResponseFormat extends\n    | Record<string, any>\n    | ResponseFormatUndefined = Record<string, any>,\n  StateSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject\n    | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  TMiddleware extends readonly AgentMiddleware[] = readonly AgentMiddleware[]\n> {\n  #graph: AgentGraph<\n    StateSchema,\n    StructuredResponseFormat,\n    ContextSchema,\n    TMiddleware\n  >;\n\n  #toolBehaviorVersion: \"v1\" | \"v2\" = \"v2\";\n\n  #agentNode: AgentNode<any, AnyAnnotationRoot>;\n\n  constructor(\n    public options: CreateAgentParams<\n      StructuredResponseFormat,\n      StateSchema,\n      ContextSchema\n    >\n  ) {\n    this.#toolBehaviorVersion = options.version ?? this.#toolBehaviorVersion;\n\n    /**\n     * validate that model option is provided\n     */\n    if (!options.model) {\n      throw new Error(\"`model` option is required to create an agent.\");\n    }\n\n    /**\n     * Check if the LLM already has bound tools and throw if it does.\n     */\n    if (typeof options.model !== \"string\") {\n      validateLLMHasNoBoundTools(options.model);\n    }\n\n    /**\n     * define complete list of tools based on options and middleware\n     */\n    const middlewareTools = (this.options.middleware\n      ?.filter((m) => m.tools)\n      .flatMap((m) => m.tools) ?? []) as (ClientTool | ServerTool)[];\n    const toolClasses = [...(options.tools ?? []), ...middlewareTools];\n\n    /**\n     * If any of the tools are configured to return_directly after running,\n     * our graph needs to check if these were called\n     */\n    const shouldReturnDirect = new Set(\n      toolClasses\n        .filter(isClientTool)\n        .filter((tool) => \"returnDirect\" in tool && tool.returnDirect)\n        .map((tool) => tool.name)\n    );\n\n    /**\n     * Create a schema that merges agent base schema with middleware state schemas\n     * Using Zod with withLangGraph ensures LangGraph Studio gets proper metadata\n     */\n    const schema = createAgentAnnotationConditional<StateSchema, TMiddleware>(\n      this.options.responseFormat !== undefined,\n      this.options.stateSchema as StateSchema,\n      this.options.middleware as TMiddleware\n    );\n\n    const workflow = new StateGraph(\n      schema as unknown as AnnotationRoot<any>,\n      this.options.contextSchema\n    );\n\n    const allNodeWorkflows = workflow as WithStateGraphNodes<\n      \"tools\" | \"model_request\" | string,\n      typeof workflow\n    >;\n\n    // Generate node names for middleware nodes that have hooks\n    const beforeAgentNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[] = [];\n    const beforeModelNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[] = [];\n    const afterModelNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[] = [];\n    const afterAgentNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[] = [];\n    const wrapModelCallHookMiddleware: [\n      AgentMiddleware,\n      /**\n       * ToDo: better type to get the state of middleware\n       */\n      () => any\n    ][] = [];\n\n    this.#agentNode = new AgentNode({\n      model: this.options.model,\n      systemPrompt: this.options.systemPrompt,\n      includeAgentName: this.options.includeAgentName,\n      name: this.options.name,\n      responseFormat: this.options.responseFormat,\n      middleware: this.options.middleware,\n      toolClasses,\n      shouldReturnDirect,\n      signal: this.options.signal,\n      wrapModelCallHookMiddleware,\n    });\n\n    const middlewareNames = new Set<string>();\n    const middleware = this.options.middleware ?? [];\n    for (let i = 0; i < middleware.length; i++) {\n      let beforeAgentNode: BeforeAgentNode | undefined;\n      let beforeModelNode: BeforeModelNode | undefined;\n      let afterModelNode: AfterModelNode | undefined;\n      let afterAgentNode: AfterAgentNode | undefined;\n      const m = middleware[i];\n      if (middlewareNames.has(m.name)) {\n        throw new Error(`Middleware ${m.name} is defined multiple times`);\n      }\n\n      middlewareNames.add(m.name);\n      if (m.beforeAgent) {\n        beforeAgentNode = new BeforeAgentNode(m, {\n          getPrivateState: () => this.#agentNode.getState()._privateState,\n        });\n        const name = `${m.name}.before_agent`;\n        beforeAgentNodes.push({\n          index: i,\n          name,\n          allowed: getHookConstraint(m.beforeAgent),\n        });\n        allNodeWorkflows.addNode(\n          name,\n          beforeAgentNode,\n          beforeAgentNode.nodeOptions\n        );\n      }\n      if (m.beforeModel) {\n        beforeModelNode = new BeforeModelNode(m, {\n          getPrivateState: () => this.#agentNode.getState()._privateState,\n        });\n        const name = `${m.name}.before_model`;\n        beforeModelNodes.push({\n          index: i,\n          name,\n          allowed: getHookConstraint(m.beforeModel),\n        });\n        allNodeWorkflows.addNode(\n          name,\n          beforeModelNode,\n          beforeModelNode.nodeOptions\n        );\n      }\n      if (m.afterModel) {\n        afterModelNode = new AfterModelNode(m, {\n          getPrivateState: () => this.#agentNode.getState()._privateState,\n        });\n        const name = `${m.name}.after_model`;\n        afterModelNodes.push({\n          index: i,\n          name,\n          allowed: getHookConstraint(m.afterModel),\n        });\n        allNodeWorkflows.addNode(\n          name,\n          afterModelNode,\n          afterModelNode.nodeOptions\n        );\n      }\n      if (m.afterAgent) {\n        afterAgentNode = new AfterAgentNode(m, {\n          getPrivateState: () => this.#agentNode.getState()._privateState,\n        });\n        const name = `${m.name}.after_agent`;\n        afterAgentNodes.push({\n          index: i,\n          name,\n          allowed: getHookConstraint(m.afterAgent),\n        });\n        allNodeWorkflows.addNode(\n          name,\n          afterAgentNode,\n          afterAgentNode.nodeOptions\n        );\n      }\n\n      if (m.wrapModelCall) {\n        wrapModelCallHookMiddleware.push([\n          m,\n          () => ({\n            ...beforeAgentNode?.getState(),\n            ...beforeModelNode?.getState(),\n            ...afterModelNode?.getState(),\n            ...afterAgentNode?.getState(),\n          }),\n        ]);\n      }\n    }\n\n    /**\n     * Add Nodes\n     */\n    allNodeWorkflows.addNode(\n      \"model_request\",\n      this.#agentNode,\n      AgentNode.nodeOptions\n    );\n\n    /**\n     * Collect and compose wrapToolCall handlers from middleware\n     * Wrap each handler with error handling and validation\n     */\n    const wrapToolCallHandler = wrapToolCall(middleware);\n\n    /**\n     * add single tool node for all tools\n     */\n    if (toolClasses.filter(isClientTool).length > 0) {\n      const toolNode = new ToolNode(toolClasses.filter(isClientTool), {\n        signal: this.options.signal,\n        wrapToolCall: wrapToolCallHandler,\n        getPrivateState: () => this.#agentNode.getState()._privateState,\n      });\n      allNodeWorkflows.addNode(\"tools\", toolNode);\n    }\n\n    /**\n     * Add Edges\n     */\n    // Determine the entry node (runs once at start): before_agent -> before_model -> model_request\n    let entryNode: string;\n    if (beforeAgentNodes.length > 0) {\n      entryNode = beforeAgentNodes[0].name;\n    } else if (beforeModelNodes.length > 0) {\n      entryNode = beforeModelNodes[0].name;\n    } else {\n      entryNode = \"model_request\";\n    }\n\n    // Determine the loop entry node (beginning of agent loop, excludes before_agent)\n    // This is where tools will loop back to for the next iteration\n    const loopEntryNode =\n      beforeModelNodes.length > 0 ? beforeModelNodes[0].name : \"model_request\";\n\n    // Determine the exit node (runs once at end): after_agent or END\n    const exitNode =\n      afterAgentNodes.length > 0\n        ? afterAgentNodes[afterAgentNodes.length - 1].name\n        : END;\n\n    allNodeWorkflows.addEdge(START, entryNode);\n\n    // Connect beforeAgent nodes (run once at start)\n    for (let i = 0; i < beforeAgentNodes.length; i++) {\n      const node = beforeAgentNodes[i];\n      const current = node.name;\n      const isLast = i === beforeAgentNodes.length - 1;\n      const nextDefault = isLast ? loopEntryNode : beforeAgentNodes[i + 1].name;\n\n      if (node.allowed && node.allowed.length > 0) {\n        const hasTools = toolClasses.filter(isClientTool).length > 0;\n        const allowedMapped = node.allowed\n          .map((t) => parseJumpToTarget(t))\n          .filter((dest) => dest !== \"tools\" || hasTools);\n        // Replace END with exitNode (which could be an afterAgent node)\n        const destinations = Array.from(\n          new Set([\n            nextDefault,\n            ...allowedMapped.map((dest) => (dest === END ? exitNode : dest)),\n          ])\n        ) as (\"tools\" | \"model_request\" | typeof END)[];\n\n        allNodeWorkflows.addConditionalEdges(\n          current,\n          this.#createBeforeAgentRouter(\n            toolClasses.filter(isClientTool),\n            nextDefault,\n            exitNode\n          ),\n          destinations\n        );\n      } else {\n        allNodeWorkflows.addEdge(current, nextDefault);\n      }\n    }\n\n    // Connect beforeModel nodes; add conditional routing ONLY if allowed jumps are specified\n    for (let i = 0; i < beforeModelNodes.length; i++) {\n      const node = beforeModelNodes[i];\n      const current = node.name;\n      const isLast = i === beforeModelNodes.length - 1;\n      const nextDefault = isLast\n        ? \"model_request\"\n        : beforeModelNodes[i + 1].name;\n\n      if (node.allowed && node.allowed.length > 0) {\n        const hasTools = toolClasses.filter(isClientTool).length > 0;\n        const allowedMapped = node.allowed\n          .map((t) => parseJumpToTarget(t))\n          .filter((dest) => dest !== \"tools\" || hasTools);\n        const destinations = Array.from(\n          new Set([nextDefault, ...allowedMapped])\n        ) as (\"tools\" | \"model_request\" | typeof END)[];\n\n        allNodeWorkflows.addConditionalEdges(\n          current,\n          this.#createBeforeModelRouter(\n            toolClasses.filter(isClientTool),\n            nextDefault\n          ),\n          destinations\n        );\n      } else {\n        allNodeWorkflows.addEdge(current, nextDefault);\n      }\n    }\n\n    // Connect agent to last afterModel node (for reverse order execution)\n    const lastAfterModelNode = afterModelNodes.at(-1);\n    if (afterModelNodes.length > 0 && lastAfterModelNode) {\n      allNodeWorkflows.addEdge(\"model_request\", lastAfterModelNode.name);\n    } else {\n      // If no afterModel nodes, connect model_request directly to model paths\n      const modelPaths = this.#getModelPaths(toolClasses.filter(isClientTool));\n      // Replace END with exitNode in destinations, since exitNode might be an afterAgent node\n      const destinations = modelPaths.map((p) =>\n        p === END ? exitNode : p\n      ) as (\"tools\" | \"model_request\" | typeof END)[];\n      if (destinations.length === 1) {\n        allNodeWorkflows.addEdge(\"model_request\", destinations[0]);\n      } else {\n        allNodeWorkflows.addConditionalEdges(\n          \"model_request\",\n          this.#createModelRouter(exitNode),\n          destinations\n        );\n      }\n    }\n\n    // Connect afterModel nodes in reverse sequence; add conditional routing ONLY if allowed jumps are specified per node\n    for (let i = afterModelNodes.length - 1; i > 0; i--) {\n      const node = afterModelNodes[i];\n      const current = node.name;\n      const nextDefault = afterModelNodes[i - 1].name;\n\n      if (node.allowed && node.allowed.length > 0) {\n        const hasTools = toolClasses.filter(isClientTool).length > 0;\n        const allowedMapped = node.allowed\n          .map((t) => parseJumpToTarget(t))\n          .filter((dest) => dest !== \"tools\" || hasTools);\n        const destinations = Array.from(\n          new Set([nextDefault, ...allowedMapped])\n        ) as (\"tools\" | \"model_request\" | typeof END)[];\n\n        allNodeWorkflows.addConditionalEdges(\n          current,\n          this.#createAfterModelSequenceRouter(\n            toolClasses.filter(isClientTool),\n            node.allowed,\n            nextDefault\n          ),\n          destinations\n        );\n      } else {\n        allNodeWorkflows.addEdge(current, nextDefault);\n      }\n    }\n\n    // Connect first afterModel node (last to execute) to model paths with jumpTo support\n    if (afterModelNodes.length > 0) {\n      const firstAfterModel = afterModelNodes[0];\n      const firstAfterModelNode = firstAfterModel.name;\n\n      // Include exitNode in the paths since afterModel should be able to route to after_agent or END\n      const modelPaths = this.#getModelPaths(\n        toolClasses.filter(isClientTool),\n        true\n      ).filter(\n        (p) => p !== \"tools\" || toolClasses.filter(isClientTool).length > 0\n      );\n\n      const allowJump = Boolean(\n        firstAfterModel.allowed && firstAfterModel.allowed.length > 0\n      );\n\n      // Replace END with exitNode in destinations, since exitNode might be an afterAgent node\n      const destinations = modelPaths.map((p) =>\n        p === END ? exitNode : p\n      ) as (\"tools\" | \"model_request\" | typeof END)[];\n\n      allNodeWorkflows.addConditionalEdges(\n        firstAfterModelNode,\n        this.#createAfterModelRouter(\n          toolClasses.filter(isClientTool),\n          allowJump,\n          exitNode\n        ),\n        destinations\n      );\n    }\n\n    // Connect afterAgent nodes (run once at end, in reverse order like afterModel)\n    for (let i = afterAgentNodes.length - 1; i > 0; i--) {\n      const node = afterAgentNodes[i];\n      const current = node.name;\n      const nextDefault = afterAgentNodes[i - 1].name;\n\n      if (node.allowed && node.allowed.length > 0) {\n        const hasTools = toolClasses.filter(isClientTool).length > 0;\n        const allowedMapped = node.allowed\n          .map((t) => parseJumpToTarget(t))\n          .filter((dest) => dest !== \"tools\" || hasTools);\n        const destinations = Array.from(\n          new Set([nextDefault, ...allowedMapped])\n        ) as (\"tools\" | \"model_request\" | typeof END)[];\n\n        allNodeWorkflows.addConditionalEdges(\n          current,\n          this.#createAfterModelSequenceRouter(\n            toolClasses.filter(isClientTool),\n            node.allowed,\n            nextDefault\n          ),\n          destinations\n        );\n      } else {\n        allNodeWorkflows.addEdge(current, nextDefault);\n      }\n    }\n\n    // Connect the first afterAgent node (last to execute) to END\n    if (afterAgentNodes.length > 0) {\n      const firstAfterAgent = afterAgentNodes[0];\n      const firstAfterAgentNode = firstAfterAgent.name;\n\n      if (firstAfterAgent.allowed && firstAfterAgent.allowed.length > 0) {\n        const hasTools = toolClasses.filter(isClientTool).length > 0;\n        const allowedMapped = firstAfterAgent.allowed\n          .map((t) => parseJumpToTarget(t))\n          .filter((dest) => dest !== \"tools\" || hasTools);\n\n        /**\n         * For after_agent, only use explicitly allowed destinations (don't add loopEntryNode)\n         * The default destination (when no jump occurs) should be END\n         */\n        const destinations = Array.from(new Set([END, ...allowedMapped])) as (\n          | \"tools\"\n          | \"model_request\"\n          | typeof END\n        )[];\n\n        allNodeWorkflows.addConditionalEdges(\n          firstAfterAgentNode,\n          this.#createAfterModelSequenceRouter(\n            toolClasses.filter(isClientTool),\n            firstAfterAgent.allowed,\n            END as string\n          ),\n          destinations\n        );\n      } else {\n        allNodeWorkflows.addEdge(firstAfterAgentNode, END);\n      }\n    }\n\n    /**\n     * add edges for tools node\n     */\n    if (toolClasses.filter(isClientTool).length > 0) {\n      // Tools should return to loop entry node (not including before_agent)\n      const toolReturnTarget = loopEntryNode;\n\n      if (shouldReturnDirect.size > 0) {\n        allNodeWorkflows.addConditionalEdges(\n          \"tools\",\n          this.#createToolsRouter(shouldReturnDirect, exitNode),\n          [toolReturnTarget, exitNode as string]\n        );\n      } else {\n        allNodeWorkflows.addEdge(\"tools\", toolReturnTarget);\n      }\n    }\n\n    /**\n     * compile the graph\n     */\n    this.#graph = allNodeWorkflows.compile({\n      checkpointer: this.options.checkpointer,\n      store: this.options.store,\n      name: this.options.name,\n      description: this.options.description,\n    }) as AgentGraph<\n      StateSchema,\n      StructuredResponseFormat,\n      ContextSchema,\n      TMiddleware\n    >;\n  }\n\n  /**\n   * Get the compiled {@link https://docs.langchain.com/oss/javascript/langgraph/use-graph-api | StateGraph}.\n   */\n  get graph(): AgentGraph<\n    StateSchema,\n    StructuredResponseFormat,\n    ContextSchema,\n    TMiddleware\n  > {\n    return this.#graph;\n  }\n\n  /**\n   * Get possible edge destinations from model node.\n   * @param toolClasses names of tools to call\n   * @param includeModelRequest whether to include \"model_request\" as a valid path (for jumpTo routing)\n   * @returns list of possible edge destinations\n   */\n  #getModelPaths(\n    toolClasses: (ClientTool | ServerTool)[],\n    includeModelRequest: boolean = false\n  ): (\"tools\" | \"model_request\" | typeof END)[] {\n    const paths: (\"tools\" | \"model_request\" | typeof END)[] = [];\n    if (toolClasses.length > 0) {\n      paths.push(\"tools\");\n    }\n\n    if (includeModelRequest) {\n      paths.push(\"model_request\");\n    }\n\n    paths.push(END);\n\n    return paths;\n  }\n\n  /**\n   * Create routing function for tools node conditional edges.\n   */\n  #createToolsRouter(\n    shouldReturnDirect: Set<string>,\n    exitNode: string | typeof END\n  ) {\n    /**\n     * ToDo: fix type\n     */\n    return (state: any) => {\n      const messages = state.messages;\n      const lastMessage = messages[messages.length - 1];\n\n      // Check if we just executed a returnDirect tool\n      if (\n        ToolMessage.isInstance(lastMessage) &&\n        lastMessage.name &&\n        shouldReturnDirect.has(lastMessage.name)\n      ) {\n        // If we have a response format, route to agent to generate structured response\n        // Otherwise, return directly to exit node (could be after_agent or END)\n        return this.options.responseFormat ? \"model_request\" : exitNode;\n      }\n\n      // For non-returnDirect tools, always route back to agent\n      return \"model_request\";\n    };\n  }\n\n  /**\n   * Create routing function for model node conditional edges.\n   * @param exitNode - The exit node to route to (could be after_agent or END)\n   */\n  #createModelRouter(exitNode: string | typeof END = END) {\n    /**\n     * determine if the agent should continue or not\n     */\n    return (state: BuiltInState) => {\n      const messages = state.messages;\n      const lastMessage = messages.at(-1);\n\n      if (\n        !AIMessage.isInstance(lastMessage) ||\n        !lastMessage.tool_calls ||\n        lastMessage.tool_calls.length === 0\n      ) {\n        return exitNode;\n      }\n\n      // Check if all tool calls are for structured response extraction\n      const hasOnlyStructuredResponseCalls = lastMessage.tool_calls.every(\n        (toolCall) => toolCall.name.startsWith(\"extract-\")\n      );\n\n      if (hasOnlyStructuredResponseCalls) {\n        // If all tool calls are for structured response extraction, go to exit node\n        // The AgentNode will handle these internally and return the structured response\n        return exitNode;\n      }\n\n      /**\n       * The tool node processes a single message.\n       */\n      if (this.#toolBehaviorVersion === \"v1\") {\n        return \"tools\";\n      }\n\n      /**\n       * Route to tools node (filter out any structured response tool calls)\n       */\n      const regularToolCalls = lastMessage.tool_calls.filter(\n        (toolCall) => !toolCall.name.startsWith(\"extract-\")\n      );\n\n      if (regularToolCalls.length === 0) {\n        return exitNode;\n      }\n\n      return regularToolCalls.map(\n        (toolCall) => new Send(\"tools\", { ...state, lg_tool_call: toolCall })\n      );\n    };\n  }\n\n  /**\n   * Create routing function for jumpTo functionality after afterModel hooks.\n   *\n   * This router checks if the `jumpTo` property is set in the state after afterModel middleware\n   * execution. If set, it routes to the specified target (\"model_request\" or \"tools\").\n   * If not set, it falls back to the normal model routing logic for afterModel context.\n   *\n   * The jumpTo property is automatically cleared after use to prevent infinite loops.\n   *\n   * @param toolClasses - Available tool classes for validation\n   * @param allowJump - Whether jumping is allowed\n   * @param exitNode - The exit node to route to (could be after_agent or END)\n   * @returns Router function that handles jumpTo logic and normal routing\n   */\n  #createAfterModelRouter(\n    toolClasses: (ClientTool | ServerTool)[],\n    allowJump: boolean,\n    exitNode: string | typeof END\n  ) {\n    const hasStructuredResponse = Boolean(this.options.responseFormat);\n\n    return (state: Omit<BuiltInState, \"jumpTo\"> & { jumpTo?: JumpTo }) => {\n      // First, check if we just processed a structured response\n      // If so, ignore any existing jumpTo and go to exitNode\n      const messages = state.messages;\n      const lastMessage = messages.at(-1);\n      if (\n        AIMessage.isInstance(lastMessage) &&\n        (!lastMessage.tool_calls || lastMessage.tool_calls.length === 0)\n      ) {\n        return exitNode;\n      }\n\n      // Check if jumpTo is set in the state and allowed\n      if (allowJump && state.jumpTo) {\n        if (state.jumpTo === END) {\n          return exitNode;\n        }\n        if (state.jumpTo === \"tools\") {\n          // If trying to jump to tools but no tools are available, go to exitNode\n          if (toolClasses.length === 0) {\n            return exitNode;\n          }\n          return new Send(\"tools\", { ...state, jumpTo: undefined });\n        }\n        // destination === \"model_request\"\n        return new Send(\"model_request\", { ...state, jumpTo: undefined });\n      }\n\n      // check if there are pending tool calls\n      const toolMessages = messages.filter(ToolMessage.isInstance);\n      const lastAiMessage = messages.filter(AIMessage.isInstance).at(-1);\n      const pendingToolCalls = lastAiMessage?.tool_calls?.filter(\n        (call) => !toolMessages.some((m) => m.tool_call_id === call.id)\n      );\n      if (pendingToolCalls && pendingToolCalls.length > 0) {\n        return pendingToolCalls.map(\n          (toolCall) => new Send(\"tools\", { ...state, lg_tool_call: toolCall })\n        );\n      }\n\n      // if we exhausted all tool calls, but still have no structured response tool calls,\n      // go back to model_request\n      const hasStructuredResponseCalls = lastAiMessage?.tool_calls?.some(\n        (toolCall) => toolCall.name.startsWith(\"extract-\")\n      );\n\n      if (\n        pendingToolCalls &&\n        pendingToolCalls.length === 0 &&\n        !hasStructuredResponseCalls &&\n        hasStructuredResponse\n      ) {\n        return \"model_request\";\n      }\n\n      if (\n        !AIMessage.isInstance(lastMessage) ||\n        !lastMessage.tool_calls ||\n        lastMessage.tool_calls.length === 0\n      ) {\n        return exitNode;\n      }\n\n      // Check if all tool calls are for structured response extraction\n      const hasOnlyStructuredResponseCalls = lastMessage.tool_calls.every(\n        (toolCall) => toolCall.name.startsWith(\"extract-\")\n      );\n\n      // Check if there are any regular tool calls (non-structured response)\n      const hasRegularToolCalls = lastMessage.tool_calls.some(\n        (toolCall) => !toolCall.name.startsWith(\"extract-\")\n      );\n\n      if (hasOnlyStructuredResponseCalls || !hasRegularToolCalls) {\n        return exitNode;\n      }\n\n      /**\n       * For routing from afterModel nodes, always use simple string paths\n       * The Send API is handled at the model_request node level\n       */\n      return \"tools\";\n    };\n  }\n\n  /**\n   * Router for afterModel sequence nodes (connecting later middlewares to earlier ones),\n   * honoring allowed jump targets and defaulting to the next node.\n   */\n  #createAfterModelSequenceRouter(\n    toolClasses: (ClientTool | ServerTool)[],\n    allowed: string[],\n    nextDefault: string\n  ) {\n    const allowedSet = new Set(allowed.map((t) => parseJumpToTarget(t)));\n    return (state: BuiltInState) => {\n      if (state.jumpTo) {\n        const dest = parseJumpToTarget(state.jumpTo);\n        if (dest === END && allowedSet.has(END)) {\n          return END;\n        }\n        if (dest === \"tools\" && allowedSet.has(\"tools\")) {\n          if (toolClasses.length === 0) return END;\n          return new Send(\"tools\", { ...state, jumpTo: undefined });\n        }\n        if (dest === \"model_request\" && allowedSet.has(\"model_request\")) {\n          return new Send(\"model_request\", { ...state, jumpTo: undefined });\n        }\n      }\n      return nextDefault as any;\n    };\n  }\n\n  /**\n   * Create routing function for jumpTo functionality after beforeAgent hooks.\n   * Falls back to the default next node if no jumpTo is present.\n   * When jumping to END, routes to exitNode (which could be an afterAgent node).\n   */\n  #createBeforeAgentRouter(\n    toolClasses: (ClientTool | ServerTool)[],\n    nextDefault: string,\n    exitNode: string | typeof END\n  ) {\n    return (state: BuiltInState) => {\n      if (!state.jumpTo) {\n        return nextDefault;\n      }\n      const destination = parseJumpToTarget(state.jumpTo);\n      if (destination === END) {\n        // When beforeAgent jumps to END, route to exitNode (first afterAgent node)\n        return exitNode;\n      }\n      if (destination === \"tools\") {\n        if (toolClasses.length === 0) {\n          return exitNode;\n        }\n        return new Send(\"tools\", { ...state, jumpTo: undefined });\n      }\n      // destination === \"model_request\"\n      return new Send(\"model_request\", { ...state, jumpTo: undefined });\n    };\n  }\n\n  /**\n   * Create routing function for jumpTo functionality after beforeModel hooks.\n   * Falls back to the default next node if no jumpTo is present.\n   */\n  #createBeforeModelRouter(\n    toolClasses: (ClientTool | ServerTool)[],\n    nextDefault: string\n  ) {\n    return (state: BuiltInState) => {\n      if (!state.jumpTo) {\n        return nextDefault;\n      }\n      const destination = parseJumpToTarget(state.jumpTo);\n      if (destination === END) {\n        return END;\n      }\n      if (destination === \"tools\") {\n        if (toolClasses.length === 0) {\n          return END;\n        }\n        return new Send(\"tools\", { ...state, jumpTo: undefined });\n      }\n      // destination === \"model_request\"\n      return new Send(\"model_request\", { ...state, jumpTo: undefined });\n    };\n  }\n\n  /**\n   * Initialize middleware states if not already present in the input state.\n   */\n  async #initializeMiddlewareStates(\n    state: InvokeStateParameter<StateSchema, TMiddleware>\n  ): Promise<InvokeStateParameter<StateSchema, TMiddleware>> {\n    if (\n      !this.options.middleware ||\n      this.options.middleware.length === 0 ||\n      state instanceof Command ||\n      !state\n    ) {\n      return state;\n    }\n\n    const defaultStates = await initializeMiddlewareStates(\n      this.options.middleware,\n      state\n    );\n    const updatedState = { ...state } as InvokeStateParameter<\n      StateSchema,\n      TMiddleware\n    >;\n    if (!updatedState) {\n      return updatedState;\n    }\n\n    // Only add defaults for keys that don't exist in current state\n    for (const [key, value] of Object.entries(defaultStates)) {\n      if (!(key in updatedState)) {\n        updatedState[key as keyof typeof updatedState] = value;\n      }\n    }\n\n    return updatedState;\n  }\n\n  /**\n   * Populate the private state of the agent node from the previous state.\n   */\n  async #populatePrivateState(config?: RunnableConfig) {\n    /**\n     * not needed if thread_id is not provided\n     */\n    if (!config?.configurable?.thread_id) {\n      return;\n    }\n    const prevState = (await this.#graph.getState(config as any)) as {\n      values: {\n        _privateState: PrivateState;\n      };\n    };\n\n    /**\n     * not need if state is empty\n     */\n    if (!prevState.values._privateState) {\n      return;\n    }\n\n    this.#agentNode.setState({\n      structuredResponse: undefined,\n      _privateState: prevState.values._privateState,\n    });\n  }\n\n  /**\n   * Executes the agent with the given state and returns the final state after all processing.\n   *\n   * This method runs the agent's entire workflow synchronously, including:\n   * - Processing the input messages through any configured middleware\n   * - Calling the language model to generate responses\n   * - Executing any tool calls made by the model\n   * - Running all middleware hooks (beforeModel, afterModel, etc.)\n   *\n   * @param state - The initial state for the agent execution. Can be:\n   *   - An object containing `messages` array and any middleware-specific state properties\n   *   - A Command object for more advanced control flow\n   *\n   * @param config - Optional runtime configuration including:\n   * @param config.context - The context for the agent execution.\n   * @param config.configurable - LangGraph configuration options like `thread_id`, `run_id`, etc.\n   * @param config.store - The store for the agent execution for persisting state, see more in {@link https://docs.langchain.com/oss/javascript/langgraph/memory#memory-storage | Memory storage}.\n   * @param config.signal - An optional {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal | `AbortSignal`} for the agent execution.\n   * @param config.recursionLimit - The recursion limit for the agent execution.\n   *\n   * @returns A Promise that resolves to the final agent state after execution completes.\n   *          The returned state includes:\n   *          - a `messages` property containing an array with all messages (input, AI responses, tool calls/results)\n   *          - a `structuredResponse` property containing the structured response (if configured)\n   *          - all state values defined in the middleware\n   *\n   * @example\n   * ```typescript\n   * const agent = new ReactAgent({\n   *   llm: myModel,\n   *   tools: [calculator, webSearch],\n   *   responseFormat: z.object({\n   *     weather: z.string(),\n   *   }),\n   * });\n   *\n   * const result = await agent.invoke({\n   *   messages: [{ role: \"human\", content: \"What's the weather in Paris?\" }]\n   * });\n   *\n   * console.log(result.structuredResponse.weather); // outputs: \"It's sunny and 75°F.\"\n   * ```\n   */\n  async invoke(\n    state: InvokeStateParameter<StateSchema, TMiddleware>,\n    config?: InvokeConfiguration<\n      InferContextInput<ContextSchema> &\n        InferMiddlewareContextInputs<TMiddleware>\n    >\n  ) {\n    type FullState = MergedAgentState<\n      StateSchema,\n      StructuredResponseFormat,\n      TMiddleware\n    >;\n    const initializedState = await this.#initializeMiddlewareStates(state);\n    await this.#populatePrivateState(config);\n\n    return this.#graph.invoke(\n      initializedState,\n      config as unknown as InferContextInput<ContextSchema> &\n        InferMiddlewareContextInputs<TMiddleware>\n    ) as Promise<FullState>;\n  }\n\n  /**\n   * Executes the agent with streaming, returning an async iterable of state updates as they occur.\n   *\n   * This method runs the agent's workflow similar to `invoke`, but instead of waiting for\n   * completion, it streams high-level state updates in real-time. This allows you to:\n   * - Display intermediate results to users as they're generated\n   * - Monitor the agent's progress through each step\n   * - React to state changes as nodes complete\n   *\n   * For more granular event-level streaming (like individual LLM tokens), use `streamEvents` instead.\n   *\n   * @param state - The initial state for the agent execution. Can be:\n   *   - An object containing `messages` array and any middleware-specific state properties\n   *   - A Command object for more advanced control flow\n   *\n   * @param config - Optional runtime configuration including:\n   * @param config.context - The context for the agent execution.\n   * @param config.configurable - LangGraph configuration options like `thread_id`, `run_id`, etc.\n   * @param config.store - The store for the agent execution for persisting state, see more in {@link https://docs.langchain.com/oss/javascript/langgraph/memory#memory-storage | Memory storage}.\n   * @param config.signal - An optional {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal | `AbortSignal`} for the agent execution.\n   * @param config.streamMode - The streaming mode for the agent execution, see more in {@link https://docs.langchain.com/oss/javascript/langgraph/streaming#supported-stream-modes | Supported stream modes}.\n   * @param config.recursionLimit - The recursion limit for the agent execution.\n   *\n   * @returns A Promise that resolves to an IterableReadableStream of state updates.\n   *          Each update contains the current state after a node completes.\n   *\n   * @example\n   * ```typescript\n   * const agent = new ReactAgent({\n   *   llm: myModel,\n   *   tools: [calculator, webSearch]\n   * });\n   *\n   * const stream = await agent.stream({\n   *   messages: [{ role: \"human\", content: \"What's 2+2 and the weather in NYC?\" }]\n   * });\n   *\n   * for await (const chunk of stream) {\n   *   console.log(chunk); // State update from each node\n   * }\n   * ```\n   */\n  async stream(\n    state: InvokeStateParameter<StateSchema, TMiddleware>,\n    config?: StreamConfiguration<\n      InferContextInput<ContextSchema> &\n        InferMiddlewareContextInputs<TMiddleware>\n    >\n  ): Promise<IterableReadableStream<any>> {\n    const initializedState = await this.#initializeMiddlewareStates(state);\n    return this.#graph.stream(initializedState, config as Record<string, any>);\n  }\n\n  /**\n   * Visualize the graph as a PNG image.\n   * @param params - Parameters for the drawMermaidPng method.\n   * @param params.withStyles - Whether to include styles in the graph.\n   * @param params.curveStyle - The style of the graph's curves.\n   * @param params.nodeColors - The colors of the graph's nodes.\n   * @param params.wrapLabelNWords - The maximum number of words to wrap in a node's label.\n   * @param params.backgroundColor - The background color of the graph.\n   * @returns PNG image as a buffer\n   */\n  async drawMermaidPng(params?: {\n    withStyles?: boolean;\n    curveStyle?: string;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n    backgroundColor?: string;\n  }) {\n    const representation = await this.#graph.getGraphAsync();\n    const image = await representation.drawMermaidPng(params);\n    const arrayBuffer = await image.arrayBuffer();\n    const buffer = new Uint8Array(arrayBuffer);\n    return buffer;\n  }\n\n  /**\n   * Draw the graph as a Mermaid string.\n   * @param params - Parameters for the drawMermaid method.\n   * @param params.withStyles - Whether to include styles in the graph.\n   * @param params.curveStyle - The style of the graph's curves.\n   * @param params.nodeColors - The colors of the graph's nodes.\n   * @param params.wrapLabelNWords - The maximum number of words to wrap in a node's label.\n   * @param params.backgroundColor - The background color of the graph.\n   * @returns Mermaid string\n   */\n  async drawMermaid(params?: {\n    withStyles?: boolean;\n    curveStyle?: string;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n    backgroundColor?: string;\n  }) {\n    const representation = await this.#graph.getGraphAsync();\n    return representation.drawMermaid(params);\n  }\n\n  /**\n   * The following are internal methods to enable support for LangGraph Platform.\n   * They are not part of the createAgent public API.\n   *\n   * Note: we intentionally return as `never` to avoid type errors due to type inference.\n   */\n\n  /**\n   * @internal\n   */\n  streamEvents(\n    state: InvokeStateParameter<StateSchema, TMiddleware>,\n    config?: StreamConfiguration<\n      InferContextInput<ContextSchema> &\n        InferMiddlewareContextInputs<TMiddleware>\n    > & { version?: \"v1\" | \"v2\" },\n    streamOptions?: Parameters<Runnable[\"streamEvents\"]>[2]\n  ): IterableReadableStream<StreamEvent> {\n    return this.#graph.streamEvents(\n      state,\n      {\n        ...(config as any),\n        version: config?.version ?? \"v2\",\n      },\n      streamOptions\n    );\n  }\n  /**\n   * @internal\n   */\n  getGraphAsync(config?: RunnableConfig) {\n    return this.#graph.getGraphAsync(config) as never;\n  }\n  /**\n   * @internal\n   */\n  getState(config: RunnableConfig, options?: GetStateOptions) {\n    return this.#graph.getState(config, options) as never;\n  }\n  /**\n   * @internal\n   */\n  getStateHistory(config: RunnableConfig, options?: CheckpointListOptions) {\n    return this.#graph.getStateHistory(config, options) as never;\n  }\n  /**\n   * @internal\n   */\n  getSubgraphs(namespace?: string, recurse?: boolean) {\n    return this.#graph.getSubgraphs(namespace, recurse) as never;\n  }\n  /**\n   * @internal\n   */\n  getSubgraphAsync(namespace?: string, recurse?: boolean) {\n    return this.#graph.getSubgraphsAsync(namespace, recurse) as never;\n  }\n  /**\n   * @internal\n   */\n  updateState(\n    inputConfig: LangGraphRunnableConfig,\n    values: Record<string, unknown> | unknown,\n    asNode?: string\n  ) {\n    return this.#graph.updateState(inputConfig, values, asNode) as never;\n  }\n}\n"],"mappings":"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"}