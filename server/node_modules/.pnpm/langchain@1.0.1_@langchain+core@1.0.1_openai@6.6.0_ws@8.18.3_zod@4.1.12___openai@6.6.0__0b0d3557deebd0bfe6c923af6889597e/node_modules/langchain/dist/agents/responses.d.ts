import { MultipleStructuredOutputsError, StructuredOutputParsingError } from "./errors.js";
import { AIMessage } from "@langchain/core/messages";
import { InteropZodObject, InteropZodType } from "@langchain/core/utils/types";
import { FunctionDefinition, LanguageModelLike } from "@langchain/core/language_models/base";

//#region src/agents/responses.d.ts

/**
 * Special type to indicate that no response format is provided.
 * When this type is used, the structuredResponse property should not be present in the result.
 */
type ResponseFormatUndefined = {
  __responseFormatUndefined: true;
};
/**
 * Information for tracking structured output tool metadata.
 * This contains all necessary information to handle structured responses generated
 * via tool calls, including the original schema, its type classification, and the
 * corresponding tool implementation used by the tools strategy.
 */
declare class ToolStrategy<_T = unknown> {
  readonly schema: Record<string, unknown>;
  readonly tool: {
    type: "function";
    function: FunctionDefinition;
  };
  readonly options?: ToolStrategyOptions | undefined;
  private constructor();
  get name(): string;
  static fromSchema<S extends InteropZodObject>(schema: S, outputOptions?: ToolStrategyOptions): ToolStrategy<S extends InteropZodType<infer U> ? U : unknown>;
  static fromSchema(schema: Record<string, unknown>, outputOptions?: ToolStrategyOptions): ToolStrategy<Record<string, unknown>>;
  /**
   * Parse tool arguments according to the schema.
   *
   * @throws {StructuredOutputParsingError} if the response is not valid
   * @param toolArgs - The arguments from the tool call
   * @returns The parsed response according to the schema type
   */
  parse(toolArgs: Record<string, unknown>): Record<string, unknown>;
}
declare class ProviderStrategy<T = unknown> {
  readonly schema: Record<string, unknown>;
  // @ts-expect-error - _schemaType is used only for type inference
  private _schemaType?;
  private constructor();
  static fromSchema<T>(schema: InteropZodType<T>): ProviderStrategy<T>;
  static fromSchema(schema: Record<string, unknown>): ProviderStrategy<Record<string, unknown>>;
  /**
   * Parse tool arguments according to the schema. If the response is not valid, return undefined.
   *
   * @param toolArgs - The arguments from the tool call
   * @returns The parsed response according to the schema type
   */
  parse(response: AIMessage): any;
}
type ResponseFormat = ToolStrategy<any> | ProviderStrategy<any>;
/**
 * Handle user input for `responseFormat` parameter of `CreateAgentParams`.
 * This function defines the default behavior for the `responseFormat` parameter, which is:
 *
 * - if value is a Zod schema, default to structured output via tool calling
 * - if value is a JSON schema, default to structured output via tool calling
 * - if value is a custom response format, return it as is
 * - if value is an array, ensure all array elements are instance of `ToolStrategy`
 * @param responseFormat - The response format to transform, provided by the user
 * @param options - The response format options for tool strategy
 * @param model - The model to check if it supports JSON schema output
 * @returns
 */

/**
 * Branded type for ToolStrategy arrays that preserves type information
 */
interface TypedToolStrategy<T = unknown> extends Array<ToolStrategy<any>> {
  _schemaType?: T;
}
type ToolStrategyError = StructuredOutputParsingError | MultipleStructuredOutputsError;
interface ToolStrategyOptions {
  /**
   * Allows you to customize the message that appears in the conversation history when structured
   * output is generated.
   */
  toolMessageContent?: string;
  /**
   * Handle errors from the structured output tool call. Using tools to generate structured output
   * can cause errors, e.g. if:
   * - you provide multiple structured output schemas and the model calls multiple structured output tools
   * - if the structured output generated by the tool call doesn't match provided schema
   *
   * This property allows to handle these errors in different ways:
   * - `true` - retry the tool call
   * - `false` - throw an error
   * - `string` - retry the tool call with the provided message
   * - `(error: ToolStrategyError) => Promise<string> | string` - retry with the provided message or throw the error
   */
  handleError?: boolean | string | ((error: ToolStrategyError) => Promise<string> | string);
}
declare function toolStrategy<T extends InteropZodType<any>>(responseFormat: T, options?: ToolStrategyOptions): TypedToolStrategy<T extends InteropZodType<infer U> ? U : never>;
declare function toolStrategy<T extends readonly InteropZodType<any>[]>(responseFormat: T, options?: ToolStrategyOptions): TypedToolStrategy<{ [K in keyof T]: T[K] extends InteropZodType<infer U> ? U : never }[number]>;
declare function toolStrategy(responseFormat: JsonSchemaFormat, options?: ToolStrategyOptions): TypedToolStrategy<Record<string, unknown>>;
declare function toolStrategy(responseFormat: JsonSchemaFormat[], options?: ToolStrategyOptions): TypedToolStrategy<Record<string, unknown>>;
declare function providerStrategy<T extends InteropZodType<any>>(responseFormat: T): ProviderStrategy<T extends InteropZodType<infer U> ? U : never>;
declare function providerStrategy(responseFormat: JsonSchemaFormat): ProviderStrategy<Record<string, unknown>>;
/**
 * Type representing a JSON Schema object format.
 * This is a strict type that excludes ToolStrategy and ProviderStrategy instances.
 */
type JsonSchemaFormat = {
  type: "null" | "boolean" | "object" | "array" | "number" | "string" | "integer";
  properties?: Record<string, unknown>;
  required?: string[];
  additionalProperties?: boolean;
  [key: string]: unknown;
} & {
  // Brand to ensure this is not a ToolStrategy or ProviderStrategy
  __brand?: never;
};
/**
 * Identifies the models that support JSON schema output
 * @param model - The model to check
 * @returns True if the model supports JSON schema output, false otherwise
 */
//#endregion
export { JsonSchemaFormat, ProviderStrategy, ResponseFormat, ResponseFormatUndefined, ToolStrategy, TypedToolStrategy, providerStrategy, toolStrategy };
//# sourceMappingURL=responses.d.ts.map