{"version":3,"file":"AgentNode.cjs","names":["RunnableCallable","options: AgentNodeOptions<StructuredResponseFormat, ContextSchema>","#run","#options","model: string | LanguageModelLike","transformResponseFormat","ProviderStrategy","ToolStrategy","state: InternalAgentState<StructuredResponseFormat> &\n      PreHookAnnotation[\"State\"]","config: RunnableConfig","ToolMessage","#invokeModel","#runState","Command","#areMoreStepsNeeded","AIMessage","initChatModel","options: {\n      lastMessage?: string;\n    }","#deriveModel","request: ModelRequest","validateLLMHasNoBoundTools","#getResponseFormat","#bindTools","#getModelInputState","mergeAbortSignals","#handleMultipleStructuredOutputs","#handleSingleStructuredOutput","wrappedHandler: (\n      request: ModelRequest<\n        InternalAgentState<StructuredResponseFormat> &\n          PreHookAnnotation[\"State\"],\n        unknown\n      >\n    ) => Promise<InternalModelResponse<StructuredResponseFormat>>","request: ModelRequest<\n            InternalAgentState<StructuredResponseFormat> &\n              PreHookAnnotation[\"State\"],\n            unknown\n          >","runtime: Runtime<unknown>","requestWithStateAndRuntime: ModelRequest<\n            InternalAgentState<StructuredResponseFormat> &\n              PreHookAnnotation[\"State\"],\n            unknown\n          >","req: ModelRequest<\n              InternalAgentState<StructuredResponseFormat> &\n                PreHookAnnotation[\"State\"],\n              unknown\n            >","isClientTool","initialRequest: ModelRequest<\n      InternalAgentState<StructuredResponseFormat> & PreHookAnnotation[\"State\"],\n      unknown\n    >","response: AIMessage","toolCalls: ToolCall[]","responseFormat: ToolResponseFormat","MultipleStructuredOutputsError","#handleToolStrategyError","toolCall: ToolCall","lastMessage?: string","error: ToolStrategyError","response: BaseMessage","hasToolCalls","model: LanguageModelLike","preparedOptions: ModelRequest | undefined","structuredResponseFormat: ResponseFormat | undefined","options: Partial<BaseChatModelCallOptions>","hasSupportForJsonSchemaOutput","bindTools","getPromptRunnable","withAgentName","z"],"sources":["../../../src/agents/nodes/AgentNode.ts"],"sourcesContent":["/* eslint-disable no-instanceof/no-instanceof */\nimport { Runnable, RunnableConfig } from \"@langchain/core/runnables\";\nimport { BaseMessage, AIMessage, ToolMessage } from \"@langchain/core/messages\";\nimport { z } from \"zod/v3\";\nimport { Command, type LangGraphRunnableConfig } from \"@langchain/langgraph\";\nimport { type LanguageModelLike } from \"@langchain/core/language_models/base\";\nimport { type BaseChatModelCallOptions } from \"@langchain/core/language_models/chat_models\";\nimport {\n  InteropZodObject,\n  getSchemaDescription,\n  interopParse,\n} from \"@langchain/core/utils/types\";\nimport type { ToolCall } from \"@langchain/core/messages/tool\";\n\nimport { initChatModel } from \"../../chat_models/universal.js\";\nimport { MultipleStructuredOutputsError } from \"../errors.js\";\nimport { RunnableCallable } from \"../RunnableCallable.js\";\nimport { PreHookAnnotation } from \"../annotation.js\";\nimport {\n  bindTools,\n  getPromptRunnable,\n  validateLLMHasNoBoundTools,\n  hasToolCalls,\n  isClientTool,\n} from \"../utils.js\";\nimport { mergeAbortSignals } from \"../nodes/utils.js\";\nimport { CreateAgentParams } from \"../types.js\";\nimport type { InternalAgentState, Runtime, PrivateState } from \"../runtime.js\";\nimport type {\n  AgentMiddleware,\n  AnyAnnotationRoot,\n  WrapModelCallHandler,\n} from \"../middleware/types.js\";\nimport type { ModelRequest } from \"./types.js\";\nimport type { ClientTool, ServerTool } from \"../tools.js\";\nimport { withAgentName } from \"../withAgentName.js\";\nimport {\n  ToolStrategy,\n  ProviderStrategy,\n  transformResponseFormat,\n  ToolStrategyError,\n  hasSupportForJsonSchemaOutput,\n} from \"../responses.js\";\n\ntype ResponseHandlerResult<StructuredResponseFormat> =\n  | {\n      structuredResponse: StructuredResponseFormat;\n      messages: BaseMessage[];\n    }\n  | Promise<Command>;\n\n/**\n * Wrap the base handler with middleware wrapModelCall hooks\n * Middleware are composed so the first middleware is the outermost wrapper\n * Example: [auth, retry, cache] means auth wraps retry wraps cache wraps baseHandler\n */\ntype InternalModelResponse<StructuredResponseFormat> =\n  | AIMessage\n  | ResponseHandlerResult<StructuredResponseFormat>;\n\nexport interface AgentNodeOptions<\n  StructuredResponseFormat extends Record<string, unknown> = Record<\n    string,\n    unknown\n  >,\n  StateSchema extends AnyAnnotationRoot | InteropZodObject = AnyAnnotationRoot,\n  ContextSchema extends AnyAnnotationRoot | InteropZodObject = AnyAnnotationRoot\n> extends Pick<\n    CreateAgentParams<StructuredResponseFormat, StateSchema, ContextSchema>,\n    | \"model\"\n    | \"systemPrompt\"\n    | \"includeAgentName\"\n    | \"name\"\n    | \"responseFormat\"\n    | \"middleware\"\n  > {\n  toolClasses: (ClientTool | ServerTool)[];\n  shouldReturnDirect: Set<string>;\n  signal?: AbortSignal;\n  wrapModelCallHookMiddleware?: [\n    AgentMiddleware,\n    () => Record<string, unknown>\n  ][];\n}\n\ninterface NativeResponseFormat {\n  type: \"native\";\n  strategy: ProviderStrategy;\n}\n\ninterface ToolResponseFormat {\n  type: \"tool\";\n  tools: Record<string, ToolStrategy>;\n}\n\ntype ResponseFormat = NativeResponseFormat | ToolResponseFormat;\n\nexport class AgentNode<\n  StructuredResponseFormat extends Record<string, unknown> = Record<\n    string,\n    unknown\n  >,\n  ContextSchema extends AnyAnnotationRoot | InteropZodObject = AnyAnnotationRoot\n> extends RunnableCallable<\n  InternalAgentState<StructuredResponseFormat> & PreHookAnnotation[\"State\"],\n  | ((\n      | { messages: BaseMessage[] }\n      | { structuredResponse: StructuredResponseFormat }\n    ) & { _privateState: PrivateState })\n  | Command\n> {\n  #options: AgentNodeOptions<StructuredResponseFormat, ContextSchema>;\n\n  #runState: Pick<PrivateState, \"runModelCallCount\"> = {\n    runModelCallCount: 0,\n  };\n\n  constructor(\n    options: AgentNodeOptions<StructuredResponseFormat, ContextSchema>\n  ) {\n    super({\n      name: options.name ?? \"model\",\n      func: (input, config) => this.#run(input, config as RunnableConfig),\n    });\n\n    this.#options = options;\n  }\n\n  /**\n   * Returns response format primtivies based on given model and response format provided by the user.\n   *\n   * If the the user selects a tool output:\n   * - return a record of tools to extract structured output from the model's response\n   *\n   * if the the user selects a native schema output or if the model supports JSON schema output:\n   * - return a provider strategy to extract structured output from the model's response\n   *\n   * @param model - The model to get the response format for.\n   * @returns The response format.\n   */\n  #getResponseFormat(\n    model: string | LanguageModelLike\n  ): ResponseFormat | undefined {\n    if (!this.#options.responseFormat) {\n      return undefined;\n    }\n\n    const strategies = transformResponseFormat(\n      this.#options.responseFormat,\n      undefined,\n      model\n    );\n\n    /**\n     * we either define a list of provider strategies or a list of tool strategies\n     */\n    const isProviderStrategy = strategies.every(\n      (format) => format instanceof ProviderStrategy\n    );\n\n    /**\n     * Populate a list of structured tool info.\n     */\n    if (!isProviderStrategy) {\n      return {\n        type: \"tool\",\n        tools: (\n          strategies.filter(\n            (format) => format instanceof ToolStrategy\n          ) as ToolStrategy[]\n        ).reduce((acc, format) => {\n          acc[format.name] = format;\n          return acc;\n        }, {} as Record<string, ToolStrategy>),\n      };\n    }\n\n    return {\n      type: \"native\",\n      /**\n       * there can only be one provider strategy\n       */\n      strategy: strategies[0] as ProviderStrategy,\n    };\n  }\n\n  async #run(\n    state: InternalAgentState<StructuredResponseFormat> &\n      PreHookAnnotation[\"State\"],\n    config: RunnableConfig\n  ) {\n    /**\n     * Check if we just executed a returnDirect tool\n     * If so, we should generate structured response (if needed) and stop\n     */\n    const lastMessage = state.messages.at(-1);\n    if (\n      lastMessage &&\n      ToolMessage.isInstance(lastMessage) &&\n      lastMessage.name &&\n      this.#options.shouldReturnDirect.has(lastMessage.name)\n    ) {\n      /**\n       * return directly without invoking the model again\n       */\n      return { messages: [], _privateState: this.getState()._privateState };\n    }\n\n    const privateState = this.getState()._privateState;\n    const response = await this.#invokeModel(state, config);\n    this.#runState.runModelCallCount++;\n    const _privateState = {\n      ...privateState,\n      threadLevelCallCount: privateState.threadLevelCallCount + 1,\n    };\n\n    /**\n     * if we were able to generate a structured response, return it\n     */\n    if (\"structuredResponse\" in response) {\n      return {\n        messages: [...state.messages, ...(response.messages || [])],\n        structuredResponse: response.structuredResponse,\n        _privateState,\n      };\n    }\n\n    /**\n     * if we need to direct the agent to the model, return the update\n     */\n    if (response instanceof Command) {\n      return response;\n    }\n\n    response.name = this.name;\n    response.lc_kwargs.name = this.name;\n\n    if (this.#areMoreStepsNeeded(state, response)) {\n      return {\n        messages: [\n          new AIMessage({\n            content: \"Sorry, need more steps to process this request.\",\n            name: this.name,\n            id: response.id,\n          }),\n        ],\n        _privateState,\n      };\n    }\n\n    return { messages: [response], _privateState };\n  }\n\n  /**\n   * Derive the model from the options.\n   * @param state - The state of the agent.\n   * @param config - The config of the agent.\n   * @returns The model.\n   */\n  #deriveModel() {\n    if (typeof this.#options.model === \"string\") {\n      return initChatModel(this.#options.model);\n    }\n\n    if (this.#options.model) {\n      return this.#options.model;\n    }\n\n    throw new Error(\"No model option was provided, either via `model` option.\");\n  }\n\n  async #invokeModel(\n    state: InternalAgentState<StructuredResponseFormat> &\n      PreHookAnnotation[\"State\"],\n    config: RunnableConfig,\n    options: {\n      lastMessage?: string;\n    } = {}\n  ): Promise<AIMessage | ResponseHandlerResult<StructuredResponseFormat>> {\n    const model = await this.#deriveModel();\n    const lgConfig = config as LangGraphRunnableConfig;\n\n    /**\n     * Create the base handler that performs the actual model invocation\n     */\n    const baseHandler = async (\n      request: ModelRequest\n    ): Promise<AIMessage | ResponseHandlerResult<StructuredResponseFormat>> => {\n      /**\n       * Check if the LLM already has bound tools and throw if it does.\n       */\n      validateLLMHasNoBoundTools(request.model);\n\n      const structuredResponseFormat = this.#getResponseFormat(request.model);\n      const modelWithTools = await this.#bindTools(\n        request.model,\n        request,\n        structuredResponseFormat\n      );\n\n      let modelInput = this.#getModelInputState(state);\n      modelInput = { ...modelInput, messages: request.messages };\n\n      const signal = mergeAbortSignals(this.#options.signal, config.signal);\n      const invokeConfig = { ...config, signal };\n      const response = (await modelWithTools.invoke(\n        modelInput,\n        invokeConfig\n      )) as AIMessage;\n\n      /**\n       * if the user requests a native schema output, try to parse the response\n       * and return the structured response if it is valid\n       */\n      if (structuredResponseFormat?.type === \"native\") {\n        const structuredResponse =\n          structuredResponseFormat.strategy.parse(response);\n        if (structuredResponse) {\n          return { structuredResponse, messages: [response] };\n        }\n\n        return response;\n      }\n\n      if (!structuredResponseFormat || !response.tool_calls) {\n        return response;\n      }\n\n      const toolCalls = response.tool_calls.filter(\n        (call) => call.name in structuredResponseFormat.tools\n      );\n\n      /**\n       * if there were not structured tool calls, we can return the response\n       */\n      if (toolCalls.length === 0) {\n        return response;\n      }\n\n      /**\n       * if there were multiple structured tool calls, we should throw an error as this\n       * scenario is not defined/supported.\n       */\n      if (toolCalls.length > 1) {\n        return this.#handleMultipleStructuredOutputs(\n          response,\n          toolCalls,\n          structuredResponseFormat\n        );\n      }\n\n      const toolStrategy = structuredResponseFormat.tools[toolCalls[0].name];\n      const toolMessageContent = toolStrategy?.options?.toolMessageContent;\n      return this.#handleSingleStructuredOutput(\n        response,\n        toolCalls[0],\n        structuredResponseFormat,\n        toolMessageContent ?? options.lastMessage\n      );\n    };\n\n    const wrapperMiddleware = this.#options.wrapModelCallHookMiddleware ?? [];\n    let wrappedHandler: (\n      request: ModelRequest<\n        InternalAgentState<StructuredResponseFormat> &\n          PreHookAnnotation[\"State\"],\n        unknown\n      >\n    ) => Promise<InternalModelResponse<StructuredResponseFormat>> = baseHandler;\n\n    /**\n     * Build composed handler from last to first so first middleware becomes outermost\n     */\n    for (let i = wrapperMiddleware.length - 1; i >= 0; i--) {\n      const [middleware, getMiddlewareState] = wrapperMiddleware[i];\n      if (middleware.wrapModelCall) {\n        const innerHandler = wrappedHandler;\n        const currentMiddleware = middleware;\n        const currentGetState = getMiddlewareState;\n\n        wrappedHandler = async (\n          request: ModelRequest<\n            InternalAgentState<StructuredResponseFormat> &\n              PreHookAnnotation[\"State\"],\n            unknown\n          >\n        ): Promise<InternalModelResponse<StructuredResponseFormat>> => {\n          /**\n           * Merge context with default context of middleware\n           */\n          const context = currentMiddleware.contextSchema\n            ? interopParse(\n                currentMiddleware.contextSchema,\n                lgConfig?.context || {}\n              )\n            : lgConfig?.context;\n\n          /**\n           * Create runtime\n           */\n          const privateState = this.getState()._privateState;\n          const runtime: Runtime<unknown> = Object.freeze({\n            ...privateState,\n            context,\n            writer: lgConfig.writer,\n            interrupt: lgConfig.interrupt,\n            signal: lgConfig.signal,\n          });\n\n          /**\n           * Create the request with state and runtime\n           */\n          const requestWithStateAndRuntime: ModelRequest<\n            InternalAgentState<StructuredResponseFormat> &\n              PreHookAnnotation[\"State\"],\n            unknown\n          > = {\n            ...request,\n            state: {\n              ...currentGetState(),\n              messages: state.messages,\n            } as InternalAgentState<StructuredResponseFormat> &\n              PreHookAnnotation[\"State\"],\n            runtime,\n          };\n\n          /**\n           * Create handler that validates tools and calls the inner handler\n           */\n          const handlerWithValidation = async (\n            req: ModelRequest<\n              InternalAgentState<StructuredResponseFormat> &\n                PreHookAnnotation[\"State\"],\n              unknown\n            >\n          ): Promise<InternalModelResponse<StructuredResponseFormat>> => {\n            /**\n             * Verify that the user didn't add any new tools.\n             * We can't allow this as the ToolNode is already initiated with given tools.\n             */\n            const modifiedTools = req.tools ?? [];\n            const newTools = modifiedTools.filter(\n              (tool) =>\n                isClientTool(tool) &&\n                !this.#options.toolClasses.some((t) => t.name === tool.name)\n            );\n            if (newTools.length > 0) {\n              throw new Error(\n                `You have added a new tool in \"wrapModelCall\" hook of middleware \"${\n                  currentMiddleware.name\n                }\": ${newTools\n                  .map((tool) => tool.name)\n                  .join(\", \")}. This is not supported.`\n              );\n            }\n\n            /**\n             * Verify that user has not added or modified a tool with the same name.\n             * We can't allow this as the ToolNode is already initiated with given tools.\n             */\n            const invalidTools = modifiedTools.filter(\n              (tool) =>\n                isClientTool(tool) &&\n                this.#options.toolClasses.every((t) => t !== tool)\n            );\n            if (invalidTools.length > 0) {\n              throw new Error(\n                `You have modified a tool in \"wrapModelCall\" hook of middleware \"${\n                  currentMiddleware.name\n                }\": ${invalidTools\n                  .map((tool) => tool.name)\n                  .join(\", \")}. This is not supported.`\n              );\n            }\n\n            return innerHandler(req);\n          };\n\n          // Call middleware's wrapModelCall with the validation handler\n          if (!currentMiddleware.wrapModelCall) {\n            return handlerWithValidation(requestWithStateAndRuntime);\n          }\n\n          try {\n            const middlewareResponse = await currentMiddleware.wrapModelCall(\n              requestWithStateAndRuntime,\n              handlerWithValidation as WrapModelCallHandler\n            );\n\n            /**\n             * Validate that this specific middleware returned a valid AIMessage\n             */\n            if (!AIMessage.isInstance(middlewareResponse)) {\n              throw new Error(\n                `Invalid response from \"wrapModelCall\" in middleware \"${\n                  currentMiddleware.name\n                }\": expected AIMessage, got ${typeof middlewareResponse}`\n              );\n            }\n\n            return middlewareResponse;\n          } catch (error) {\n            // Add middleware context to error if not already added\n            if (\n              error instanceof Error &&\n              !error.message.includes(`middleware \"${currentMiddleware.name}\"`)\n            ) {\n              error.message = `Error in middleware \"${currentMiddleware.name}\": ${error.message}`;\n            }\n            throw error;\n          }\n        };\n      }\n    }\n\n    /**\n     * Execute the wrapped handler with the initial request\n     */\n    const initialRequest: ModelRequest<\n      InternalAgentState<StructuredResponseFormat> & PreHookAnnotation[\"State\"],\n      unknown\n    > = {\n      model,\n      systemPrompt: this.#options.systemPrompt,\n      messages: state.messages,\n      tools: this.#options.toolClasses,\n      state: {\n        messages: state.messages,\n      } as InternalAgentState<StructuredResponseFormat> &\n        PreHookAnnotation[\"State\"],\n      runtime: Object.freeze({\n        ...this.getState()._privateState,\n        context: lgConfig?.context,\n        writer: lgConfig.writer,\n        interrupt: lgConfig.interrupt,\n        signal: lgConfig.signal,\n      }) as Runtime<unknown>,\n    };\n\n    return wrappedHandler(initialRequest);\n  }\n\n  /**\n   * If the model returns multiple structured outputs, we need to handle it.\n   * @param response - The response from the model\n   * @param toolCalls - The tool calls that were made\n   * @returns The response from the model\n   */\n  #handleMultipleStructuredOutputs(\n    response: AIMessage,\n    toolCalls: ToolCall[],\n    responseFormat: ToolResponseFormat\n  ): Promise<Command> {\n    const multipleStructuredOutputsError = new MultipleStructuredOutputsError(\n      toolCalls.map((call) => call.name)\n    );\n\n    return this.#handleToolStrategyError(\n      multipleStructuredOutputsError,\n      response,\n      toolCalls[0],\n      responseFormat\n    );\n  }\n\n  /**\n   * If the model returns a single structured output, we need to handle it.\n   * @param toolCall - The tool call that was made\n   * @returns The structured response and a message to the LLM if needed\n   */\n  #handleSingleStructuredOutput(\n    response: AIMessage,\n    toolCall: ToolCall,\n    responseFormat: ToolResponseFormat,\n    lastMessage?: string\n  ): ResponseHandlerResult<StructuredResponseFormat> {\n    const tool = responseFormat.tools[toolCall.name];\n\n    try {\n      const structuredResponse = tool.parse(\n        toolCall.args\n      ) as StructuredResponseFormat;\n\n      return {\n        structuredResponse,\n        messages: [\n          response,\n          new AIMessage(\n            lastMessage ??\n              `Returning structured response: ${JSON.stringify(\n                structuredResponse\n              )}`\n          ),\n        ],\n      };\n    } catch (error) {\n      return this.#handleToolStrategyError(\n        error as ToolStrategyError,\n        response,\n        toolCall,\n        responseFormat\n      );\n    }\n  }\n\n  async #handleToolStrategyError(\n    error: ToolStrategyError,\n    response: AIMessage,\n    toolCall: ToolCall,\n    responseFormat: ToolResponseFormat\n  ): Promise<Command> {\n    /**\n     * Using the `errorHandler` option of the first `ToolStrategy` entry is sufficient here.\n     * There is technically only one `ToolStrategy` entry in `structuredToolInfo` if the user\n     * uses `toolStrategy` to define the response format. If the user applies a list of json\n     * schema objects, these will be transformed into multiple `ToolStrategy` entries but all\n     * with the same `handleError` option.\n     */\n    const errorHandler = Object.values(responseFormat.tools).at(0)?.options\n      ?.handleError;\n\n    const toolCallId = toolCall.id;\n    if (!toolCallId) {\n      throw new Error(\n        \"Tool call ID is required to handle tool output errors. Please provide a tool call ID.\"\n      );\n    }\n\n    /**\n     * retry if:\n     */\n    if (\n      /**\n       * if the user has provided `true` as the `errorHandler` option, return a new AIMessage\n       * with the error message and retry the tool call.\n       */\n      (typeof errorHandler === \"boolean\" && errorHandler) ||\n      /**\n       * if `errorHandler` is an array and contains MultipleStructuredOutputsError\n       */\n      (Array.isArray(errorHandler) &&\n        errorHandler.some((h) => h instanceof MultipleStructuredOutputsError))\n    ) {\n      return new Command({\n        update: {\n          messages: [\n            response,\n            new ToolMessage({\n              content: error.message,\n              tool_call_id: toolCallId,\n            }),\n          ],\n        },\n        goto: \"model\",\n      });\n    }\n\n    /**\n     * if `errorHandler` is a string, retry the tool call with given string\n     */\n    if (typeof errorHandler === \"string\") {\n      return new Command({\n        update: {\n          messages: [\n            response,\n            new ToolMessage({\n              content: errorHandler,\n              tool_call_id: toolCallId,\n            }),\n          ],\n        },\n        goto: \"model\",\n      });\n    }\n\n    /**\n     * if `errorHandler` is a function, retry the tool call with the function\n     */\n    if (typeof errorHandler === \"function\") {\n      const content = await errorHandler(error);\n      if (typeof content !== \"string\") {\n        throw new Error(\"Error handler must return a string.\");\n      }\n\n      return new Command({\n        update: {\n          messages: [\n            response,\n            new ToolMessage({\n              content,\n              tool_call_id: toolCallId,\n            }),\n          ],\n        },\n        goto: \"model\",\n      });\n    }\n\n    /**\n     * throw otherwise, e.g. if `errorHandler` is not defined or set to `false`\n     */\n    throw error;\n  }\n\n  #areMoreStepsNeeded(\n    state: InternalAgentState<StructuredResponseFormat> &\n      PreHookAnnotation[\"State\"],\n    response: BaseMessage\n  ): boolean {\n    const allToolsReturnDirect =\n      AIMessage.isInstance(response) &&\n      response.tool_calls?.every((call) =>\n        this.#options.shouldReturnDirect.has(call.name)\n      );\n    const remainingSteps =\n      \"remainingSteps\" in state ? (state.remainingSteps as number) : undefined;\n    return Boolean(\n      remainingSteps &&\n        ((remainingSteps < 1 && allToolsReturnDirect) ||\n          (remainingSteps < 2 && hasToolCalls(state.messages.at(-1))))\n    );\n  }\n\n  #getModelInputState(\n    state: InternalAgentState<StructuredResponseFormat> &\n      PreHookAnnotation[\"State\"]\n  ): Omit<InternalAgentState<StructuredResponseFormat>, \"llmInputMessages\"> {\n    const { messages, llmInputMessages, ...rest } = state;\n    if (llmInputMessages && llmInputMessages.length > 0) {\n      return { messages: llmInputMessages, ...rest } as Omit<\n        InternalAgentState<StructuredResponseFormat>,\n        \"llmInputMessages\"\n      >;\n    }\n    return { messages, ...rest } as Omit<\n      InternalAgentState<StructuredResponseFormat>,\n      \"llmInputMessages\"\n    >;\n  }\n\n  async #bindTools(\n    model: LanguageModelLike,\n    preparedOptions: ModelRequest | undefined,\n    structuredResponseFormat: ResponseFormat | undefined\n  ): Promise<Runnable> {\n    const options: Partial<BaseChatModelCallOptions> = {};\n    const structuredTools = Object.values(\n      structuredResponseFormat && \"tools\" in structuredResponseFormat\n        ? structuredResponseFormat.tools\n        : {}\n    );\n\n    /**\n     * Use tools from preparedOptions if provided, otherwise use default tools\n     */\n    const allTools = [\n      ...(preparedOptions?.tools ?? this.#options.toolClasses),\n      ...structuredTools.map((toolStrategy) => toolStrategy.tool),\n    ];\n\n    /**\n     * If there are structured tools, we need to set the tool choice to \"any\"\n     * so that the model can choose to use a structured tool or not.\n     */\n    const toolChoice =\n      preparedOptions?.toolChoice ||\n      (structuredTools.length > 0 ? \"any\" : undefined);\n\n    /**\n     * check if the user requests a native schema output\n     */\n    if (structuredResponseFormat?.type === \"native\") {\n      /**\n       * if the model does not support JSON schema output, throw an error\n       */\n      if (!hasSupportForJsonSchemaOutput(model)) {\n        throw new Error(\n          \"Model does not support native structured output responses. Please use a model that supports native structured output responses or use a tool output.\"\n        );\n      }\n\n      const jsonSchemaParams = {\n        name: structuredResponseFormat.strategy.schema?.name ?? \"extract\",\n        description: getSchemaDescription(\n          structuredResponseFormat.strategy.schema\n        ),\n        schema: structuredResponseFormat.strategy.schema,\n        strict: true,\n      };\n\n      Object.assign(options, {\n        response_format: {\n          type: \"json_schema\",\n          json_schema: jsonSchemaParams,\n        },\n        ls_structured_output_format: {\n          kwargs: { method: \"json_schema\" },\n          schema: structuredResponseFormat.strategy.schema,\n        },\n        strict: true,\n      });\n    }\n\n    /**\n     * Bind tools to the model if they are not already bound.\n     */\n    const modelWithTools = await bindTools(model, allTools, {\n      ...options,\n      ...(preparedOptions?.modelSettings ?? {}),\n      tool_choice: toolChoice,\n    });\n\n    /**\n     * Create a model runnable with the prompt and agent name\n     */\n    const modelRunnable = getPromptRunnable(\n      preparedOptions?.systemPrompt ?? this.#options.systemPrompt\n    ).pipe(\n      this.#options.includeAgentName === \"inline\"\n        ? withAgentName(modelWithTools, this.#options.includeAgentName)\n        : modelWithTools\n    );\n\n    return modelRunnable;\n  }\n\n  static get nodeOptions(): {\n    input: z.ZodObject<{\n      messages: z.ZodArray<z.ZodType<BaseMessage>>;\n      _privateState: z.ZodObject<{\n        threadLevelCallCount: z.ZodNumber;\n      }>;\n    }>;\n  } {\n    return {\n      input: z.object({\n        messages: z.array(z.custom<BaseMessage>()),\n        _privateState: z.object({\n          threadLevelCallCount: z.number(),\n        }),\n      }),\n    };\n  }\n\n  getState(): {\n    messages: BaseMessage[];\n    _privateState: PrivateState;\n  } {\n    const state = super.getState();\n    const origState =\n      state && !(state instanceof Command)\n        ? state\n        : ({\n            _privateState: {\n              threadLevelCallCount: 0,\n              runModelCallCount: 0,\n            },\n          } as {\n            messages?: BaseMessage[];\n            _privateState?: PrivateState;\n          });\n\n    return {\n      messages: [],\n      ...origState,\n      _privateState: {\n        threadLevelCallCount: 0,\n        ...(origState._privateState ?? {}),\n        ...this.#runState,\n      },\n    };\n  }\n}\n"],"mappings":"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"}