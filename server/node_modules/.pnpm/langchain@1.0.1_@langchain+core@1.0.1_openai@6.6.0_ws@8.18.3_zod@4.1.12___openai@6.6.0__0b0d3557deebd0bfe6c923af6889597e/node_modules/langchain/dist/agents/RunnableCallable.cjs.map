{"version":3,"file":"RunnableCallable.cjs","names":["Runnable","fields: RunnableCallableArgs<I, O>","#state","state: Awaited<O>","input: I","options?: Partial<RunnableConfig> | undefined","AsyncLocalStorageProviderSingleton"],"sources":["../../src/agents/RunnableCallable.ts"],"sourcesContent":["import {\n  mergeConfigs,\n  Runnable,\n  RunnableConfig,\n} from \"@langchain/core/runnables\";\nimport { AsyncLocalStorageProviderSingleton } from \"@langchain/core/singletons\";\n\nexport interface RunnableCallableArgs<I, O> {\n  /**\n   * The name of the runnable.\n   */\n  name?: string;\n  /**\n   * The function to call.\n   */\n  func: (...args: I[]) => O | Promise<O>;\n  /**\n   * The tags to add to the runnable.\n   */\n  tags?: string[];\n  /**\n   * Whether to recurse the runnable.\n   */\n  recurse?: boolean;\n}\n\nexport class RunnableCallable<I = unknown, O = unknown> extends Runnable<I, O> {\n  lc_namespace: string[] = [\"langgraph\"];\n\n  func: RunnableCallableArgs<I, O>[\"func\"];\n\n  tags?: RunnableCallableArgs<I, O>[\"tags\"];\n\n  config?: RunnableConfig;\n\n  trace = true;\n\n  recurse = true;\n\n  #state: Awaited<O>;\n\n  constructor(fields: RunnableCallableArgs<I, O>) {\n    super();\n    this.name = fields.name ?? fields.func.name;\n    this.func = fields.func;\n    this.config = fields.tags ? { tags: fields.tags } : undefined;\n    this.recurse = fields.recurse ?? this.recurse;\n  }\n\n  getState(): Awaited<O> {\n    return this.#state;\n  }\n\n  /**\n   * This allows us to set the state of the runnable, e.g. for model and middleware nodes.\n   * @internal\n   */\n  setState(state: Awaited<O>) {\n    this.#state = {\n      ...this.#state,\n      ...state,\n    };\n  }\n\n  async invoke(\n    input: I,\n    options?: Partial<RunnableConfig> | undefined\n  ): Promise<O> {\n    const mergedConfig = mergeConfigs(this.config, options);\n\n    const returnValue = await AsyncLocalStorageProviderSingleton.runWithConfig(\n      mergedConfig,\n      async () => this.func(input, mergedConfig as I)\n    );\n\n    if (Runnable.isRunnable(returnValue) && this.recurse) {\n      return await AsyncLocalStorageProviderSingleton.runWithConfig(\n        mergedConfig,\n        async () => (returnValue as Runnable<I, O>).invoke(input, mergedConfig)\n      );\n    }\n\n    this.#state = returnValue;\n    return returnValue;\n  }\n}\n"],"mappings":";;;;;AA0BA,IAAa,mBAAb,cAAgEA,oCAAe;CAC7E,eAAyB,CAAC,WAAY;CAEtC;CAEA;CAEA;CAEA,QAAQ;CAER,UAAU;CAEV;CAEA,YAAYC,QAAoC;EAC9C,OAAO;EACP,KAAK,OAAO,OAAO,QAAQ,OAAO,KAAK;EACvC,KAAK,OAAO,OAAO;EACnB,KAAK,SAAS,OAAO,OAAO,EAAE,MAAM,OAAO,KAAM,IAAG;EACpD,KAAK,UAAU,OAAO,WAAW,KAAK;CACvC;CAED,WAAuB;AACrB,SAAO,KAAKC;CACb;;;;;CAMD,SAASC,OAAmB;EAC1B,KAAKD,SAAS;GACZ,GAAG,KAAKA;GACR,GAAG;EACJ;CACF;CAED,MAAM,OACJE,OACAC,SACY;EACZ,MAAM,4DAA4B,KAAK,QAAQ,QAAQ;EAEvD,MAAM,cAAc,MAAMC,+DAAmC,cAC3D,cACA,YAAY,KAAK,KAAK,OAAO,aAAkB,CAChD;AAED,MAAIN,oCAAS,WAAW,YAAY,IAAI,KAAK,QAC3C,QAAO,MAAMM,+DAAmC,cAC9C,cACA,YAAa,YAA+B,OAAO,OAAO,aAAa,CACxE;EAGH,KAAKJ,SAAS;AACd,SAAO;CACR;AACF"}