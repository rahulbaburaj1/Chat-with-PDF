{"version":3,"file":"middleware.d.cts","names":["InteropZodObject","InteropZodDefault","InteropZodOptional","InferInteropZodOutput","ClientTool","ServerTool","AgentMiddleware","WrapToolCallHook","WrapModelCallHook","BeforeAgentHook","BeforeModelHook","AfterModelHook","AfterAgentHook","createMiddleware","TSchema","TContextSchema","NormalizeContextSchema","Partial"],"sources":["../../src/agents/middleware.d.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { InteropZodObject, InteropZodDefault, InteropZodOptional, InferInteropZodOutput } from \"@langchain/core/utils/types\";\nimport type { ClientTool, ServerTool } from \"./tools.js\";\nimport type { AgentMiddleware, WrapToolCallHook, WrapModelCallHook, BeforeAgentHook, BeforeModelHook, AfterModelHook, AfterAgentHook } from \"./middleware/types.js\";\n/**\n * Creates a middleware instance with automatic schema inference.\n *\n * @param config - Middleware configuration\n * @param config.name - The name of the middleware\n * @param config.stateSchema - The schema of the middleware state\n * @param config.contextSchema - The schema of the middleware context\n * @param config.wrapModelCall - The function to wrap model invocation\n * @param config.wrapToolCall - The function to wrap tool invocation\n * @param config.beforeModel - The function to run before the model call\n * @param config.afterModel - The function to run after the model call\n * @param config.beforeAgent - The function to run before the agent execution starts\n * @param config.afterAgent - The function to run after the agent execution completes\n * @returns A middleware instance\n *\n * @example\n * ```ts\n * const authMiddleware = createMiddleware({\n *   name: \"AuthMiddleware\",\n *   stateSchema: z.object({\n *     isAuthenticated: z.boolean().default(false),\n *   }),\n *   contextSchema: z.object({\n *     userId: z.string(),\n *   }),\n *   beforeModel: async (state, runtime, controls) => {\n *     if (!state.isAuthenticated) {\n *       return controls.terminate(new Error(\"Not authenticated\"));\n *     }\n *   },\n * });\n * ```\n */\nexport declare function createMiddleware<TSchema extends InteropZodObject | undefined = undefined, TContextSchema extends InteropZodObject | InteropZodOptional<InteropZodObject> | InteropZodDefault<InteropZodObject> | undefined = undefined>(config: {\n    /**\n     * The name of the middleware\n     */\n    name: string;\n    /**\n     * The schema of the middleware state. Middleware state is persisted between multiple invocations. It can be either:\n     * - A Zod object\n     * - A Zod optional object\n     * - A Zod default object\n     * - Undefined\n     */\n    stateSchema?: TSchema;\n    /**\n     * The schema of the middleware context. Middleware context is read-only and not persisted between multiple invocations. It can be either:\n     * - A Zod object\n     * - A Zod optional object\n     * - A Zod default object\n     * - Undefined\n     */\n    contextSchema?: TContextSchema;\n    /**\n     * Additional tools registered by the middleware.\n     */\n    tools?: (ClientTool | ServerTool)[];\n    /**\n     * Wraps tool execution with custom logic. This allows you to:\n     * - Modify tool call parameters before execution\n     * - Handle errors and retry with different parameters\n     * - Post-process tool results\n     * - Implement caching, logging, authentication, or other cross-cutting concerns\n     * - Return Command objects for advanced control flow\n     *\n     * The handler receives a ToolCallRequest containing the tool call, state, and runtime,\n     * along with a handler function to execute the actual tool.\n     *\n     * @param request - The tool call request containing toolCall, state, and runtime.\n     * @param handler - The function that executes the tool. Call this with a ToolCallRequest to get the result.\n     * @returns The tool result as a ToolMessage or a Command for advanced control flow.\n     *\n     * @example\n     * ```ts\n     * wrapToolCall: async (request, handler) => {\n     *   console.log(`Calling tool: ${request.tool.name}`);\n     *   console.log(`Tool description: ${request.tool.description}`);\n     *\n     *   try {\n     *     // Execute the tool\n     *     const result = await handler(request);\n     *     console.log(`Tool ${request.tool.name} succeeded`);\n     *     return result;\n     *   } catch (error) {\n     *     console.error(`Tool ${request.tool.name} failed:`, error);\n     *     // Could return a custom error message or retry\n     *     throw error;\n     *   }\n     * }\n     * ```\n     *\n     * @example Authentication\n     * ```ts\n     * wrapToolCall: async (request, handler) => {\n     *   // Check if user is authorized for this tool\n     *   if (!request.runtime.context.isAuthorized(request.tool.name)) {\n     *     return new ToolMessage({\n     *       content: \"Unauthorized to call this tool\",\n     *       tool_call_id: request.toolCall.id,\n     *     });\n     *   }\n     *   return handler(request);\n     * }\n     * ```\n     */\n    wrapToolCall?: WrapToolCallHook<TSchema, NormalizeContextSchema<TContextSchema>>;\n    /**\n     * Wraps the model invocation with custom logic. This allows you to:\n     * - Modify the request before calling the model\n     * - Handle errors and retry with different parameters\n     * - Post-process the response\n     * - Implement custom caching, logging, or other cross-cutting concerns\n     *\n     * The request parameter contains: model, messages, systemPrompt, tools, state, and runtime.\n     *\n     * @param request - The model request containing all the parameters needed.\n     * @param handler - The function that invokes the model. Call this with a ModelRequest to get the response.\n     * @returns The response from the model (or a modified version).\n     *\n     * @example\n     * ```ts\n     * wrapModelCall: async (request, handler) => {\n     *   // Modify request before calling\n     *   const modifiedRequest = { ...request, systemPrompt: \"You are helpful\" };\n     *\n     *   try {\n     *     // Call the model\n     *     return await handler(modifiedRequest);\n     *   } catch (error) {\n     *     // Handle errors and retry with fallback\n     *     const fallbackRequest = { ...request, model: fallbackModel };\n     *     return await handler(fallbackRequest);\n     *   }\n     * }\n     * ```\n     */\n    wrapModelCall?: WrapModelCallHook<TSchema, NormalizeContextSchema<TContextSchema>>;\n    /**\n     * The function to run before the agent execution starts. This function is called once at the start of the agent invocation.\n     * It allows to modify the state of the agent before any model calls or tool executions.\n     *\n     * @param state - The middleware state\n     * @param runtime - The middleware runtime\n     * @returns The modified middleware state or undefined to pass through\n     */\n    beforeAgent?: BeforeAgentHook<TSchema, NormalizeContextSchema<TContextSchema>>;\n    /**\n     * The function to run before the model call. This function is called before the model is invoked and before the `wrapModelCall` hook.\n     * It allows to modify the state of the agent.\n     *\n     * @param state - The middleware state\n     * @param runtime - The middleware runtime\n     * @returns The modified middleware state or undefined to pass through\n     */\n    beforeModel?: BeforeModelHook<TSchema, NormalizeContextSchema<TContextSchema>>;\n    /**\n     * The function to run after the model call. This function is called after the model is invoked and before any tools are called.\n     * It allows to modify the state of the agent after the model is invoked, e.g. to update tool call parameters.\n     *\n     * @param state - The middleware state\n     * @param runtime - The middleware runtime\n     * @returns The modified middleware state or undefined to pass through\n     */\n    afterModel?: AfterModelHook<TSchema, NormalizeContextSchema<TContextSchema>>;\n    /**\n     * The function to run after the agent execution completes. This function is called once at the end of the agent invocation.\n     * It allows to modify the final state of the agent after all model calls and tool executions are complete.\n     *\n     * @param state - The middleware state\n     * @param runtime - The middleware runtime\n     * @returns The modified middleware state or undefined to pass through\n     */\n    afterAgent?: AfterAgentHook<TSchema, NormalizeContextSchema<TContextSchema>>;\n}): AgentMiddleware<TSchema, TContextSchema, any>;\ntype NormalizeContextSchema<TContextSchema extends InteropZodObject | InteropZodOptional<InteropZodObject> | InteropZodDefault<InteropZodObject> | undefined = undefined> = TContextSchema extends InteropZodObject ? InferInteropZodOutput<TContextSchema> : TContextSchema extends InteropZodDefault<any> ? InferInteropZodOutput<TContextSchema> : TContextSchema extends InteropZodOptional<any> ? Partial<InferInteropZodOutput<TContextSchema>> : never;\nexport {};\n"],"mappings":";;;;;;;AAqCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4IgCc,iBA5IRD,gBA4IQC,CAAAA,gBA5IyBd,gBA4IzBc,GAAAA,SAAAA,GAAAA,SAAAA,EAAAA,uBA5I0Fd,gBA4I1Fc,GA5I6GZ,kBA4I7GY,CA5IgId,gBA4IhIc,CAAAA,GA5IoJb,iBA4IpJa,CA5IsKd,gBA4ItKc,CAAAA,GAAAA,SAAAA,GAAAA,SAAAA,CAAAA,CAAAA,MAAAA,EAAAA;EAAO;;;EAAR,IACXA,EAAAA,MAAAA;EAAO;;AAAR;AAA+B;;;;EACuD,WAAnCZ,CAAAA,EAlIpDY,OAkIoDZ;EAAkB;;;;;;;EAAoL,aAASD,CAAAA,EA1HjQc,cA0HiQd;EAAiB;;;EAA8D,KAASC,CAAAA,EAAAA,CAtHhWE,UAsHgWF,GAtHnVG,UAsHmVH,CAAAA,EAAAA;EAAkB;;;AAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBArE3XK,iBAAiBO,SAASE,uBAAuBD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kBA+BhDP,kBAAkBM,SAASE,uBAAuBD;;;;;;;;;gBASpDN,gBAAgBK,SAASE,uBAAuBD;;;;;;;;;gBAShDL,gBAAgBI,SAASE,uBAAuBD;;;;;;;;;eASjDJ,eAAeG,SAASE,uBAAuBD;;;;;;;;;eAS/CH,eAAeE,SAASE,uBAAuBD;IAC5DT,gBAAgBQ,SAASC;KACxBC,8CAA8ChB,mBAAmBE,mBAAmBF,oBAAoBC,kBAAkBD,6CAA6Ce,uBAAuBf,mBAAmBG,sBAAsBY,kBAAkBA,uBAAuBd,yBAAyBE,sBAAsBY,kBAAkBA,uBAAuBb,0BAA0Be,QAAQd,sBAAsBY"}