{"version":3,"file":"types.d.ts","names":["InteropZodObject","InteropZodType","START","END","StateGraph","LanguageModelLike","BaseMessage","BaseCheckpointSaver","BaseStore","Messages","ResponseFormat","ToolStrategy","TypedToolStrategy","ProviderStrategy","JsonSchemaFormat","ResponseFormatUndefined","AgentMiddleware","AnyAnnotationRoot","InferSchemaInput","ServerTool","ClientTool","JumpToTarget","N","Interrupt","TValue","BuiltInState","UserInput","TStateSchema","ToolCall","Record","ToolResult","JumpTo","ExecutedToolCall","CreateAgentParams","StructuredResponseType","StateSchema","ContextSchema","ResponseFormatType","AbortSignal","ExtractZodArrayTypes","T","Rest","A","WithStateGraphNodes","Graph","SD","S","U","K","I","O","C"],"sources":["../../src/agents/types.d.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { InteropZodObject, InteropZodType } from \"@langchain/core/utils/types\";\nimport type { START, END, StateGraph } from \"@langchain/langgraph\";\nimport type { LanguageModelLike } from \"@langchain/core/language_models/base\";\nimport type { BaseMessage } from \"@langchain/core/messages\";\nimport type { BaseCheckpointSaver, BaseStore } from \"@langchain/langgraph-checkpoint\";\nimport type { Messages } from \"@langchain/langgraph/\";\nimport type { ResponseFormat, ToolStrategy, TypedToolStrategy, ProviderStrategy, JsonSchemaFormat, ResponseFormatUndefined } from \"./responses.js\";\nimport type { AgentMiddleware, AnyAnnotationRoot, InferSchemaInput } from \"./middleware/types.js\";\nimport type { ServerTool, ClientTool } from \"./tools.js\";\nimport type { JumpToTarget } from \"./constants.js\";\nexport type N = typeof START | \"model_request\" | \"tools\";\n/**\n * Represents information about an interrupt.\n */\nexport interface Interrupt<TValue = unknown> {\n    /**\n     * The ID of the interrupt.\n     */\n    id: string;\n    /**\n     * The requests for human input.\n     */\n    value: TValue;\n}\nexport interface BuiltInState {\n    messages: BaseMessage[];\n    __interrupt__?: Interrupt[];\n    /**\n     * Optional property to control routing after afterModel middleware execution.\n     * When set by middleware, the agent will jump to the specified node instead of\n     * following normal routing logic. The property is automatically cleared after use.\n     *\n     * - \"model_request\": Jump back to the model for another LLM call\n     * - \"tools\": Jump to tool execution (requires tools to be available)\n     */\n    jumpTo?: JumpToTarget;\n}\n/**\n * Base input type for `.invoke` and `.stream` methods.\n */\nexport type UserInput<TStateSchema extends AnyAnnotationRoot | InteropZodObject | undefined = undefined> = InferSchemaInput<TStateSchema> & {\n    messages: Messages;\n};\n/**\n * Information about a tool call that has been executed.\n */\nexport interface ToolCall {\n    /**\n     * The ID of the tool call.\n     */\n    id: string;\n    /**\n     * The name of the tool that was called.\n     */\n    name: string;\n    /**\n     * The arguments that were passed to the tool.\n     */\n    args: Record<string, any>;\n    /**\n     * The result of the tool call.\n     */\n    result?: unknown;\n    /**\n     * An optional error message if the tool call failed.\n     */\n    error?: string;\n}\n/**\n * Information about a tool result from a tool execution.\n */\nexport interface ToolResult {\n    /**\n     * The ID of the tool call.\n     */\n    id: string;\n    /**\n     * The result of the tool call.\n     */\n    result: any;\n    /**\n     * An optional error message if the tool call failed.\n     */\n    error?: string;\n}\n/**\n * jump targets (internal)\n */\nexport type JumpTo = \"model_request\" | \"tools\" | typeof END;\n/**\n * Information about a tool call that has been executed.\n */\nexport interface ExecutedToolCall {\n    /**\n     * The name of the tool that was called.\n     */\n    name: string;\n    /**\n     * The arguments that were passed to the tool.\n     */\n    args: Record<string, unknown>;\n    /**\n     * The ID of the tool call.\n     */\n    tool_id: string;\n    /**\n     * The result of the tool call (if available).\n     */\n    result?: unknown;\n}\nexport type CreateAgentParams<StructuredResponseType extends Record<string, any> = Record<string, any>, StateSchema extends AnyAnnotationRoot | InteropZodObject | undefined = undefined, ContextSchema extends AnyAnnotationRoot | InteropZodObject = AnyAnnotationRoot, ResponseFormatType = InteropZodType<StructuredResponseType> | InteropZodType<unknown>[] | JsonSchemaFormat | JsonSchemaFormat[] | ResponseFormat | TypedToolStrategy<StructuredResponseType> | ToolStrategy<StructuredResponseType> | ProviderStrategy<StructuredResponseType> | ResponseFormatUndefined> = {\n    /**\n     * Defines a model to use for the agent. You can either pass in an instance of a LangChain chat model\n     * or a string. If a string is provided the agent initializes a ChatModel based on the provided model name and provider.\n     * It supports various model providers and allows for runtime configuration of model parameters.\n     *\n     * @uses {@link initChatModel}\n     * @example\n     * ```ts\n     * const agent = createAgent({\n     *   model: \"anthropic:claude-3-7-sonnet-latest\",\n     *   // ...\n     * });\n     * ```\n     *\n     * @example\n     * ```ts\n     * import { ChatOpenAI } from \"@langchain/openai\";\n     * const agent = createAgent({\n     *   model: new ChatOpenAI({ model: \"gpt-4o\" }),\n     *   // ...\n     * });\n     * ```\n     */\n    model: string | LanguageModelLike;\n    /**\n     * A list of tools or a ToolNode.\n     *\n     * @example\n     * ```ts\n     * import { tool } from \"langchain\";\n     *\n     * const weatherTool = tool(() => \"Sunny!\", {\n     *   name: \"get_weather\",\n     *   description: \"Get the weather for a location\",\n     *   schema: z.object({\n     *     location: z.string().describe(\"The location to get weather for\"),\n     *   }),\n     * });\n     *\n     * const agent = createAgent({\n     *   tools: [weatherTool],\n     *   // ...\n     * });\n     * ```\n     */\n    tools?: (ServerTool | ClientTool)[];\n    /**\n     * An optional system message for the model.\n     */\n    systemPrompt?: string;\n    /**\n     * An optional schema for the agent state. It allows you to define custom state properties that persist\n     * across agent invocations and can be accessed in hooks, middleware, and throughout the agent's execution.\n     * The state is persisted when using a checkpointer and can be updated by middleware or during execution.\n     *\n     * As opposed to the context (defined in `contextSchema`), the state is persisted between agent invocations\n     * when using a checkpointer, making it suitable for maintaining conversation history, user preferences,\n     * or any other data that should persist across multiple interactions.\n     *\n     * @example\n     * ```ts\n     * import { z } from \"zod\";\n     * import { createAgent } from \"@langchain/langgraph\";\n     *\n     * const agent = createAgent({\n     *   model: \"openai:gpt-4o\",\n     *   tools: [getWeather],\n     *   stateSchema: z.object({\n     *     userPreferences: z.object({\n     *       temperatureUnit: z.enum([\"celsius\", \"fahrenheit\"]).default(\"celsius\"),\n     *       location: z.string().optional(),\n     *     }).optional(),\n     *     conversationCount: z.number().default(0),\n     *   }),\n     *   prompt: (state, config) => {\n     *     const unit = state.userPreferences?.temperatureUnit || \"celsius\";\n     *     return [\n     *       new SystemMessage(`You are a helpful assistant. Use ${unit} for temperature.`),\n     *     ];\n     *   },\n     * });\n     *\n     * const result = await agent.invoke({\n     *   messages: [\n     *     new HumanMessage(\"What's the weather like?\"),\n     *   ],\n     *   userPreferences: {\n     *     temperatureUnit: \"fahrenheit\",\n     *     location: \"New York\",\n     *   },\n     *   conversationCount: 1,\n     * });\n     * ```\n     */\n    stateSchema?: StateSchema;\n    /**\n     * An optional schema for the context. It allows to pass in a typed context object into the agent\n     * invocation and allows to access it in hooks such as `prompt` and middleware.\n     * As opposed to the agent state, defined in `stateSchema`, the context is not persisted between\n     * agent invocations.\n     *\n     * @example\n     * ```ts\n     * const agent = createAgent({\n     *   llm: model,\n     *   tools: [getWeather],\n     *   contextSchema: z.object({\n     *     capital: z.string(),\n     *   }),\n     *   prompt: (state, config) => {\n     *     return [\n     *       new SystemMessage(`You are a helpful assistant. The capital of France is ${config.context.capital}.`),\n     *     ];\n     *   },\n     * });\n     *\n     * const result = await agent.invoke({\n     *   messages: [\n     *     new SystemMessage(\"You are a helpful assistant.\"),\n     *     new HumanMessage(\"What is the capital of France?\"),\n     *   ],\n     * }, {\n     *   context: {\n     *     capital: \"Paris\",\n     *   },\n     * });\n     * ```\n     */\n    contextSchema?: ContextSchema;\n    /**\n     * An optional checkpoint saver to persist the agent's state.\n     * @see {@link https://docs.langchain.com/oss/javascript/langgraph/persistence | Checkpointing}\n     */\n    checkpointer?: BaseCheckpointSaver | boolean;\n    /**\n     * An optional store to persist the agent's state.\n     * @see {@link https://docs.langchain.com/oss/javascript/langgraph/memory#memory-storage | Long-term memory}\n     */\n    store?: BaseStore;\n    /**\n     * An optional schema for the final agent output.\n     *\n     * If provided, output will be formatted to match the given schema and returned in the 'structuredResponse' state key.\n     * If not provided, `structuredResponse` will not be present in the output state.\n     *\n     * Can be passed in as:\n     *   - Zod schema\n     *     ```ts\n     *     const agent = createAgent({\n     *       responseFormat: z.object({\n     *         capital: z.string(),\n     *       }),\n     *       // ...\n     *     });\n     *     ```\n     *   - JSON schema\n     *     ```ts\n     *     const agent = createAgent({\n     *       responseFormat: {\n     *         type: \"json_schema\",\n     *         schema: {\n     *           type: \"object\",\n     *           properties: {\n     *             capital: { type: \"string\" },\n     *           },\n     *           required: [\"capital\"],\n     *         },\n     *       },\n     *       // ...\n     *     });\n     *     ```\n     *   - Create React Agent ResponseFormat\n     *     ```ts\n     *     import { providerStrategy, toolStrategy } from \"langchain\";\n     *     const agent = createAgent({\n     *       responseFormat: providerStrategy(\n     *         z.object({\n     *           capital: z.string(),\n     *         })\n     *       ),\n     *       // or\n     *       responseFormat: [\n     *         toolStrategy({ ... }),\n     *         toolStrategy({ ... }),\n     *       ]\n     *       // ...\n     *     });\n     *     ```\n     *\n     * **Note**: The graph will make a separate call to the LLM to generate the structured response after the agent loop is finished.\n     * This is not the only strategy to get structured responses, see more options in [this guide](https://langchain-ai.github.io/langgraph/how-tos/react-agent-structured-output/).\n     */\n    responseFormat?: ResponseFormatType;\n    /**\n     * Middleware instances to run during agent execution.\n     * Each middleware can define its own state schema and hook into the agent lifecycle.\n     *\n     * @see {@link https://docs.langchain.com/oss/javascript/langchain/middleware | Middleware}\n     */\n    middleware?: readonly AgentMiddleware<any, any, any>[];\n    /**\n     * An optional name for the agent.\n     */\n    name?: string;\n    /**\n     * An optional description for the agent.\n     * This can be used to describe the agent to the underlying supervisor LLM.\n     */\n    description?: string;\n    /**\n     * Use to specify how to expose the agent name to the underlying supervisor LLM.\n     *   - `undefined`: Relies on the LLM provider {@link AIMessage#name}. Currently, only OpenAI supports this.\n     *   - `\"inline\"`: Add the agent name directly into the content field of the {@link AIMessage} using XML-style tags.\n     *       Example: `\"How can I help you\"` -> `\"<name>agent_name</name><content>How can I help you?</content>\"`\n     */\n    includeAgentName?: \"inline\" | undefined;\n    /**\n     * An optional abort signal that indicates that the overall operation should be aborted.\n     */\n    signal?: AbortSignal;\n    /**\n     * Determines the version of the graph to create.\n     *\n     * Can be one of\n     * - `\"v1\"`: The tool node processes a single message. All tool calls in the message are\n     *           executed in parallel within the tool node.\n     * - `\"v2\"`: The tool node processes a single tool call. Tool calls are distributed across\n     *           multiple instances of the tool node using the Send API.\n     *\n     * @default `\"v2\"`\n     */\n    version?: \"v1\" | \"v2\";\n};\n/**\n * Type helper to extract union type from an array of Zod schemas\n */\nexport type ExtractZodArrayTypes<T extends readonly InteropZodType<any>[]> = T extends readonly [InteropZodType<infer A>, ...infer Rest] ? Rest extends readonly InteropZodType<any>[] ? A | ExtractZodArrayTypes<Rest> : A : never;\nexport type WithStateGraphNodes<K extends string, Graph> = Graph extends StateGraph<infer SD, infer S, infer U, infer N, infer I, infer O, infer C> ? StateGraph<SD, S, U, N | K, I, O, C> : never;\n"],"mappings":";;;;;;;;;;;;KAWYsB,CAAAA,UAAWpB;AAAvB;AAIA;AAUA;AAA6B,UAVZqB,SAUY,CAAA,SAAA,OAAA,CAAA,CAAA;EAAA;;;EAWJ,EAAA,EAAA,MAAA;EAKbG;;;EAAgD,KAAG1B,EAlBpDwB,MAkBoDxB;;AAA4CkB,UAhB1FO,YAAAA,CAgB0FP;EAAgB,QAC7GT,EAhBAH,WAgBAG,EAAAA;EAAQ,aAAA,CAAA,EAfFc,SAeE,EAAA;EAKLK;AAyBjB;AAiBA;AAIA;AAkBA;;;;EAAyF,MAAmCX,CAAAA,EA3E/GI,YA2E+GJ;;;;;AAAkLiB,KAtElSR,SAsEkSQ,CAAAA,qBAtEnQjB,iBAsEmQiB,GAtE/OlC,gBAsE+OkC,GAAAA,SAAAA,GAAAA,SAAAA,CAAAA,GAtEnMhB,gBAsEmMgB,CAtElLP,YAsEkLO,CAAAA,GAAAA;EAAsB,QAArCjC,EArEjRQ,QAqEiRR;CAAc;;;;AAAkIiC,UAhE9ZN,UAAAA,CAgE8ZM;EAAsB;;;EAAgB,EAAA,EAA4CA,MAAAA;EAAsB;;;EAwBlf,IAsBxBf,EAAAA,MAAAA;EAAU;;;EAmFU,IAKdZ,EA1LTsB,MA0LStB,CAAAA,MAAAA,EAAAA,GAAAA,CAAAA;EAAmB;;;EAkEG,MAoB5B+B,CAAAA,EAAAA,OAAAA;EAAW;AAiBxB;;EAAgC,KAAoBrC,CAAAA,EAAAA,MAAAA;;;;;AAAqIyC,UApRxKZ,UAAAA,CAoRwKY;EAAC;;;EAAiC,EAAA,EAAA,MAAA;EAC/MC;;;EAAoD,MAASvC,EAAAA,GAAAA;EAAU;;;EAAsF,KAAEkB,CAAAA,EAAAA,MAAAA;;;;;AAArBlB,KApQ1I2B,MAAAA,GAoQ0I3B,eAAAA,GAAAA,OAAAA,GAAAA,OApQ9FD,GAoQ8FC;AAAU;;;UAhQ/I4B,gBAAAA;;;;;;;;QAQPH;;;;;;;;;;KAUEI,iDAAiDJ,sBAAsBA,yCAAyCZ,oBAAoBjB,gEAAgEiB,oBAAoBjB,mBAAmBiB,wCAAwChB,eAAeiC,0BAA0BjC,4BAA4Ba,mBAAmBA,qBAAqBJ,iBAAiBE,kBAAkBsB,0BAA0BvB,aAAauB,0BAA0BrB,iBAAiBqB,0BAA0BnB;;;;;;;;;;;;;;;;;;;;;;;;kBAwBvgBV;;;;;;;;;;;;;;;;;;;;;;WAsBPc,aAAaC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gBAiDRe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kBAkCEC;;;;;iBAKD7B;;;;;UAKPC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBAsDS6B;;;;;;;wBAOKrB;;;;;;;;;;;;;;;;;;;;WAoBbsB;;;;;;;;;;;;;;;;;KAiBDC,wCAAwCtC,yBAAyBuC,oBAAoBvC,0CAA0CwC,sBAAsBxC,wBAAwByC,IAAIH,qBAAqBE,QAAQC;KAC9MC,+CAA+CC,cAAcxC,6EAA6EA,WAAWyC,IAAIC,GAAGC,GAAGzB,IAAI0B,GAAGC,GAAGC,GAAGC"}