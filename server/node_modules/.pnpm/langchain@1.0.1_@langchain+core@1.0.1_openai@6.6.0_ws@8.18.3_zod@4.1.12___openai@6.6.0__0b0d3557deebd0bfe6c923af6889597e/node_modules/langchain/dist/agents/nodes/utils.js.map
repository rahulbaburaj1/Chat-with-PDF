{"version":3,"file":"utils.js","names":["middlewareList: readonly AgentMiddleware[]","state: unknown","middlewareStates: Record<string, any>","issue: ZodIssue","stateSchema?: z.ZodObject<z.ZodRawShape>","privateShape: Record<string, any>","target?: string"],"sources":["../../../src/agents/nodes/utils.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { z } from \"zod/v3\";\nimport { type BaseMessage } from \"@langchain/core/messages\";\nimport {\n  interopSafeParseAsync,\n  interopZodObjectMakeFieldsOptional,\n} from \"@langchain/core/utils/types\";\nimport { type ZodIssue } from \"zod/v3\";\nimport { END } from \"@langchain/langgraph\";\n\nimport type { JumpTo } from \"../types.js\";\nimport type { AgentMiddleware } from \"../middleware/types.js\";\n\n/**\n * Helper function to initialize middleware state defaults.\n * This is used to ensure all middleware state properties are initialized.\n *\n * Private properties (starting with _) are automatically made optional since\n * users cannot provide them when invoking the agent.\n */\nexport async function initializeMiddlewareStates(\n  middlewareList: readonly AgentMiddleware[],\n  state: unknown\n): Promise<Record<string, any>> {\n  const middlewareStates: Record<string, any> = {};\n\n  for (const middleware of middlewareList) {\n    if (middleware.stateSchema) {\n      // Create a modified schema where private properties are optional\n      const modifiedSchema = interopZodObjectMakeFieldsOptional(\n        middleware.stateSchema,\n        (key) => key.startsWith(\"_\")\n      );\n\n      // Use safeParse with the modified schema\n      const parseResult = await interopSafeParseAsync(modifiedSchema, state);\n\n      if (parseResult.success) {\n        Object.assign(middlewareStates, parseResult.data);\n        continue;\n      }\n\n      /**\n       * If safeParse fails, there are required public fields missing\n       */\n      const requiredFields = parseResult.error.issues\n        .filter(\n          (issue: ZodIssue) =>\n            issue.code === \"invalid_type\" && issue.message === \"Required\"\n        )\n        .map(\n          (issue: ZodIssue) => `  - ${issue.path.join(\".\")}: ${issue.message}`\n        )\n        .join(\"\\n\");\n\n      throw new Error(\n        `Middleware \"${middleware.name}\" has required state fields that must be initialized:\\n` +\n          `${requiredFields}\\n\\n` +\n          `To fix this, either:\\n` +\n          `1. Provide default values in your middleware's state schema using .default():\\n` +\n          `   stateSchema: z.object({\\n` +\n          `     myField: z.string().default(\"default value\")\\n` +\n          `   })\\n\\n` +\n          `2. Or make the fields optional using .optional():\\n` +\n          `   stateSchema: z.object({\\n` +\n          `     myField: z.string().optional()\\n` +\n          `   })\\n\\n` +\n          `3. Or ensure you pass these values when invoking the agent:\\n` +\n          `   agent.invoke({\\n` +\n          `     messages: [...],\\n` +\n          `     ${parseResult.error.issues[0]?.path.join(\".\")}: \"value\"\\n` +\n          `   })`\n      );\n    }\n  }\n\n  return middlewareStates;\n}\n\n/**\n * Users can define private and public state for a middleware. Private state properties start with an underscore.\n * This function will return the private state properties from the state schema, making all of them optional.\n * @param stateSchema - The middleware state schema\n * @returns A new schema containing only the private properties (underscore-prefixed), all made optional\n */\nexport function derivePrivateState(\n  stateSchema?: z.ZodObject<z.ZodRawShape>\n): z.ZodObject<z.ZodRawShape> {\n  const builtInStateSchema = {\n    messages: z.custom<BaseMessage[]>(() => []),\n    // Include optional structuredResponse so after_agent hooks can access/modify it\n    structuredResponse: z.any().optional(),\n  };\n\n  if (!stateSchema) {\n    return z.object(builtInStateSchema);\n  }\n\n  const { shape } = stateSchema;\n  const privateShape: Record<string, any> = { ...builtInStateSchema };\n\n  // Filter properties that start with underscore and make them optional\n  for (const [key, value] of Object.entries(shape)) {\n    if (key.startsWith(\"_\")) {\n      // Make the private property optional\n      privateShape[key] = value.optional();\n    } else {\n      privateShape[key] = value;\n    }\n  }\n\n  // Return a new schema with only private properties (all optional)\n  return z.object(privateShape);\n}\n\n/**\n * Parse `jumpTo` target from user facing labels to a LangGraph node names\n */\nexport function parseJumpToTarget(target: string): JumpTo;\nexport function parseJumpToTarget(target?: string): JumpTo | undefined {\n  if (!target) {\n    return undefined;\n  }\n\n  /**\n   * if target is already a valid jump target, return it\n   */\n  if ([\"model_request\", \"tools\", END].includes(target)) {\n    return target as JumpTo;\n  }\n\n  if (target === \"model\") {\n    return \"model_request\";\n  }\n  if (target === \"tools\") {\n    return \"tools\";\n  }\n  if (target === \"end\") {\n    return END;\n  }\n\n  throw new Error(\n    `Invalid jump target: ${target}, must be \"model\", \"tools\" or \"end\".`\n  );\n}\n\n/**\n * TypeScript currently doesn't support types for `AbortSignal.any`\n * @see https://github.com/microsoft/TypeScript/issues/60695\n */\ndeclare const AbortSignal: {\n  any(signals: AbortSignal[]): AbortSignal;\n};\n\n/**\n * `config` always contains a signal from LangGraphs Pregel class.\n * To ensure we acknowledge the abort signal from the user, we merge it\n * with the signal from the ToolNode.\n *\n * @param signals - The signals to merge.\n * @returns The merged signal.\n */\nexport function mergeAbortSignals(\n  ...signals: (AbortSignal | undefined)[]\n): AbortSignal {\n  return AbortSignal.any(\n    signals.filter(\n      (maybeSignal): maybeSignal is AbortSignal =>\n        maybeSignal !== null &&\n        maybeSignal !== undefined &&\n        typeof maybeSignal === \"object\" &&\n        \"aborted\" in maybeSignal &&\n        typeof maybeSignal.aborted === \"boolean\"\n    )\n  );\n}\n"],"mappings":";;;;;;;;;;;;AAoBA,eAAsB,2BACpBA,gBACAC,OAC8B;CAC9B,MAAMC,mBAAwC,CAAE;AAEhD,MAAK,MAAM,cAAc,eACvB,KAAI,WAAW,aAAa;EAE1B,MAAM,iBAAiB,mCACrB,WAAW,aACX,CAAC,QAAQ,IAAI,WAAW,IAAI,CAC7B;EAGD,MAAM,cAAc,MAAM,sBAAsB,gBAAgB,MAAM;AAEtE,MAAI,YAAY,SAAS;GACvB,OAAO,OAAO,kBAAkB,YAAY,KAAK;AACjD;EACD;;;;EAKD,MAAM,iBAAiB,YAAY,MAAM,OACtC,OACC,CAACC,UACC,MAAM,SAAS,kBAAkB,MAAM,YAAY,WACtD,CACA,IACC,CAACA,UAAoB,CAAC,IAAI,EAAE,MAAM,KAAK,KAAK,IAAI,CAAC,EAAE,EAAE,MAAM,SAAS,CACrE,CACA,KAAK,KAAK;AAEb,QAAM,IAAI,MACR,CAAC,YAAY,EAAE,WAAW,KAAK,uDAAuD,EACjF,eAAe,0aAAI,EAad,YAAY,MAAM,OAAO,IAAI,KAAK,KAAK,IAAI,CAAC,gBAAW,CACxD;CAEZ;AAGH,QAAO;AACR;;;;;;;AAQD,SAAgB,mBACdC,aAC4B;CAC5B,MAAM,qBAAqB;EACzB,UAAU,EAAE,OAAsB,MAAM,CAAE,EAAC;EAE3C,oBAAoB,EAAE,KAAK,CAAC,UAAU;CACvC;AAED,KAAI,CAAC,YACH,QAAO,EAAE,OAAO,mBAAmB;CAGrC,MAAM,EAAE,OAAO,GAAG;CAClB,MAAMC,eAAoC,EAAE,GAAG,mBAAoB;AAGnE,MAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,QAAQ,MAAM,CAC9C,KAAI,IAAI,WAAW,IAAI,EAErB,aAAa,OAAO,MAAM,UAAU;MAEpC,aAAa,OAAO;AAKxB,QAAO,EAAE,OAAO,aAAa;AAC9B;AAMD,SAAgB,kBAAkBC,QAAqC;AACrE,KAAI,CAAC,OACH,QAAO;;;;AAMT,KAAI;EAAC;EAAiB;EAAS;CAAI,EAAC,SAAS,OAAO,CAClD,QAAO;AAGT,KAAI,WAAW,QACb,QAAO;AAET,KAAI,WAAW,QACb,QAAO;AAET,KAAI,WAAW,MACb,QAAO;AAGT,OAAM,IAAI,MACR,CAAC,qBAAqB,EAAE,OAAO,oCAAoC,CAAC;AAEvE;;;;;;;;;AAkBD,SAAgB,kBACd,GAAG,SACU;AACb,QAAO,YAAY,IACjB,QAAQ,OACN,CAAC,gBACC,gBAAgB,QAChB,gBAAgB,UAChB,OAAO,gBAAgB,YACvB,aAAa,eACb,OAAO,YAAY,YAAY,UAClC,CACF;AACF"}