{"version":3,"file":"utils.js","names":["message: T","updatedContent: MessageContent","updatedName: string | undefined","tool: ClientTool | ServerTool","llm: LanguageModelLike","toolClasses: (ClientTool | ServerTool)[]","options: Partial<BaseChatModelCallOptions>","step: RunnableLike","message?: BaseMessage","prompt?: Prompt","promptRunnable: Runnable","state: typeof MessagesAnnotation.State","model","nextSteps: unknown[]","handlers: WrapToolCallHook[]","outer: WrapToolCallHook","inner: WrapToolCallHook","innerHandler: ToolCallHandler","middleware: readonly AgentMiddleware[]","wrappedHandler: WrapToolCallHook"],"sources":["../../src/agents/utils.ts"],"sourcesContent":["import {\n  AIMessage,\n  AIMessageChunk,\n  BaseMessage,\n  BaseMessageLike,\n  SystemMessage,\n  MessageContent,\n  ToolMessage,\n} from \"@langchain/core/messages\";\nimport { MessagesAnnotation, isCommand } from \"@langchain/langgraph\";\nimport {\n  BaseChatModel,\n  type BaseChatModelCallOptions,\n} from \"@langchain/core/language_models/chat_models\";\nimport {\n  LanguageModelLike,\n  BaseLanguageModelInput,\n} from \"@langchain/core/language_models/base\";\nimport {\n  Runnable,\n  RunnableLike,\n  RunnableConfig,\n  RunnableLambda,\n  RunnableSequence,\n  RunnableBinding,\n} from \"@langchain/core/runnables\";\n\nimport { isBaseChatModel, isConfigurableModel } from \"./model.js\";\nimport type { ClientTool, ServerTool } from \"./tools.js\";\nimport { MultipleToolsBoundError } from \"./errors.js\";\nimport { PROMPT_RUNNABLE_NAME } from \"./constants.js\";\nimport type { AgentBuiltInState } from \"./runtime.js\";\nimport type {\n  ToolCallHandler,\n  AgentMiddleware,\n  ToolCallRequest,\n  WrapToolCallHook,\n} from \"./middleware/types.js\";\n\nconst NAME_PATTERN = /<name>(.*?)<\\/name>/s;\nconst CONTENT_PATTERN = /<content>(.*?)<\\/content>/s;\n\nexport type AgentNameMode = \"inline\";\n\n/**\n * Attach formatted agent names to the messages passed to and from a language model.\n *\n * This is useful for making a message history with multiple agents more coherent.\n *\n * NOTE: agent name is consumed from the message.name field.\n * If you're using an agent built with createAgent, name is automatically set.\n * If you're building a custom agent, make sure to set the name on the AI message returned by the LLM.\n *\n * @param message - Message to add agent name formatting to\n * @returns Message with agent name formatting\n *\n * @internal\n */\nexport function _addInlineAgentName<T extends BaseMessageLike>(\n  message: T\n): T | AIMessage {\n  if (!AIMessage.isInstance(message) || AIMessageChunk.isInstance(message)) {\n    return message;\n  }\n\n  if (!message.name) {\n    return message;\n  }\n\n  const { name } = message;\n\n  if (typeof message.content === \"string\") {\n    return new AIMessage({\n      ...message.lc_kwargs,\n      content: `<name>${name}</name><content>${message.content}</content>`,\n      name: undefined,\n    });\n  }\n\n  const updatedContent = [];\n  let textBlockCount = 0;\n\n  for (const contentBlock of message.content) {\n    if (typeof contentBlock === \"string\") {\n      textBlockCount += 1;\n      updatedContent.push(\n        `<name>${name}</name><content>${contentBlock}</content>`\n      );\n    } else if (\n      typeof contentBlock === \"object\" &&\n      \"type\" in contentBlock &&\n      contentBlock.type === \"text\"\n    ) {\n      textBlockCount += 1;\n      updatedContent.push({\n        ...contentBlock,\n        text: `<name>${name}</name><content>${contentBlock.text}</content>`,\n      });\n    } else {\n      updatedContent.push(contentBlock);\n    }\n  }\n\n  if (!textBlockCount) {\n    updatedContent.unshift({\n      type: \"text\",\n      text: `<name>${name}</name><content></content>`,\n    });\n  }\n  return new AIMessage({\n    ...message.lc_kwargs,\n    content: updatedContent as MessageContent,\n    name: undefined,\n  });\n}\n\n/**\n * Remove explicit name and content XML tags from the AI message content.\n *\n * Examples:\n *\n * @example\n * ```typescript\n * removeInlineAgentName(new AIMessage({ content: \"<name>assistant</name><content>Hello</content>\", name: \"assistant\" }))\n * // AIMessage with content: \"Hello\"\n *\n * removeInlineAgentName(new AIMessage({ content: [{type: \"text\", text: \"<name>assistant</name><content>Hello</content>\"}], name: \"assistant\" }))\n * // AIMessage with content: [{type: \"text\", text: \"Hello\"}]\n * ```\n *\n * @internal\n */\nexport function _removeInlineAgentName<T extends BaseMessage>(message: T): T {\n  if (!AIMessage.isInstance(message) || !message.content) {\n    return message;\n  }\n\n  let updatedContent: MessageContent = [];\n  let updatedName: string | undefined;\n\n  if (Array.isArray(message.content)) {\n    updatedContent = message.content\n      .filter((block) => {\n        if (block.type === \"text\" && typeof block.text === \"string\") {\n          const nameMatch = block.text.match(NAME_PATTERN);\n          const contentMatch = block.text.match(CONTENT_PATTERN);\n          // don't include empty content blocks that were added because there was no text block to modify\n          if (nameMatch && (!contentMatch || contentMatch[1] === \"\")) {\n            // capture name from text block\n            updatedName = nameMatch[1];\n            return false;\n          }\n          return true;\n        }\n        return true;\n      })\n      .map((block) => {\n        if (block.type === \"text\" && typeof block.text === \"string\") {\n          const nameMatch = block.text.match(NAME_PATTERN);\n          const contentMatch = block.text.match(CONTENT_PATTERN);\n\n          if (!nameMatch || !contentMatch) {\n            return block;\n          }\n\n          // capture name from text block\n          updatedName = nameMatch[1];\n\n          return {\n            ...block,\n            text: contentMatch[1],\n          };\n        }\n        return block;\n      });\n  } else {\n    const content = message.content as string;\n    const nameMatch = content.match(NAME_PATTERN);\n    const contentMatch = content.match(CONTENT_PATTERN);\n\n    if (!nameMatch || !contentMatch) {\n      return message;\n    }\n\n    updatedName = nameMatch[1];\n    updatedContent = contentMatch[1];\n  }\n\n  return new AIMessage({\n    ...(Object.keys(message.lc_kwargs ?? {}).length > 0\n      ? message.lc_kwargs\n      : message),\n    content: updatedContent,\n    name: updatedName,\n  }) as T;\n}\n\nexport function isClientTool(\n  tool: ClientTool | ServerTool\n): tool is ClientTool {\n  return Runnable.isRunnable(tool);\n}\n\n/**\n * Helper function to check if a language model has a bindTools method.\n * @param llm - The language model to check if it has a bindTools method.\n * @returns True if the language model has a bindTools method, false otherwise.\n */\nfunction _isChatModelWithBindTools(\n  llm: LanguageModelLike\n): llm is BaseChatModel & Required<Pick<BaseChatModel, \"bindTools\">> {\n  if (!isBaseChatModel(llm)) return false;\n  return \"bindTools\" in llm && typeof llm.bindTools === \"function\";\n}\n\n/**\n * Helper function to bind tools to a language model.\n * @param llm - The language model to bind tools to.\n * @param toolClasses - The tools to bind to the language model.\n * @param options - The options to pass to the language model.\n * @returns The language model with the tools bound to it.\n */\nconst _simpleBindTools = (\n  llm: LanguageModelLike,\n  toolClasses: (ClientTool | ServerTool)[],\n  options: Partial<BaseChatModelCallOptions> = {}\n) => {\n  if (_isChatModelWithBindTools(llm)) {\n    return llm.bindTools(toolClasses, options);\n  }\n\n  if (\n    RunnableBinding.isRunnableBinding(llm) &&\n    _isChatModelWithBindTools(llm.bound)\n  ) {\n    const newBound = llm.bound.bindTools(toolClasses, options);\n\n    if (RunnableBinding.isRunnableBinding(newBound)) {\n      return new RunnableBinding({\n        bound: newBound.bound,\n        config: { ...llm.config, ...newBound.config },\n        kwargs: { ...llm.kwargs, ...newBound.kwargs },\n        configFactories: newBound.configFactories ?? llm.configFactories,\n      });\n    }\n\n    return new RunnableBinding({\n      bound: newBound,\n      config: llm.config,\n      kwargs: llm.kwargs,\n      configFactories: llm.configFactories,\n    });\n  }\n\n  return null;\n};\n\n/**\n * Check if the LLM already has bound tools and throw if it does.\n *\n * @param llm - The LLM to check.\n * @returns void\n */\nexport function validateLLMHasNoBoundTools(llm: LanguageModelLike): void {\n  /**\n   * If llm is a function, we can't validate until runtime, so skip\n   */\n  if (typeof llm === \"function\") {\n    return;\n  }\n\n  let model = llm;\n\n  /**\n   * If model is a RunnableSequence, find a RunnableBinding in its steps\n   */\n  if (RunnableSequence.isRunnableSequence(model)) {\n    model =\n      model.steps.find((step: RunnableLike) =>\n        RunnableBinding.isRunnableBinding(step)\n      ) || model;\n  }\n\n  /**\n   * If model is configurable, get the underlying model\n   */\n  if (isConfigurableModel(model)) {\n    /**\n     * Can't validate async model retrieval in constructor\n     */\n    return;\n  }\n\n  /**\n   * Check if model is a RunnableBinding with bound tools\n   */\n  if (RunnableBinding.isRunnableBinding(model)) {\n    const hasToolsInKwargs =\n      model.kwargs != null &&\n      typeof model.kwargs === \"object\" &&\n      \"tools\" in model.kwargs &&\n      Array.isArray(model.kwargs.tools) &&\n      model.kwargs.tools.length > 0;\n\n    const hasToolsInConfig =\n      model.config != null &&\n      typeof model.config === \"object\" &&\n      \"tools\" in model.config &&\n      Array.isArray(model.config.tools) &&\n      model.config.tools.length > 0;\n\n    if (hasToolsInKwargs || hasToolsInConfig) {\n      throw new MultipleToolsBoundError();\n    }\n  }\n\n  /**\n   * Also check if model has tools property directly (e.g., FakeToolCallingModel)\n   */\n  if (\n    \"tools\" in model &&\n    model.tools !== undefined &&\n    Array.isArray(model.tools) &&\n    model.tools.length > 0\n  ) {\n    throw new MultipleToolsBoundError();\n  }\n}\n\n/**\n * Check if the last message in the messages array has tool calls.\n *\n * @param messages - The messages to check.\n * @returns True if the last message has tool calls, false otherwise.\n */\nexport function hasToolCalls(message?: BaseMessage): boolean {\n  return Boolean(\n    AIMessage.isInstance(message) &&\n      message.tool_calls &&\n      message.tool_calls.length > 0\n  );\n}\n\ntype Prompt = string | SystemMessage;\n\nexport function getPromptRunnable(prompt?: Prompt): Runnable {\n  let promptRunnable: Runnable;\n\n  if (prompt == null) {\n    promptRunnable = RunnableLambda.from(\n      (state: typeof MessagesAnnotation.State) => state.messages\n    ).withConfig({ runName: PROMPT_RUNNABLE_NAME });\n  } else if (typeof prompt === \"string\") {\n    const systemMessage = new SystemMessage(prompt);\n    promptRunnable = RunnableLambda.from(\n      (state: typeof MessagesAnnotation.State) => {\n        return [systemMessage, ...(state.messages ?? [])];\n      }\n    ).withConfig({ runName: PROMPT_RUNNABLE_NAME });\n  } else {\n    throw new Error(`Got unexpected type for 'prompt': ${typeof prompt}`);\n  }\n\n  return promptRunnable;\n}\n\n/**\n * Helper function to bind tools to a language model.\n * @param llm - The language model to bind tools to.\n * @param toolClasses - The tools to bind to the language model.\n * @param options - The options to pass to the language model.\n * @returns The language model with the tools bound to it.\n */\nexport async function bindTools(\n  llm: LanguageModelLike,\n  toolClasses: (ClientTool | ServerTool)[],\n  options: Partial<BaseChatModelCallOptions> = {}\n): Promise<\n  | RunnableSequence<unknown, unknown>\n  | RunnableBinding<unknown, unknown, RunnableConfig<Record<string, unknown>>>\n  | Runnable<BaseLanguageModelInput, AIMessageChunk, BaseChatModelCallOptions>\n> {\n  const model = _simpleBindTools(llm, toolClasses, options);\n  if (model) return model;\n\n  if (isConfigurableModel(llm)) {\n    const model = _simpleBindTools(await llm._model(), toolClasses, options);\n    if (model) return model;\n  }\n\n  if (RunnableSequence.isRunnableSequence(llm)) {\n    const modelStep = llm.steps.findIndex(\n      (step) =>\n        RunnableBinding.isRunnableBinding(step) ||\n        isBaseChatModel(step) ||\n        isConfigurableModel(step)\n    );\n\n    if (modelStep >= 0) {\n      const model = _simpleBindTools(\n        llm.steps[modelStep],\n        toolClasses,\n        options\n      );\n      if (model) {\n        const nextSteps: unknown[] = llm.steps.slice();\n        nextSteps.splice(modelStep, 1, model);\n\n        return RunnableSequence.from(\n          nextSteps as [RunnableLike, ...RunnableLike[], RunnableLike]\n        );\n      }\n    }\n  }\n\n  throw new Error(`llm ${llm} must define bindTools method.`);\n}\n\n/**\n * Compose multiple wrapToolCall handlers into a single middleware stack.\n *\n * Composes handlers so the first in the list becomes the outermost layer.\n * Each handler receives a handler callback to execute inner layers.\n *\n * @param handlers - List of handlers. First handler wraps all others.\n * @returns Composed handler, or undefined if handlers array is empty.\n *\n * @example\n * ```typescript\n * // handlers=[auth, retry] means: auth wraps retry\n * // Flow: auth calls retry, retry calls base handler\n * const auth: ToolCallWrapper = async (request, handler) => {\n *   try {\n *     return await handler(request);\n *   } catch (error) {\n *     if (error.message === \"Unauthorized\") {\n *       await refreshToken();\n *       return await handler(request);\n *     }\n *     throw error;\n *   }\n * };\n *\n * const retry: ToolCallWrapper = async (request, handler) => {\n *   for (let attempt = 0; attempt < 3; attempt++) {\n *     try {\n *       return await handler(request);\n *     } catch (error) {\n *       if (attempt === 2) throw error;\n *     }\n *   }\n *   throw new Error(\"Unreachable\");\n * };\n *\n * const composedHandler = chainToolCallHandlers([auth, retry]);\n * ```\n */\nfunction chainToolCallHandlers(\n  handlers: WrapToolCallHook[]\n): WrapToolCallHook | undefined {\n  if (handlers.length === 0) {\n    return undefined;\n  }\n\n  if (handlers.length === 1) {\n    return handlers[0];\n  }\n\n  // Compose two handlers where outer wraps inner\n  function composeTwo(\n    outer: WrapToolCallHook,\n    inner: WrapToolCallHook\n  ): WrapToolCallHook {\n    return async (request, handler) => {\n      // Create a wrapper that calls inner with the base handler\n      const innerHandler: ToolCallHandler = async (req) =>\n        inner(req, async (innerReq) => handler(innerReq));\n\n      // Call outer with the wrapped inner as its handler\n      return outer(request, innerHandler);\n    };\n  }\n\n  // Compose right-to-left: outer(inner(innermost(handler)))\n  let result = handlers[handlers.length - 1];\n  for (let i = handlers.length - 2; i >= 0; i--) {\n    result = composeTwo(handlers[i], result);\n  }\n\n  return result;\n}\n\n/**\n * Wrapping `wrapToolCall` invocation so we can inject middleware name into\n * the error message.\n *\n * @param middleware list of middleware passed to the agent\n * @returns single wrap function\n */\nexport function wrapToolCall(middleware: readonly AgentMiddleware[]) {\n  const middlewareWithWrapToolCall = middleware.filter((m) => m.wrapToolCall);\n\n  if (middlewareWithWrapToolCall.length === 0) {\n    return;\n  }\n\n  return chainToolCallHandlers(\n    middlewareWithWrapToolCall.map((m) => {\n      const originalHandler = m.wrapToolCall!;\n      /**\n       * Wrap with error handling and validation\n       */\n      const wrappedHandler: WrapToolCallHook = async (request, handler) => {\n        try {\n          const result = await originalHandler(\n            request as ToolCallRequest<AgentBuiltInState, unknown>,\n            handler\n          );\n\n          /**\n           * Validate return type\n           */\n          if (!ToolMessage.isInstance(result) && !isCommand(result)) {\n            throw new Error(\n              `Invalid response from \"wrapToolCall\" in middleware \"${m.name}\": ` +\n                `expected ToolMessage or Command, got ${typeof result}`\n            );\n          }\n\n          return result;\n        } catch (error) {\n          /**\n           * Add middleware context to error if not already added\n           */\n          if (\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            error instanceof Error &&\n            !error.message.includes(`middleware \"${m.name}\"`)\n          ) {\n            error.message = `Error in middleware \"${m.name}\": ${error.message}`;\n          }\n          throw error;\n        }\n      };\n      return wrappedHandler;\n    })\n  );\n}\n"],"mappings":"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"}