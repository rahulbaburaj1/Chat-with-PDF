{"version":3,"file":"index.js","names":["params: CreateAgentParams<\n    StructuredResponseFormat,\n    StateSchema,\n    ContextSchema,\n    any\n  >"],"sources":["../../src/agents/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {\n  InteropZodObject,\n  InteropZodType,\n} from \"@langchain/core/utils/types\";\n\nimport type { ResponseFormatUndefined } from \"./responses.js\";\nimport type { CreateAgentParams } from \"./types.js\";\nimport type { AgentMiddleware, AnyAnnotationRoot } from \"./middleware/types.js\";\nimport type { ExtractZodArrayTypes } from \"./types.js\";\nimport type {\n  ToolStrategy,\n  TypedToolStrategy,\n  ProviderStrategy,\n  ResponseFormat,\n  JsonSchemaFormat,\n} from \"./responses.js\";\nimport { ReactAgent } from \"./ReactAgent.js\";\n\n/**\n * Creates a production-ready ReAct (Reasoning + Acting) agent that combines language models with tools\n * and middleware to create systems that can reason about tasks, decide which tools to use, and iteratively\n * work towards solutions.\n *\n * The agent follows the ReAct pattern, interleaving reasoning steps with tool calls to iteratively\n * work towards solutions. It can handle multiple tool calls in sequence or parallel, maintain state\n * across interactions, and provide auditable decision processes.\n *\n * ## Core Components\n *\n * ### Model\n * The reasoning engine can be specified as:\n * - **String identifier**: `\"openai:gpt-4o\"` for simple setup\n * - **Model instance**: Configured model object for full control\n * - **Dynamic function**: Select models at runtime based on state\n *\n * ### Tools\n * Tools give agents the ability to take actions:\n * - Pass an array of tools created with the `tool` function\n * - Or provide a configured `ToolNode` for custom error handling\n *\n * ### Prompt\n * Shape how your agent approaches tasks:\n * - String for simple instructions\n * - SystemMessage for structured prompts\n * - Function for dynamic prompts based on state\n *\n * ### Middleware\n * Middleware allows you to extend the agent's behavior:\n * - Add pre/post-model processing for context injection or validation\n * - Add dynamic control flows, e.g. terminate invocation or retries\n * - Add human-in-the-loop capabilities\n * - Add tool calls to the agent\n * - Add tool results to the agent\n *\n * ## Advanced Features\n *\n * - **Structured Output**: Use `responseFormat` with a Zod schema to get typed responses\n * - **Memory**: Extend the state schema to remember information across interactions\n * - **Streaming**: Get real-time updates as the agent processes\n *\n * @param options - Configuration options for the agent\n * @param options.llm - The language model as an instance of a chat model\n * @param options.model - The language model as a string identifier, see more in {@link https://docs.langchain.com/oss/javascript/langchain/models#basic-usage | Models}.\n * @param options.tools - Array of tools or configured ToolNode\n * @param options.prompt - System instructions (string, SystemMessage, or function)\n * @param options.responseFormat - Zod schema for structured output\n * @param options.stateSchema - Custom state schema for memory\n * @param options.middleware - Array of middleware for extending agent behavior, see more in {@link https://docs.langchain.com/oss/javascript/langchain/middleware | Middleware}.\n *\n * @returns A ReactAgent instance with `invoke` and `stream` methods\n *\n * @example Basic agent with tools\n * ```ts\n * import { createAgent, tool } from \"langchain\";\n * import { z } from \"zod\";\n *\n * const search = tool(\n *   ({ query }) => `Results for: ${query}`,\n *   {\n *     name: \"search\",\n *     description: \"Search for information\",\n *     schema: z.object({\n *       query: z.string().describe(\"The search query\"),\n *     })\n *   }\n * );\n *\n * const agent = createAgent({\n *   llm: \"openai:gpt-4o\",\n *   tools: [search],\n * });\n *\n * const result = await agent.invoke({\n *   messages: [{ role: \"user\", content: \"Search for ReAct agents\" }],\n * });\n * ```\n *\n * @example Structured output\n * ```ts\n * import { createAgent } from \"langchain\";\n * import { z } from \"zod\";\n *\n * const ContactInfo = z.object({\n *   name: z.string(),\n *   email: z.string(),\n *   phone: z.string(),\n * });\n *\n * const agent = createAgent({\n *   llm: \"openai:gpt-4o\",\n *   tools: [],\n *   responseFormat: ContactInfo,\n * });\n *\n * const result = await agent.invoke({\n *   messages: [{\n *     role: \"user\",\n *     content: \"Extract: John Doe, john@example.com, (555) 123-4567\"\n *   }],\n * });\n *\n * console.log(result.structuredResponse);\n * // { name: 'John Doe', email: 'john@example.com', phone: '(555) 123-4567' }\n * ```\n *\n * @example Streaming responses\n * ```ts\n * const stream = await agent.stream(\n *   { messages: [{ role: \"user\", content: \"What's the weather?\" }] },\n *   { streamMode: \"values\" }\n * );\n *\n * for await (const chunk of stream) {\n *   // ...\n * }\n * ```\n */\n// Overload 1: With responseFormat as single InteropZodType\nexport function createAgent<\n  T extends Record<string, any> = Record<string, any>,\n  StateSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject\n    | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  TMiddleware extends readonly AgentMiddleware[] = readonly AgentMiddleware[]\n>(\n  params: CreateAgentParams<\n    T,\n    StateSchema,\n    ContextSchema,\n    InteropZodType<T>\n  > & {\n    responseFormat: InteropZodType<T>;\n    middleware?: TMiddleware;\n  }\n): ReactAgent<T, StateSchema, ContextSchema, TMiddleware>;\n\n// Overload 2: With responseFormat as array of InteropZodTypes (infers union type)\nexport function createAgent<\n  T extends readonly InteropZodType<any>[],\n  StateSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject\n    | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  TMiddleware extends readonly AgentMiddleware[] = readonly AgentMiddleware[]\n>(\n  params: CreateAgentParams<\n    ExtractZodArrayTypes<T> extends Record<string, any>\n      ? ExtractZodArrayTypes<T>\n      : Record<string, any>,\n    StateSchema,\n    ContextSchema,\n    T\n  > & {\n    responseFormat: T;\n    middleware?: TMiddleware;\n  }\n): ReactAgent<\n  ExtractZodArrayTypes<T> extends Record<string, any>\n    ? ExtractZodArrayTypes<T>\n    : Record<string, any>,\n  StateSchema,\n  ContextSchema,\n  TMiddleware\n>;\n\n// Overload 3: With responseFormat as JsonSchemaFormat (JSON schema object)\nexport function createAgent<\n  StateSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject\n    | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  TMiddleware extends readonly AgentMiddleware[] = readonly AgentMiddleware[]\n>(\n  params: CreateAgentParams<\n    Record<string, unknown>,\n    StateSchema,\n    ContextSchema,\n    JsonSchemaFormat\n  > & {\n    responseFormat: JsonSchemaFormat;\n    middleware?: TMiddleware;\n  }\n): ReactAgent<Record<string, unknown>, StateSchema, ContextSchema, TMiddleware>;\n\n// Overload 4: With responseFormat as array of JsonSchemaFormat (JSON schema objects)\nexport function createAgent<\n  StateSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject\n    | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  TMiddleware extends readonly AgentMiddleware[] = readonly AgentMiddleware[]\n>(\n  params: CreateAgentParams<\n    Record<string, unknown>,\n    StateSchema,\n    ContextSchema,\n    JsonSchemaFormat[]\n  > & {\n    responseFormat: JsonSchemaFormat[];\n    middleware?: TMiddleware;\n  }\n): ReactAgent<Record<string, unknown>, StateSchema, ContextSchema, TMiddleware>;\n\n// Overload 4.5: With responseFormat as union of JsonSchemaFormat | JsonSchemaFormat[]\nexport function createAgent<\n  StateSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject\n    | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  TMiddleware extends readonly AgentMiddleware[] = readonly AgentMiddleware[]\n>(\n  params: CreateAgentParams<\n    Record<string, unknown>,\n    StateSchema,\n    ContextSchema,\n    JsonSchemaFormat | JsonSchemaFormat[]\n  > & {\n    responseFormat: JsonSchemaFormat | JsonSchemaFormat[];\n    middleware?: TMiddleware;\n  }\n): ReactAgent<Record<string, unknown>, StateSchema, ContextSchema, TMiddleware>;\n\n// Overload 5: With responseFormat as TypedToolStrategy (for union types from toolStrategy)\nexport function createAgent<\n  T extends Record<string, any> = Record<string, any>,\n  StateSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject\n    | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  TMiddleware extends readonly AgentMiddleware[] = readonly AgentMiddleware[]\n>(\n  params: CreateAgentParams<\n    T,\n    StateSchema,\n    ContextSchema,\n    TypedToolStrategy<T>\n  > & {\n    responseFormat: TypedToolStrategy<T>;\n    middleware?: TMiddleware;\n  }\n): ReactAgent<T, StateSchema, ContextSchema, TMiddleware>;\n\n// Overload 6: With responseFormat as single ToolStrategy instance\nexport function createAgent<\n  T extends Record<string, any> = Record<string, any>,\n  StateSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject\n    | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  TMiddleware extends readonly AgentMiddleware[] = readonly AgentMiddleware[]\n>(\n  params: CreateAgentParams<T, StateSchema, ContextSchema, ToolStrategy<T>> & {\n    responseFormat: ToolStrategy<T>;\n    middleware?: TMiddleware;\n  }\n): ReactAgent<T, StateSchema, ContextSchema, TMiddleware>;\n\n// Overload 7: With responseFormat as ProviderStrategy\nexport function createAgent<\n  T extends Record<string, any> = Record<string, any>,\n  StateSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject\n    | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  TMiddleware extends readonly AgentMiddleware[] = readonly AgentMiddleware[]\n>(\n  params: CreateAgentParams<\n    T,\n    StateSchema,\n    ContextSchema,\n    ProviderStrategy<T>\n  > & {\n    responseFormat: ProviderStrategy<T>;\n    middleware?: TMiddleware;\n  }\n): ReactAgent<T, StateSchema, ContextSchema, TMiddleware>;\n\n// Overload 8: Without responseFormat property at all - with proper middleware state typing\nexport function createAgent<\n  StateSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject\n    | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  TMiddleware extends readonly AgentMiddleware[] = readonly AgentMiddleware[]\n>(\n  params: Omit<\n    CreateAgentParams<\n      ResponseFormatUndefined,\n      StateSchema,\n      ContextSchema,\n      never\n    >,\n    \"responseFormat\"\n  > & { middleware?: TMiddleware }\n): ReactAgent<ResponseFormatUndefined, StateSchema, ContextSchema, TMiddleware>;\n\n// Overload 9: With responseFormat explicitly undefined\nexport function createAgent<\n  StateSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject\n    | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  TMiddleware extends readonly AgentMiddleware[] = readonly AgentMiddleware[]\n>(\n  params: Omit<\n    CreateAgentParams<\n      ResponseFormatUndefined,\n      StateSchema,\n      ContextSchema,\n      never\n    >,\n    \"responseFormat\"\n  > & {\n    responseFormat?: undefined;\n    middleware?: TMiddleware;\n  }\n): ReactAgent<ResponseFormatUndefined, StateSchema, ContextSchema, TMiddleware>;\n\n// Overload 10: For other ResponseFormat values (failsafe)\nexport function createAgent<\n  StructuredResponseFormat extends Record<string, any> = Record<string, any>,\n  StateSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject\n    | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  TMiddleware extends readonly AgentMiddleware[] = readonly AgentMiddleware[]\n>(\n  params: CreateAgentParams<\n    StructuredResponseFormat,\n    StateSchema,\n    ContextSchema,\n    ResponseFormat\n  > & {\n    responseFormat: ResponseFormat;\n    middleware?: TMiddleware;\n  }\n): ReactAgent<\n  StructuredResponseFormat,\n  StateSchema,\n  ContextSchema,\n  TMiddleware\n>;\n\n// Implementation\nexport function createAgent<\n  StructuredResponseFormat extends Record<string, any>,\n  StateSchema extends AnyAnnotationRoot | InteropZodObject,\n  ContextSchema extends AnyAnnotationRoot | InteropZodObject,\n  TMiddleware extends readonly AgentMiddleware[] = []\n>(\n  params: CreateAgentParams<\n    StructuredResponseFormat,\n    StateSchema,\n    ContextSchema,\n    any\n  >\n): ReactAgent<\n  StructuredResponseFormat,\n  StateSchema,\n  ContextSchema,\n  TMiddleware\n> {\n  return new ReactAgent(params);\n}\n\n// Re-export types and utilities\nexport * from \"./types.js\";\nexport * from \"./errors.js\";\nexport type { JumpToTarget } from \"./constants.js\";\nexport type { Runtime } from \"./runtime.js\";\nexport {\n  toolStrategy,\n  providerStrategy,\n  ToolStrategy,\n  ProviderStrategy,\n  type ResponseFormat,\n  type ResponseFormatUndefined,\n} from \"./responses.js\";\nexport { createMiddleware } from \"./middleware.js\";\nexport type {\n  ToolCallRequest,\n  ToolCallHandler,\n  WrapToolCallHook,\n} from \"./middleware/types.js\";\nexport { FakeToolCallingModel } from \"./tests/utils.js\";\nexport type { ReactAgent } from \"./ReactAgent.js\";\n"],"mappings":";;;;;;;AA+YA,SAAgB,YAMdA,QAWA;AACA,QAAO,IAAI,WAAW;AACvB"}