{"version":3,"file":"buffer.js","names":["filePathOrBlob: string | Blob","buffer: Buffer","metadata: Record<string, string>"],"sources":["../../../src/document_loaders/fs/buffer.ts"],"sourcesContent":["import type { readFile as ReadFileT } from \"node:fs/promises\";\nimport { Document } from \"@langchain/core/documents\";\nimport { getEnv } from \"@langchain/core/utils/env\";\nimport { BaseDocumentLoader } from \"@langchain/core/document_loaders/base\";\n\n/**\n * Abstract class that extends the `BaseDocumentLoader` class. It\n * represents a document loader that loads documents from a buffer. The\n * `load()` method is implemented to read the buffer contents and metadata\n * based on the type of `filePathOrBlob`, and then calls the `parse()`\n * method to parse the buffer and return the documents.\n */\nexport abstract class BufferLoader extends BaseDocumentLoader {\n  constructor(public filePathOrBlob: string | Blob) {\n    super();\n  }\n\n  /**\n   * Abstract method that needs to be implemented by subclasses. It is used\n   * to parse the buffer and return the documents.\n   * @param raw The buffer to be parsed.\n   * @param metadata Metadata of the document.\n   * @returns Promise that resolves with an array of `Document` objects.\n   */\n  protected abstract parse(\n    raw: Buffer,\n    metadata: Document[\"metadata\"]\n  ): Promise<Document[]>;\n\n  /**\n   * Method that reads the buffer contents and metadata based on the type of\n   * `filePathOrBlob`, and then calls the `parse()` method to parse the\n   * buffer and return the documents.\n   * @returns Promise that resolves with an array of `Document` objects.\n   */\n  public async load(): Promise<Document[]> {\n    let buffer: Buffer;\n    let metadata: Record<string, string>;\n    if (typeof this.filePathOrBlob === \"string\") {\n      const { readFile } = await BufferLoader.imports();\n      buffer = await readFile(this.filePathOrBlob);\n      metadata = { source: this.filePathOrBlob };\n    } else {\n      buffer = await this.filePathOrBlob\n        .arrayBuffer()\n        .then((ab) => Buffer.from(ab));\n      metadata = { source: \"blob\", blobType: this.filePathOrBlob.type };\n    }\n    return this.parse(buffer, metadata);\n  }\n\n  /**\n   * Static method that imports the `readFile` function from the\n   * `fs/promises` module in Node.js. It is used to dynamically import the\n   * function when needed. If the import fails, it throws an error\n   * indicating that the `fs/promises` module is not available in the\n   * current environment.\n   * @returns Promise that resolves with an object containing the `readFile` function.\n   */\n  static async imports(): Promise<{\n    readFile: typeof ReadFileT;\n  }> {\n    try {\n      const { readFile } = await import(\"node:fs/promises\");\n      return { readFile };\n    } catch (e) {\n      console.error(e);\n      throw new Error(\n        `Failed to load fs/promises. TextLoader available only on environment 'node'. It appears you are running environment '${getEnv()}'. See https://<link to docs> for alternatives.`\n      );\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;AAYA,IAAsB,eAAtB,MAAsB,qBAAqB,mBAAmB;CAC5D,YAAmBA,gBAA+B;EAChD,OAAO;EADU;CAElB;;;;;;;CAoBD,MAAa,OAA4B;EACvC,IAAIC;EACJ,IAAIC;AACJ,MAAI,OAAO,KAAK,mBAAmB,UAAU;GAC3C,MAAM,EAAE,UAAU,GAAG,MAAM,aAAa,SAAS;GACjD,SAAS,MAAM,SAAS,KAAK,eAAe;GAC5C,WAAW,EAAE,QAAQ,KAAK,eAAgB;EAC3C,OAAM;GACL,SAAS,MAAM,KAAK,eACjB,aAAa,CACb,KAAK,CAAC,OAAO,OAAO,KAAK,GAAG,CAAC;GAChC,WAAW;IAAE,QAAQ;IAAQ,UAAU,KAAK,eAAe;GAAM;EAClE;AACD,SAAO,KAAK,MAAM,QAAQ,SAAS;CACpC;;;;;;;;;CAUD,aAAa,UAEV;AACD,MAAI;GACF,MAAM,EAAE,UAAU,GAAG,MAAM,OAAO;AAClC,UAAO,EAAE,SAAU;EACpB,SAAQ,GAAG;GACV,QAAQ,MAAM,EAAE;AAChB,SAAM,IAAI,MACR,CAAC,qHAAqH,EAAE,QAAQ,CAAC,+CAA+C,CAAC;EAEpL;CACF;AACF"}