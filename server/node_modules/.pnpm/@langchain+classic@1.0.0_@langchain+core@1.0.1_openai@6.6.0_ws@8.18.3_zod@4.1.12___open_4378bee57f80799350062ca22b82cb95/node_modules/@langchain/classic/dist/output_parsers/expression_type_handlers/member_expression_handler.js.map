{"version":3,"file":"member_expression_handler.js","names":["node: ExpressionNode","node: MemberExpression","prop: string","identifier: string"],"sources":["../../../src/output_parsers/expression_type_handlers/member_expression_handler.ts"],"sourcesContent":["import { NodeHandler, ASTParser } from \"./base.js\";\nimport { MemberExpressionType } from \"./types.js\";\nimport type {\n  ExpressionNode,\n  MemberExpression,\n} from \"../../types/expression-parser.js\";\n\n/**\n * Handles member expressions in the LangChain Expression Language (LCEL).\n * Extends the NodeHandler base class.\n */\nexport class MemberExpressionHandler extends NodeHandler {\n  /**\n   * Checks if a given node is a member expression. If it is, the method\n   * returns the node; otherwise, it returns false.\n   * @param node The node to check.\n   * @returns The node if it is a member expression, or false otherwise.\n   */\n  async accepts(node: ExpressionNode): Promise<MemberExpression | boolean> {\n    if (ASTParser.isMemberExpression(node)) {\n      return node;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Processes a member expression node. It extracts the object and property\n   * from the node, validates their types, and returns an object with the\n   * type of the expression, the identifier, and the property.\n   * @param node The member expression node to process.\n   * @returns An object with the type of the expression, the identifier, and the property.\n   */\n  async handle(node: MemberExpression): Promise<MemberExpressionType> {\n    if (!this.parentHandler) {\n      throw new Error(\n        \"ArrayLiteralExpressionHandler must have a parent handler\"\n      );\n    }\n    const { object, property } = node;\n    let prop: string;\n    if (ASTParser.isIdentifier(property)) {\n      prop = property.name.replace(/^[\"'](.+(?=[\"']$))[\"']$/, \"$1\");\n    } else if (ASTParser.isStringLiteral(property)) {\n      prop = (`${property.value}` as string).replace(\n        /^[\"'](.+(?=[\"']$))[\"']$/,\n        \"$1\"\n      );\n    } else {\n      throw new Error(\"Invalid property key type\");\n    }\n    let identifier: string;\n    if (ASTParser.isIdentifier(object)) {\n      identifier = object.name.replace(/^[\"'](.+(?=[\"']$))[\"']$/, \"$1\");\n    } else if (ASTParser.isStringLiteral(object)) {\n      identifier = (`${object.value}` as string).replace(\n        /^[\"'](.+(?=[\"']$))[\"']$/,\n        \"$1\"\n      );\n    } else {\n      throw new Error(\"Invalid object type\");\n    }\n    if (object.type !== \"Identifier\" && object.type !== \"StringLiteral\") {\n      throw new Error(\"ArrayExpression is not supported\");\n    }\n\n    return { type: \"member_expression\", identifier, property: prop };\n  }\n}\n"],"mappings":";;;;;;;AAWA,IAAa,0BAAb,cAA6C,YAAY;;;;;;;CAOvD,MAAM,QAAQA,MAA2D;AACvE,MAAI,UAAU,mBAAmB,KAAK,CACpC,QAAO;MAEP,QAAO;CAEV;;;;;;;;CASD,MAAM,OAAOC,MAAuD;AAClE,MAAI,CAAC,KAAK,cACR,OAAM,IAAI,MACR;EAGJ,MAAM,EAAE,QAAQ,UAAU,GAAG;EAC7B,IAAIC;AACJ,MAAI,UAAU,aAAa,SAAS,EAClC,OAAO,SAAS,KAAK,QAAQ,2BAA2B,KAAK;WACpD,UAAU,gBAAgB,SAAS,EAC5C,OAAQ,GAAG,SAAS,OAAO,CAAY,QACrC,2BACA,KACD;MAED,OAAM,IAAI,MAAM;EAElB,IAAIC;AACJ,MAAI,UAAU,aAAa,OAAO,EAChC,aAAa,OAAO,KAAK,QAAQ,2BAA2B,KAAK;WACxD,UAAU,gBAAgB,OAAO,EAC1C,aAAc,GAAG,OAAO,OAAO,CAAY,QACzC,2BACA,KACD;MAED,OAAM,IAAI,MAAM;AAElB,MAAI,OAAO,SAAS,gBAAgB,OAAO,SAAS,gBAClD,OAAM,IAAI,MAAM;AAGlB,SAAO;GAAE,MAAM;GAAqB;GAAY,UAAU;EAAM;CACjE;AACF"}