{"version":3,"file":"memory.d.cts","names":["MaxMarginalRelevanceSearchOptions","VectorStore","EmbeddingsInterface","Document","DocumentInterface","cosine","MemoryVector","Record","MemoryVectorStoreArgs","MemoryVectorStore","similarity","Promise"],"sources":["../../src/vectorstores/memory.d.ts"],"sourcesContent":["import { MaxMarginalRelevanceSearchOptions, VectorStore } from \"@langchain/core/vectorstores\";\nimport type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { Document, DocumentInterface } from \"@langchain/core/documents\";\nimport { cosine } from \"../util/ml-distance/similarities.js\";\n/**\n * Interface representing a vector in memory. It includes the content\n * (text), the corresponding embedding (vector), and any associated\n * metadata.\n */\ninterface MemoryVector {\n    content: string;\n    embedding: number[];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    metadata: Record<string, any>;\n    id?: string;\n}\n/**\n * Interface for the arguments that can be passed to the\n * `MemoryVectorStore` constructor. It includes an optional `similarity`\n * function.\n */\nexport interface MemoryVectorStoreArgs {\n    similarity?: typeof cosine;\n}\n/**\n * In-memory, ephemeral vector store.\n *\n * Setup:\n * Install `langchain`:\n *\n * ```bash\n * npm install langchain\n * ```\n *\n * ## [Constructor args](https://api.js.langchain.com/classes/langchain.vectorstores_memory.MemoryVectorStore.html#constructor)\n *\n * <details open>\n * <summary><strong>Instantiate</strong></summary>\n *\n * ```typescript\n * import { MemoryVectorStore } from 'langchain/vectorstores/memory';\n * // Or other embeddings\n * import { OpenAIEmbeddings } from '@langchain/openai';\n *\n * const embeddings = new OpenAIEmbeddings({\n *   model: \"text-embedding-3-small\",\n * });\n *\n * const vectorStore = new MemoryVectorStore(embeddings);\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Add documents</strong></summary>\n *\n * ```typescript\n * import type { Document } from '@langchain/core/documents';\n *\n * const document1 = { pageContent: \"foo\", metadata: { baz: \"bar\" } };\n * const document2 = { pageContent: \"thud\", metadata: { bar: \"baz\" } };\n * const document3 = { pageContent: \"i will be deleted :(\", metadata: {} };\n *\n * const documents: Document[] = [document1, document2, document3];\n *\n * await vectorStore.addDocuments(documents);\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Similarity search</strong></summary>\n *\n * ```typescript\n * const results = await vectorStore.similaritySearch(\"thud\", 1);\n * for (const doc of results) {\n *   console.log(`* ${doc.pageContent} [${JSON.stringify(doc.metadata, null)}]`);\n * }\n * // Output: * thud [{\"baz\":\"bar\"}]\n * ```\n * </details>\n *\n * <br />\n *\n *\n * <details>\n * <summary><strong>Similarity search with filter</strong></summary>\n *\n * ```typescript\n * const resultsWithFilter = await vectorStore.similaritySearch(\"thud\", 1, { baz: \"bar\" });\n *\n * for (const doc of resultsWithFilter) {\n *   console.log(`* ${doc.pageContent} [${JSON.stringify(doc.metadata, null)}]`);\n * }\n * // Output: * foo [{\"baz\":\"bar\"}]\n * ```\n * </details>\n *\n * <br />\n *\n *\n * <details>\n * <summary><strong>Similarity search with score</strong></summary>\n *\n * ```typescript\n * const resultsWithScore = await vectorStore.similaritySearchWithScore(\"qux\", 1);\n * for (const [doc, score] of resultsWithScore) {\n *   console.log(`* [SIM=${score.toFixed(6)}] ${doc.pageContent} [${JSON.stringify(doc.metadata, null)}]`);\n * }\n * // Output: * [SIM=0.000000] qux [{\"bar\":\"baz\",\"baz\":\"bar\"}]\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>As a retriever</strong></summary>\n *\n * ```typescript\n * const retriever = vectorStore.asRetriever({\n *   searchType: \"mmr\", // Leave blank for standard similarity search\n *   k: 1,\n * });\n * const resultAsRetriever = await retriever.invoke(\"thud\");\n * console.log(resultAsRetriever);\n *\n * // Output: [Document({ metadata: { \"baz\":\"bar\" }, pageContent: \"thud\" })]\n * ```\n * </details>\n *\n * <br />\n */\nexport declare class MemoryVectorStore extends VectorStore {\n    FilterType: (doc: Document) => boolean;\n    memoryVectors: MemoryVector[];\n    similarity: typeof cosine;\n    _vectorstoreType(): string;\n    constructor(embeddings: EmbeddingsInterface, { similarity, ...rest }?: MemoryVectorStoreArgs);\n    /**\n     * Method to add documents to the memory vector store. It extracts the\n     * text from each document, generates embeddings for them, and adds the\n     * resulting vectors to the store.\n     * @param documents Array of `Document` instances to be added to the store.\n     * @returns Promise that resolves when all documents have been added.\n     */\n    addDocuments(documents: Document[]): Promise<void>;\n    /**\n     * Method to add vectors to the memory vector store. It creates\n     * `MemoryVector` instances for each vector and document pair and adds\n     * them to the store.\n     * @param vectors Array of vectors to be added to the store.\n     * @param documents Array of `Document` instances corresponding to the vectors.\n     * @returns Promise that resolves when all vectors have been added.\n     */\n    addVectors(vectors: number[][], documents: Document[]): Promise<void>;\n    protected _queryVectors(query: number[], k: number, filter?: this[\"FilterType\"]): Promise<{\n        similarity: number;\n        index: number;\n        metadata: Record<string, any>;\n        content: string;\n        embedding: number[];\n        id: string | undefined;\n    }[]>;\n    /**\n     * Method to perform a similarity search in the memory vector store. It\n     * calculates the similarity between the query vector and each vector in\n     * the store, sorts the results by similarity, and returns the top `k`\n     * results along with their scores.\n     * @param query Query vector to compare against the vectors in the store.\n     * @param k Number of top results to return.\n     * @param filter Optional filter function to apply to the vectors before performing the search.\n     * @returns Promise that resolves with an array of tuples, each containing a `Document` and its similarity score.\n     */\n    similaritySearchVectorWithScore(query: number[], k: number, filter?: this[\"FilterType\"]): Promise<[Document, number][]>;\n    maxMarginalRelevanceSearch(query: string, options: MaxMarginalRelevanceSearchOptions<this[\"FilterType\"]>): Promise<DocumentInterface[]>;\n    /**\n     * Static method to create a `MemoryVectorStore` instance from an array of\n     * texts. It creates a `Document` for each text and metadata pair, and\n     * adds them to the store.\n     * @param texts Array of texts to be added to the store.\n     * @param metadatas Array or single object of metadata corresponding to the texts.\n     * @param embeddings `Embeddings` instance used to generate embeddings for the texts.\n     * @param dbConfig Optional `MemoryVectorStoreArgs` to configure the `MemoryVectorStore` instance.\n     * @returns Promise that resolves with a new `MemoryVectorStore` instance.\n     */\n    static fromTexts(texts: string[], metadatas: object[] | object, embeddings: EmbeddingsInterface, dbConfig?: MemoryVectorStoreArgs): Promise<MemoryVectorStore>;\n    /**\n     * Static method to create a `MemoryVectorStore` instance from an array of\n     * `Document` instances. It adds the documents to the store.\n     * @param docs Array of `Document` instances to be added to the store.\n     * @param embeddings `Embeddings` instance used to generate embeddings for the documents.\n     * @param dbConfig Optional `MemoryVectorStoreArgs` to configure the `MemoryVectorStore` instance.\n     * @returns Promise that resolves with a new `MemoryVectorStore` instance.\n     */\n    static fromDocuments(docs: Document[], embeddings: EmbeddingsInterface, dbConfig?: MemoryVectorStoreArgs): Promise<MemoryVectorStore>;\n    /**\n     * Static method to create a `MemoryVectorStore` instance from an existing\n     * index. It creates a new `MemoryVectorStore` instance without adding any\n     * documents or vectors.\n     * @param embeddings `Embeddings` instance used to generate embeddings for the documents.\n     * @param dbConfig Optional `MemoryVectorStoreArgs` to configure the `MemoryVectorStore` instance.\n     * @returns Promise that resolves with a new `MemoryVectorStore` instance.\n     */\n    static fromExistingIndex(embeddings: EmbeddingsInterface, dbConfig?: MemoryVectorStoreArgs): Promise<MemoryVectorStore>;\n}\nexport {};\n"],"mappings":";;;;;;;;;AAG6D;AAkB7D;AAiHA;UA7HUM,YAAAA,CA6H4B;EAAA,OAChBH,EAAAA,MAAAA;EAAQ,SACXG,EAAAA,MAAAA,EAAAA;EAAY;EACF,QAEDJ,EA9HdK,MA8HcL,CAAAA,MAAAA,EAAAA,GAAAA,CAAAA;EAAmB,EAAA,CAAIQ,EAAAA,MAAAA;;;;;;;AAkBmCC,UAxIrEH,qBAAAA,CAwIqEG;EAAO,UAkBUR,CAAAA,EAAAA,OAzJ/EE,MAyJ+EF;;;;;;;;;;;;;;;;;;;AAzC7C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAArCM,iBAAAA,SAA0BR,WAAAA;oBACzBE;iBACHG;qBACID;;0BAEKH;;;MAA+CM;;;;;;;;0BAQ/CL,aAAaQ;;;;;;;;;6CASMR,aAAaQ;oFAC0BA;;;cAGpEJ;;;;;;;;;;;;;;;4FAe4EI,SAASR;qDAChDH,wDAAwDW,QAAQP;;;;;;;;;;;8EAWvCF,gCAAgCM,wBAAwBG,QAAQF;;;;;;;;;6BASjHN,wBAAwBD,gCAAgCM,wBAAwBG,QAAQF;;;;;;;;;uCAS9EP,gCAAgCM,wBAAwBG,QAAQF"}