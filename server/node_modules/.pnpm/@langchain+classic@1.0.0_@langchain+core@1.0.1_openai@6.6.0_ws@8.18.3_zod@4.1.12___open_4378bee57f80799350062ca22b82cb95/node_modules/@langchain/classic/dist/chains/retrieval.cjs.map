{"version":3,"file":"retrieval.cjs","names":["x: unknown","retrieveDocumentsChain: Runnable<{ input: string }, DocumentInterface[]>","RunnableSequence","RunnablePassthrough"],"sources":["../../src/chains/retrieval.ts"],"sourcesContent":["import type { BaseRetrieverInterface } from \"@langchain/core/retrievers\";\nimport {\n  type Runnable,\n  RunnableSequence,\n  type RunnableInterface,\n  RunnablePassthrough,\n} from \"@langchain/core/runnables\";\nimport type { BaseMessage } from \"@langchain/core/messages\";\nimport type { DocumentInterface, Document } from \"@langchain/core/documents\";\n\n/**\n * Parameters for the createRetrievalChain method.\n */\nexport type CreateRetrievalChainParams<RunOutput> = {\n  /**\n   * Retriever-like object that returns list of documents. Should\n   * either be a subclass of BaseRetriever or a Runnable that returns\n   * a list of documents. If a subclass of BaseRetriever, then it\n   * is expected that an `input` key be passed in - this is what\n   * is will be used to pass into the retriever. If this is NOT a\n   * subclass of BaseRetriever, then all the inputs will be passed\n   * into this runnable, meaning that runnable should take a object\n   * as input.\n   */\n  retriever:\n    | BaseRetrieverInterface\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    | RunnableInterface<Record<string, any>, DocumentInterface[]>;\n  /**\n   * Runnable that takes inputs and produces a string output.\n   * The inputs to this will be any original inputs to this chain, a new\n   * context key with the retrieved documents, and chat_history (if not present\n   * in the inputs) with a value of `[]` (to easily enable conversational\n   * retrieval).\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  combineDocsChain: RunnableInterface<Record<string, any>, RunOutput>;\n};\n\nfunction isBaseRetriever(x: unknown): x is BaseRetrieverInterface {\n  return !!x && typeof (x as BaseRetrieverInterface).invoke === \"function\";\n}\n\n/**\n * Create a retrieval chain that retrieves documents and then passes them on.\n * @param {CreateRetrievalChainParams} params A params object\n *     containing a retriever and a combineDocsChain.\n * @returns An LCEL Runnable which returns a an object\n *     containing at least `context` and `answer` keys.\n * @example\n * ```typescript\n * // pnpm add langchain @langchain/openai\n *\n * import { ChatOpenAI } from \"@langchain/openai\";\n * import { pull } from \"langchain/hub\";\n * import { createRetrievalChain } from \"@langchain/classic/chains/retrieval\";\n * import { createStuffDocumentsChain } from \"@langchain/classic/chains/combine_documents\";\n *\n * const retrievalQAChatPrompt = await pull(\"langchain-ai/retrieval-qa-chat\");\n * const llm = new ChatOpenAI({ model: \"gpt-4o-mini\" });\n * const retriever = ...\n * const combineDocsChain = await createStuffDocumentsChain(...);\n * const retrievalChain = await createRetrievalChain({\n *   retriever,\n *   combineDocsChain,\n * });\n * const response = await chain.invoke({ input: \"...\" });\n * ```\n */\nexport async function createRetrievalChain<RunOutput>({\n  retriever,\n  combineDocsChain,\n}: CreateRetrievalChainParams<RunOutput>): Promise<\n  Runnable<\n    { input: string; chat_history?: BaseMessage[] | string } & {\n      [key: string]: unknown;\n    },\n    { context: Document[]; answer: RunOutput } & { [key: string]: unknown }\n  >\n> {\n  let retrieveDocumentsChain: Runnable<{ input: string }, DocumentInterface[]>;\n  if (isBaseRetriever(retriever)) {\n    retrieveDocumentsChain = RunnableSequence.from([\n      (input) => input.input,\n      retriever,\n    ]);\n  } else {\n    // TODO: Fix typing by adding withConfig to core RunnableInterface\n    retrieveDocumentsChain = retriever as Runnable;\n  }\n  const retrievalChain = RunnableSequence.from<{\n    input: string;\n    chat_history?: BaseMessage[] | string;\n  }>([\n    RunnablePassthrough.assign({\n      context: retrieveDocumentsChain.withConfig({\n        runName: \"retrieve_documents\",\n      }),\n      chat_history: (input) => input.chat_history ?? [],\n    }),\n    RunnablePassthrough.assign({\n      answer: combineDocsChain,\n    }),\n  ]).withConfig({ runName: \"retrieval_chain\" });\n  return retrievalChain;\n}\n"],"mappings":";;;;;;AAuCA,SAAS,gBAAgBA,GAAyC;AAChE,QAAO,CAAC,CAAC,KAAK,OAAQ,EAA6B,WAAW;AAC/D;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BD,eAAsB,qBAAgC,EACpD,WACA,kBACsC,EAOtC;CACA,IAAIC;AACJ,KAAI,gBAAgB,UAAU,EAC5B,yBAAyBC,4CAAiB,KAAK,CAC7C,CAAC,UAAU,MAAM,OACjB,SACD,EAAC;MAGF,yBAAyB;CAE3B,MAAM,iBAAiBA,4CAAiB,KAGrC,CACDC,+CAAoB,OAAO;EACzB,SAAS,uBAAuB,WAAW,EACzC,SAAS,qBACV,EAAC;EACF,cAAc,CAAC,UAAU,MAAM,gBAAgB,CAAE;CAClD,EAAC,EACFA,+CAAoB,OAAO,EACzB,QAAQ,iBACT,EAAC,AACH,EAAC,CAAC,WAAW,EAAE,SAAS,kBAAmB,EAAC;AAC7C,QAAO;AACR"}