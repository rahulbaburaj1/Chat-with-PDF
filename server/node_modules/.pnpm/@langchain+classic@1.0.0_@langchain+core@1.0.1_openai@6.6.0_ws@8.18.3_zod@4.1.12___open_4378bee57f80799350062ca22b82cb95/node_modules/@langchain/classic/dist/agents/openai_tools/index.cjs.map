{"version":3,"file":"index.cjs","names":["AgentRunnableSequence","RunnablePassthrough","input: { steps: ToolsAgentStep[] }","formatToOpenAIToolMessages","OpenAIToolsAgentOutputParser"],"sources":["../../../src/agents/openai_tools/index.ts"],"sourcesContent":["import type { StructuredToolInterface } from \"@langchain/core/tools\";\nimport type {\n  BaseChatModel,\n  BaseChatModelCallOptions,\n} from \"@langchain/core/language_models/chat_models\";\nimport { ChatPromptTemplate } from \"@langchain/core/prompts\";\nimport { RunnablePassthrough } from \"@langchain/core/runnables\";\nimport { OpenAIClient } from \"@langchain/openai\";\nimport { convertToOpenAITool } from \"@langchain/core/utils/function_calling\";\nimport { ToolDefinition } from \"@langchain/core/language_models/base\";\nimport { formatToOpenAIToolMessages } from \"../format_scratchpad/openai_tools.js\";\nimport {\n  OpenAIToolsAgentOutputParser,\n  type ToolsAgentStep,\n} from \"./output_parser.js\";\nimport { AgentRunnableSequence } from \"../agent.js\";\n\nexport { OpenAIToolsAgentOutputParser, type ToolsAgentStep };\n\n/**\n * Params used by the createOpenAIToolsAgent function.\n */\nexport type CreateOpenAIToolsAgentParams = {\n  /**\n   * LLM to use as the agent. Should work with OpenAI tool calling,\n   * so must either be an OpenAI model that supports that or a wrapper of\n   * a different model that adds in equivalent support.\n   */\n  llm: BaseChatModel<\n    BaseChatModelCallOptions & {\n      tools?:\n        | StructuredToolInterface[]\n        | OpenAIClient.ChatCompletionTool[]\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        | any[];\n    }\n  >;\n  /** Tools this agent has access to. */\n  tools: StructuredToolInterface[] | ToolDefinition[];\n  /** The prompt to use, must have an input key of `agent_scratchpad`. */\n  prompt: ChatPromptTemplate;\n  /**\n   * Whether to invoke the underlying model in streaming mode,\n   * allowing streaming of intermediate steps. Defaults to true.\n   */\n  streamRunnable?: boolean;\n};\n\n/**\n * Create an agent that uses OpenAI-style tool calling.\n * @param params Params required to create the agent. Includes an LLM, tools, and prompt.\n * @returns A runnable sequence representing an agent. It takes as input all the same input\n *     variables as the prompt passed in does. It returns as output either an\n *     AgentAction or AgentFinish.\n *\n * @example\n * ```typescript\n * import { AgentExecutor, createOpenAIToolsAgent } from \"langchain/agents\";\n * import { pull } from \"langchain/hub\";\n * import type { ChatPromptTemplate } from \"@langchain/core/prompts\";\n * import { AIMessage, HumanMessage } from \"@langchain/core/messages\";\n *\n * import { ChatOpenAI } from \"@langchain/openai\";\n *\n * // Define the tools the agent will have access to.\n * const tools = [...];\n *\n * // Get the prompt to use - you can modify this!\n * // If you want to see the prompt in full, you can at:\n * // https://smith.langchain.com/hub/hwchase17/openai-tools-agent\n * const prompt = await pull<ChatPromptTemplate>(\n *   \"hwchase17/openai-tools-agent\"\n * );\n *\n * const llm = new ChatOpenAI({\n *   temperature: 0,\n *   model: \"gpt-3.5-turbo-1106\",\n * });\n *\n * const agent = await createOpenAIToolsAgent({\n *   llm,\n *   tools,\n *   prompt,\n * });\n *\n * const agentExecutor = new AgentExecutor({\n *   agent,\n *   tools,\n * });\n *\n * const result = await agentExecutor.invoke({\n *   input: \"what is LangChain?\",\n * });\n *\n * // With chat history\n * const result2 = await agentExecutor.invoke({\n *   input: \"what's my name?\",\n *   chat_history: [\n *     new HumanMessage(\"hi! my name is cob\"),\n *     new AIMessage(\"Hello Cob! How can I assist you today?\"),\n *   ],\n * });\n * ```\n */\nexport async function createOpenAIToolsAgent({\n  llm,\n  tools,\n  prompt,\n  streamRunnable,\n}: CreateOpenAIToolsAgentParams) {\n  if (!prompt.inputVariables.includes(\"agent_scratchpad\")) {\n    throw new Error(\n      [\n        `Prompt must have an input variable named \"agent_scratchpad\".`,\n        `Found ${JSON.stringify(prompt.inputVariables)} instead.`,\n      ].join(\"\\n\")\n    );\n  }\n  const modelWithTools = llm.bindTools\n    ? llm.bindTools(tools)\n    : llm.withConfig({\n        tools: tools.map((tool) => convertToOpenAITool(tool)),\n      });\n  const agent = AgentRunnableSequence.fromRunnables(\n    [\n      RunnablePassthrough.assign({\n        agent_scratchpad: (input: { steps: ToolsAgentStep[] }) =>\n          formatToOpenAIToolMessages(input.steps),\n      }),\n      prompt,\n      modelWithTools,\n      new OpenAIToolsAgentOutputParser(),\n    ],\n    {\n      name: \"OpenAIToolsAgent\",\n      streamRunnable,\n      singleAction: false,\n    }\n  );\n  return agent;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwGA,eAAsB,uBAAuB,EAC3C,KACA,OACA,QACA,gBAC6B,EAAE;AAC/B,KAAI,CAAC,OAAO,eAAe,SAAS,mBAAmB,CACrD,OAAM,IAAI,MACR,CACE,CAAC,4DAA4D,CAAC,EAC9D,CAAC,MAAM,EAAE,KAAK,UAAU,OAAO,eAAe,CAAC,SAAS,CAAC,AAC1D,EAAC,KAAK,KAAK;CAGhB,MAAM,iBAAiB,IAAI,YACvB,IAAI,UAAU,MAAM,GACpB,IAAI,WAAW,EACb,OAAO,MAAM,IAAI,CAAC,0EAA6B,KAAK,CAAC,CACtD,EAAC;CACN,MAAM,QAAQA,oCAAsB,cAClC;EACEC,+CAAoB,OAAO,EACzB,kBAAkB,CAACC,UACjBC,0CAA2B,MAAM,MAAM,CAC1C,EAAC;EACF;EACA;EACA,IAAIC;CACL,GACD;EACE,MAAM;EACN;EACA,cAAc;CACf,EACF;AACD,QAAO;AACR"}