{"version":3,"file":"base.js","names":["parentHandler?: NodeHandler","node: ExpressionNode"],"sources":["../../../src/output_parsers/expression_type_handlers/base.ts"],"sourcesContent":["import { GRAMMAR } from \"./grammar/parser_grammar.js\";\nimport type {\n  ExpressionNode,\n  Program,\n  ExpressionStatement,\n  CallExpression,\n  StringLiteral,\n  NumericLiteral,\n  BooleanLiteral,\n  Identifier,\n  ObjectExpression,\n  ArrayExpression,\n  PropertyAssignment,\n  MemberExpression,\n  ParseFunction,\n} from \"../../types/expression-parser.js\";\n\n/**\n * Abstract class for handling nodes in an expression language. Subclasses\n * must implement the `accepts` and `handle` methods.\n */\nexport abstract class NodeHandler {\n  constructor(protected parentHandler?: NodeHandler) {}\n\n  /**\n   * Determines whether the given node is acceptable.\n   * @param node The node to be checked.\n   * @returns A Promise that resolves to either the node itself or a boolean indicating whether the node is acceptable.\n   */\n  abstract accepts(node: ExpressionNode): Promise<ExpressionNode | boolean>;\n\n  /**\n   * Handles the given node. The specifics of how the node is handled are\n   * determined by the subclass implementation.\n   * @param node The node to be handled.\n   * @returns A Promise that resolves to the result of handling the node.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  abstract handle(node: ExpressionNode): Promise<any>;\n}\n\n/**\n * Utility class for parsing Abstract Syntax Trees (ASTs). Contains\n * methods for identifying the type of a given node and a method for\n * importing and generating a parser using the Peggy library.\n */\nexport class ASTParser {\n  static astParseInstance: ParseFunction;\n\n  /**\n   * Imports and generates a parser using the Peggy library.\n   * @returns A Promise that resolves to the parser instance.\n   */\n  static async importASTParser() {\n    try {\n      if (!ASTParser.astParseInstance) {\n        const { default: peggy } = await import(\"peggy\");\n        const parser = peggy.generate(GRAMMAR);\n        const { parse } = parser;\n        ASTParser.astParseInstance = parse as ParseFunction;\n      }\n      return ASTParser.astParseInstance;\n    } catch {\n      throw new Error(\n        `Failed to import peggy. Please install peggy (i.e. \"npm install peggy\" or \"pnpm install peggy\").`\n      );\n    }\n  }\n\n  /**\n   * Checks if the given node is a Program node.\n   * @param node The node to be checked.\n   * @returns A boolean indicating whether the node is a Program node.\n   */\n  static isProgram(node: ExpressionNode): node is Program {\n    return node.type === \"Program\";\n  }\n\n  /**\n   * Checks if the given node is an ExpressionStatement node.\n   * @param node The node to be checked.\n   * @returns A boolean indicating whether the node is an ExpressionStatement node.\n   */\n  static isExpressionStatement(\n    node: ExpressionNode\n  ): node is ExpressionStatement {\n    return node.type === \"ExpressionStatement\";\n  }\n\n  /**\n   * Checks if the given node is a CallExpression node.\n   * @param node The node to be checked.\n   * @returns A boolean indicating whether the node is a CallExpression node.\n   */\n  static isCallExpression(node: ExpressionNode): node is CallExpression {\n    return node.type === \"CallExpression\";\n  }\n\n  /**\n   * Checks if the given node is a StringLiteral node.\n   * @param node The node to be checked.\n   * @returns A boolean indicating whether the node is a StringLiteral node.\n   */\n  static isStringLiteral(node: ExpressionNode): node is StringLiteral {\n    return node.type === \"StringLiteral\" && typeof node.value === \"string\";\n  }\n\n  /**\n   * Checks if the given node is a NumericLiteral node.\n   * @param node The node to be checked.\n   * @returns A boolean indicating whether the node is a NumericLiteral node.\n   */\n  static isNumericLiteral(node: ExpressionNode): node is NumericLiteral {\n    return node.type === \"NumericLiteral\" && typeof node.value === \"number\";\n  }\n\n  /**\n   * Checks if the given node is a BooleanLiteral node.\n   * @param node The node to be checked.\n   * @returns A boolean indicating whether the node is a BooleanLiteral node.\n   */\n  static isBooleanLiteral(node: ExpressionNode): node is BooleanLiteral {\n    return node.type === \"BooleanLiteral\" && typeof node.value === \"boolean\";\n  }\n\n  /**\n   * Checks if the given node is an Identifier node.\n   * @param node The node to be checked.\n   * @returns A boolean indicating whether the node is an Identifier node.\n   */\n  static isIdentifier(node: ExpressionNode): node is Identifier {\n    return node.type === \"Identifier\";\n  }\n\n  /**\n   * Checks if the given node is an ObjectExpression node.\n   * @param node The node to be checked.\n   * @returns A boolean indicating whether the node is an ObjectExpression node.\n   */\n  static isObjectExpression(node: ExpressionNode): node is ObjectExpression {\n    return node.type === \"ObjectExpression\";\n  }\n\n  /**\n   * Checks if the given node is an ArrayExpression node.\n   * @param node The node to be checked.\n   * @returns A boolean indicating whether the node is an ArrayExpression node.\n   */\n  static isArrayExpression(node: ExpressionNode): node is ArrayExpression {\n    return node.type === \"ArrayExpression\";\n  }\n\n  /**\n   * Checks if the given node is a PropertyAssignment node.\n   * @param node The node to be checked.\n   * @returns A boolean indicating whether the node is a PropertyAssignment node.\n   */\n  static isPropertyAssignment(\n    node: ExpressionNode\n  ): node is PropertyAssignment {\n    return node.type === \"PropertyAssignment\";\n  }\n\n  /**\n   * Checks if the given node is a MemberExpression node.\n   * @param node The node to be checked.\n   * @returns A boolean indicating whether the node is a MemberExpression node.\n   */\n  static isMemberExpression(node: ExpressionNode): node is MemberExpression {\n    return node.type === \"MemberExpression\";\n  }\n}\n"],"mappings":";;;;;;;AAqBA,IAAsB,cAAtB,MAAkC;CAChC,YAAsBA,eAA6B;EAA7B;CAA+B;AAiBtD;;;;;;AAOD,IAAa,YAAb,MAAa,UAAU;CACrB,OAAO;;;;;CAMP,aAAa,kBAAkB;AAC7B,MAAI;AACF,OAAI,CAAC,UAAU,kBAAkB;IAC/B,MAAM,EAAE,SAAS,OAAO,GAAG,MAAM,OAAO;IACxC,MAAM,SAAS,MAAM,SAAS,QAAQ;IACtC,MAAM,EAAE,OAAO,GAAG;IAClB,UAAU,mBAAmB;GAC9B;AACD,UAAO,UAAU;EAClB,QAAO;AACN,SAAM,IAAI,MACR,CAAC,gGAAgG,CAAC;EAErG;CACF;;;;;;CAOD,OAAO,UAAUC,MAAuC;AACtD,SAAO,KAAK,SAAS;CACtB;;;;;;CAOD,OAAO,sBACLA,MAC6B;AAC7B,SAAO,KAAK,SAAS;CACtB;;;;;;CAOD,OAAO,iBAAiBA,MAA8C;AACpE,SAAO,KAAK,SAAS;CACtB;;;;;;CAOD,OAAO,gBAAgBA,MAA6C;AAClE,SAAO,KAAK,SAAS,mBAAmB,OAAO,KAAK,UAAU;CAC/D;;;;;;CAOD,OAAO,iBAAiBA,MAA8C;AACpE,SAAO,KAAK,SAAS,oBAAoB,OAAO,KAAK,UAAU;CAChE;;;;;;CAOD,OAAO,iBAAiBA,MAA8C;AACpE,SAAO,KAAK,SAAS,oBAAoB,OAAO,KAAK,UAAU;CAChE;;;;;;CAOD,OAAO,aAAaA,MAA0C;AAC5D,SAAO,KAAK,SAAS;CACtB;;;;;;CAOD,OAAO,mBAAmBA,MAAgD;AACxE,SAAO,KAAK,SAAS;CACtB;;;;;;CAOD,OAAO,kBAAkBA,MAA+C;AACtE,SAAO,KAAK,SAAS;CACtB;;;;;;CAOD,OAAO,qBACLA,MAC4B;AAC5B,SAAO,KAAK,SAAS;CACtB;;;;;;CAOD,OAAO,mBAAmBA,MAAgD;AACxE,SAAO,KAAK,SAAS;CACtB;AACF"}