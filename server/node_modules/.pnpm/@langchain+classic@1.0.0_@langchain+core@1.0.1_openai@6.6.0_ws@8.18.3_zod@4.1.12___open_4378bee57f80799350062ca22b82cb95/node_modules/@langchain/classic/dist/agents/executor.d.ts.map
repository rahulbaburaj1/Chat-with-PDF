{"version":3,"file":"executor.d.ts","names":["StructuredToolInterface","ToolInterface","ToolInputParsingException","Tool","Runnable","RunnableConfig","AgentAction","AgentFinish","AgentStep","ChainValues","CallbackManagerForChainRun","Callbacks","OutputParserException","Serializable","SerializedLLMChain","StoppingMethod","BaseMultiActionAgent","BaseSingleActionAgent","BaseChain","ChainInputs","AgentExecutorIteratorInput","AgentExecutor","Record","AgentExecutorIterator","Promise","AsyncGenerator","ExtractToolType","T","AgentExecutorInput","Error","AgentExecutorOutput","ExceptionTool","Partial"],"sources":["../../src/agents/executor.d.ts"],"sourcesContent":["import { type StructuredToolInterface, type ToolInterface, ToolInputParsingException, Tool } from \"@langchain/core/tools\";\nimport { Runnable, type RunnableConfig } from \"@langchain/core/runnables\";\nimport { AgentAction, AgentFinish, AgentStep } from \"@langchain/core/agents\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport { CallbackManagerForChainRun, Callbacks } from \"@langchain/core/callbacks/manager\";\nimport { OutputParserException } from \"@langchain/core/output_parsers\";\nimport { Serializable } from \"@langchain/core/load/serializable\";\nimport { SerializedLLMChain } from \"../chains/serde.js\";\nimport { StoppingMethod } from \"./types.js\";\nimport { BaseMultiActionAgent, BaseSingleActionAgent } from \"./agent.js\";\nimport { BaseChain, ChainInputs } from \"../chains/base.js\";\ninterface AgentExecutorIteratorInput {\n    agentExecutor: AgentExecutor;\n    inputs: Record<string, string>;\n    config?: RunnableConfig;\n    /** @deprecated Use \"config\" */\n    callbacks?: Callbacks;\n    /** @deprecated Use \"config\" */\n    tags?: string[];\n    /** @deprecated Use \"config\" */\n    metadata?: Record<string, unknown>;\n    runName?: string;\n    runManager?: CallbackManagerForChainRun;\n}\nexport declare class AgentExecutorIterator extends Serializable implements AgentExecutorIteratorInput {\n    lc_namespace: string[];\n    agentExecutor: AgentExecutor;\n    inputs: Record<string, string>;\n    config?: RunnableConfig;\n    /** @deprecated Use \"config\" */\n    callbacks?: Callbacks;\n    /** @deprecated Use \"config\" */\n    tags: string[] | undefined;\n    /** @deprecated Use \"config\" */\n    metadata: Record<string, unknown> | undefined;\n    /** @deprecated Use \"config\" */\n    runName: string | undefined;\n    private _finalOutputs;\n    get finalOutputs(): Record<string, unknown> | undefined;\n    /** Intended to be used as a setter method, needs to be async. */\n    setFinalOutputs(value: Record<string, unknown> | undefined): Promise<void>;\n    runManager: CallbackManagerForChainRun | undefined;\n    intermediateSteps: AgentStep[];\n    iterations: number;\n    get nameToToolMap(): Record<string, ToolInterface>;\n    constructor(fields: AgentExecutorIteratorInput);\n    /**\n     * Reset the iterator to its initial state, clearing intermediate steps,\n     * iterations, and the final output.\n     */\n    reset(): void;\n    updateIterations(): void;\n    streamIterator(): AsyncGenerator<Record<string, unknown>, Record<string, unknown>, unknown>;\n    /**\n     * Perform any necessary setup for the first step\n     * of the asynchronous iterator.\n     */\n    onFirstStep(): Promise<void>;\n    /**\n     * Execute the next step in the chain using the\n     * AgentExecutor's _takeNextStep method.\n     */\n    _executeNextStep(runManager?: CallbackManagerForChainRun): Promise<AgentFinish | AgentStep[]>;\n    /**\n     * Process the output of the next step,\n     * handling AgentFinish and tool return cases.\n     */\n    _processNextStepOutput(nextStepOutput: AgentFinish | AgentStep[], runManager?: CallbackManagerForChainRun): Promise<Record<string, string | AgentStep[]>>;\n    _stop(): Promise<Record<string, unknown>>;\n    _callNext(): Promise<Record<string, unknown>>;\n}\ntype ExtractToolType<T> = T extends {\n    ToolType: infer ToolInterface;\n} ? ToolInterface : StructuredToolInterface;\n/**\n * Interface defining the structure of input data for creating an\n * AgentExecutor. It extends ChainInputs and includes additional\n * properties specific to agent execution.\n */\nexport interface AgentExecutorInput extends ChainInputs {\n    agent: BaseSingleActionAgent | BaseMultiActionAgent | Runnable<ChainValues & {\n        steps?: AgentStep[];\n    }, AgentAction[] | AgentAction | AgentFinish>;\n    tools: ExtractToolType<this[\"agent\"]>[];\n    returnIntermediateSteps?: boolean;\n    maxIterations?: number;\n    earlyStoppingMethod?: StoppingMethod;\n    handleParsingErrors?: boolean | string | ((e: OutputParserException | ToolInputParsingException) => string);\n    handleToolRuntimeErrors?: (e: Error) => string;\n}\n// TODO: Type properly with { intermediateSteps?: AgentStep[] };\nexport type AgentExecutorOutput = ChainValues;\n/**\n * Tool that just returns the query.\n * Used for exception tracking.\n */\nexport declare class ExceptionTool extends Tool {\n    name: string;\n    description: string;\n    _call(query: string): Promise<string>;\n}\n/**\n * A chain managing an agent using tools.\n * @augments BaseChain\n * @example\n * ```typescript\n *\n * const executor = AgentExecutor.fromAgentAndTools({\n *   agent: async () => loadAgentFromLangchainHub(),\n *   tools: [new SerpAPI(), new Calculator()],\n *   returnIntermediateSteps: true,\n * });\n *\n * const result = await executor.invoke({\n *   input: `Who is Olivia Wilde's boyfriend? What is his current age raised to the 0.23 power?`,\n * });\n *\n * ```\n */\nexport declare class AgentExecutor extends BaseChain<ChainValues, AgentExecutorOutput> {\n    static lc_name(): string;\n    get lc_namespace(): string[];\n    agent: BaseSingleActionAgent | BaseMultiActionAgent;\n    tools: this[\"agent\"][\"ToolType\"][];\n    returnIntermediateSteps: boolean;\n    maxIterations?: number;\n    earlyStoppingMethod: StoppingMethod;\n    // TODO: Update BaseChain implementation on breaking change to include this\n    returnOnlyOutputs: boolean;\n    /**\n     * How to handle errors raised by the agent's output parser.\n      Defaults to `False`, which raises the error.\n  \n      If `true`, the error will be sent back to the LLM as an observation.\n      If a string, the string itself will be sent to the LLM as an observation.\n      If a callable function, the function will be called with the exception\n      as an argument, and the result of that function will be passed to the agent\n      as an observation.\n     */\n    handleParsingErrors: boolean | string | ((e: OutputParserException | ToolInputParsingException) => string);\n    handleToolRuntimeErrors?: (e: Error) => string;\n    get inputKeys(): string[];\n    get outputKeys(): string[];\n    constructor(input: AgentExecutorInput);\n    /** Create from agent and a list of tools. */\n    static fromAgentAndTools(fields: AgentExecutorInput): AgentExecutor;\n    get shouldContinueGetter(): (iterations: number) => boolean;\n    /**\n     * Method that checks if the agent execution should continue based on the\n     * number of iterations.\n     * @param iterations The current number of iterations.\n     * @returns A boolean indicating whether the agent execution should continue.\n     */\n    private shouldContinue;\n    /** @ignore */\n    _call(inputs: ChainValues, runManager?: CallbackManagerForChainRun, config?: RunnableConfig): Promise<AgentExecutorOutput>;\n    _takeNextStep(nameToolMap: Record<string, ToolInterface>, inputs: ChainValues, intermediateSteps: AgentStep[], runManager?: CallbackManagerForChainRun, config?: RunnableConfig): Promise<AgentFinish | AgentStep[]>;\n    _return(output: AgentFinish, intermediateSteps: AgentStep[], runManager?: CallbackManagerForChainRun): Promise<AgentExecutorOutput>;\n    _getToolReturn(nextStepOutput: AgentStep): Promise<AgentFinish | null>;\n    _returnStoppedResponse(earlyStoppingMethod: StoppingMethod): AgentFinish;\n    _streamIterator(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    inputs: Record<string, any>, options?: Partial<RunnableConfig>): AsyncGenerator<ChainValues>;\n    _chainType(): \"agent_executor\";\n    serialize(): SerializedLLMChain;\n}\nexport {};\n"],"mappings":";;;;;;;;;;;;;;KAuEK0B,eAuF0CF,CAAAA,CAAAA,CAAAA,GAvFrBG,CAuFqBH,SAAAA;EAAO,QACNT,EAAAA,KAAAA,cAAAA;CAAc,GAtF1Dd,aAsF6DM,GAtF7CP,uBAsF6CO;;;;;;AAKhDO,UArFAc,kBAAAA,SAA2BT,WAqF3BL,CAAAA;EAAkB,KA7CQI,EAvChCD,qBAuCgCC,GAvCRF,oBAuCQE,GAvCed,QAuCfc,CAvCwBT,WAuCxBS,GAAAA;IAAS,KAAA,CAAA,EAtCpCV,SAsCoC,EAAA;KArC7CF,gBAAgBA,cAAcC;SAC1BmB;;;wBAGeX;gDACwBH,wBAAwBV;gCACxC2B;;;KAGtBC,mBAAAA,GAAsBrB;;;;;;;;;;;;;;;;;;;;;;;;cA4BbY,aAAAA,SAAsBH,UAAUT,aAAaqB;;;SAGvDb,wBAAwBD;;;;uBAIVD;;;;;;;;;;;;+CAawBH,wBAAwBV;gCACvC2B;;;qBAGXD;;mCAEcA,qBAAqBP;;;;;;;;;;gBAUxCZ,0BAA0BC,qCAAqCL,iBAAiBmB,QAAQM;6BAC3ER,eAAerB,wBAAwBQ,gCAAgCD,0BAA0BE,qCAAqCL,iBAAiBmB,QAAQjB,cAAcC;kBACxLD,gCAAgCC,0BAA0BE,6BAA6Bc,QAAQM;iCAChFtB,YAAYgB,QAAQjB;8CACPQ,iBAAiBR;;;UAGrDe,+BAA+BU,QAAQ3B,kBAAkBoB,eAAehB;;eAEnEK"}