{"version":3,"file":"executor.cjs","names":["Serializable","value: Record<string, unknown> | undefined","preparedOutputs: Record<string, unknown>","fields: AgentExecutorIteratorInput","e: any","CallbackManager","runManager?: CallbackManagerForChainRun","nextStepOutput: AgentFinish | AgentStep[]","output","output: Record<string, string | AgentStep[]>","Tool","query: string","BaseChain","input: AgentExecutorInput","agent: BaseSingleActionAgent | BaseMultiActionAgent","Runnable","AgentRunnableSequence","RunnableSingleActionAgent","RunnableMultiActionAgent","isRunnableAgent","fields: AgentExecutorInput","iterations: number","inputs: ChainValues","config?: RunnableConfig","steps: AgentStep[]","finishStep: AgentFinish","OutputParserException","actions: AgentAction[]","ToolInputParsingException","nameToolMap: Record<string, ToolInterface>","intermediateSteps: AgentStep[]","result: AgentStep[]","output: AgentFinish","finalOutput: Record<string, unknown>","nextStepOutput: AgentStep","earlyStoppingMethod: StoppingMethod","inputs: Record<string, any>","options?: Partial<RunnableConfig>"],"sources":["../../src/agents/executor.ts"],"sourcesContent":["import {\n  type StructuredToolInterface,\n  type ToolInterface,\n  ToolInputParsingException,\n  Tool,\n} from \"@langchain/core/tools\";\nimport {\n  Runnable,\n  type RunnableConfig,\n  patchConfig,\n} from \"@langchain/core/runnables\";\nimport { AgentAction, AgentFinish, AgentStep } from \"@langchain/core/agents\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport {\n  CallbackManager,\n  CallbackManagerForChainRun,\n  Callbacks,\n} from \"@langchain/core/callbacks/manager\";\nimport { OutputParserException } from \"@langchain/core/output_parsers\";\nimport { Serializable } from \"@langchain/core/load/serializable\";\nimport { SerializedLLMChain } from \"../chains/serde.js\";\nimport { StoppingMethod } from \"./types.js\";\nimport {\n  AgentRunnableSequence,\n  BaseMultiActionAgent,\n  BaseSingleActionAgent,\n  RunnableMultiActionAgent,\n  RunnableSingleActionAgent,\n  isRunnableAgent,\n} from \"./agent.js\";\nimport { BaseChain, ChainInputs } from \"../chains/base.js\";\n\ninterface AgentExecutorIteratorInput {\n  agentExecutor: AgentExecutor;\n  inputs: Record<string, string>;\n  config?: RunnableConfig;\n  /** @deprecated Use \"config\" */\n  callbacks?: Callbacks;\n  /** @deprecated Use \"config\" */\n  tags?: string[];\n  /** @deprecated Use \"config\" */\n  metadata?: Record<string, unknown>;\n  runName?: string;\n  runManager?: CallbackManagerForChainRun;\n}\n\nexport class AgentExecutorIterator\n  extends Serializable\n  implements AgentExecutorIteratorInput\n{\n  lc_namespace = [\"langchain\", \"agents\", \"executor_iterator\"];\n\n  agentExecutor: AgentExecutor;\n\n  inputs: Record<string, string>;\n\n  config?: RunnableConfig;\n\n  /** @deprecated Use \"config\" */\n  callbacks?: Callbacks;\n\n  /** @deprecated Use \"config\" */\n  tags: string[] | undefined;\n\n  /** @deprecated Use \"config\" */\n  metadata: Record<string, unknown> | undefined;\n\n  /** @deprecated Use \"config\" */\n  runName: string | undefined;\n\n  private _finalOutputs: Record<string, unknown> | undefined;\n\n  get finalOutputs(): Record<string, unknown> | undefined {\n    return this._finalOutputs;\n  }\n\n  /** Intended to be used as a setter method, needs to be async. */\n  async setFinalOutputs(value: Record<string, unknown> | undefined) {\n    this._finalOutputs = undefined;\n    if (value) {\n      const preparedOutputs: Record<string, unknown> =\n        await this.agentExecutor.prepOutputs(this.inputs, value, true);\n      this._finalOutputs = preparedOutputs;\n    }\n  }\n\n  runManager: CallbackManagerForChainRun | undefined;\n\n  intermediateSteps: AgentStep[] = [];\n\n  iterations = 0;\n\n  get nameToToolMap(): Record<string, ToolInterface> {\n    const toolMap = this.agentExecutor.tools.map((tool) => ({\n      [tool.name]: tool,\n    }));\n    return Object.assign({}, ...toolMap);\n  }\n\n  constructor(fields: AgentExecutorIteratorInput) {\n    super(fields);\n    this.agentExecutor = fields.agentExecutor;\n    this.inputs = fields.inputs;\n    this.callbacks = fields.callbacks;\n    this.tags = fields.tags;\n    this.metadata = fields.metadata;\n    this.runName = fields.runName;\n    this.runManager = fields.runManager;\n    this.config = fields.config;\n  }\n\n  /**\n   * Reset the iterator to its initial state, clearing intermediate steps,\n   * iterations, and the final output.\n   */\n  reset(): void {\n    this.intermediateSteps = [];\n    this.iterations = 0;\n    this._finalOutputs = undefined;\n  }\n\n  updateIterations(): void {\n    this.iterations += 1;\n  }\n\n  async *streamIterator() {\n    this.reset();\n\n    // Loop to handle iteration\n    while (true) {\n      try {\n        if (this.iterations === 0) {\n          await this.onFirstStep();\n        }\n\n        const result = await this._callNext();\n        yield result;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (e: any) {\n        if (\n          \"message\" in e &&\n          e.message.startsWith(\"Final outputs already reached: \")\n        ) {\n          if (!this.finalOutputs) {\n            throw e;\n          }\n          return this.finalOutputs;\n        }\n        if (this.runManager) {\n          await this.runManager.handleChainError(e);\n        }\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * Perform any necessary setup for the first step\n   * of the asynchronous iterator.\n   */\n  async onFirstStep(): Promise<void> {\n    if (this.iterations === 0) {\n      const callbackManager = await CallbackManager.configure(\n        this.callbacks ?? this.config?.callbacks,\n        this.agentExecutor.callbacks,\n        this.tags ?? this.config?.tags,\n        this.agentExecutor.tags,\n        this.metadata ?? this.config?.metadata,\n        this.agentExecutor.metadata,\n        {\n          verbose: this.agentExecutor.verbose,\n        }\n      );\n      this.runManager = await callbackManager?.handleChainStart(\n        this.agentExecutor.toJSON(),\n        this.inputs,\n        this.config?.runId,\n        undefined,\n        this.tags ?? this.config?.tags,\n        this.metadata ?? this.config?.metadata,\n        this.runName ?? this.config?.runName\n      );\n      if (this.config !== undefined) {\n        delete this.config.runId;\n      }\n    }\n  }\n\n  /**\n   * Execute the next step in the chain using the\n   * AgentExecutor's _takeNextStep method.\n   */\n  async _executeNextStep(\n    runManager?: CallbackManagerForChainRun\n  ): Promise<AgentFinish | AgentStep[]> {\n    return this.agentExecutor._takeNextStep(\n      this.nameToToolMap,\n      this.inputs,\n      this.intermediateSteps,\n      runManager,\n      this.config\n    );\n  }\n\n  /**\n   * Process the output of the next step,\n   * handling AgentFinish and tool return cases.\n   */\n  async _processNextStepOutput(\n    nextStepOutput: AgentFinish | AgentStep[],\n    runManager?: CallbackManagerForChainRun\n  ): Promise<Record<string, string | AgentStep[]>> {\n    if (\"returnValues\" in nextStepOutput) {\n      const output = await this.agentExecutor._return(\n        nextStepOutput as AgentFinish,\n        this.intermediateSteps,\n        runManager\n      );\n      if (this.runManager) {\n        await this.runManager.handleChainEnd(output);\n      }\n      await this.setFinalOutputs(output);\n      return output;\n    }\n\n    this.intermediateSteps = this.intermediateSteps.concat(\n      nextStepOutput as AgentStep[]\n    );\n\n    let output: Record<string, string | AgentStep[]> = {};\n    if (Array.isArray(nextStepOutput) && nextStepOutput.length === 1) {\n      const nextStep = nextStepOutput[0];\n      const toolReturn = await this.agentExecutor._getToolReturn(nextStep);\n      if (toolReturn) {\n        output = await this.agentExecutor._return(\n          toolReturn,\n          this.intermediateSteps,\n          runManager\n        );\n        await this.runManager?.handleChainEnd(output);\n        await this.setFinalOutputs(output);\n      }\n    }\n    output = { intermediateSteps: nextStepOutput as AgentStep[] };\n    return output;\n  }\n\n  async _stop(): Promise<Record<string, unknown>> {\n    const output = await this.agentExecutor.agent.returnStoppedResponse(\n      this.agentExecutor.earlyStoppingMethod,\n      this.intermediateSteps,\n      this.inputs\n    );\n    const returnedOutput = await this.agentExecutor._return(\n      output,\n      this.intermediateSteps,\n      this.runManager\n    );\n    await this.setFinalOutputs(returnedOutput);\n    await this.runManager?.handleChainEnd(returnedOutput);\n    return returnedOutput;\n  }\n\n  async _callNext(): Promise<Record<string, unknown>> {\n    // final output already reached: stopiteration (final output)\n    if (this.finalOutputs) {\n      throw new Error(\n        `Final outputs already reached: ${JSON.stringify(\n          this.finalOutputs,\n          null,\n          2\n        )}`\n      );\n    }\n    // timeout/max iterations: stopiteration (stopped response)\n    if (!this.agentExecutor.shouldContinueGetter(this.iterations)) {\n      return this._stop();\n    }\n    const nextStepOutput = await this._executeNextStep(this.runManager);\n    const output = await this._processNextStepOutput(\n      nextStepOutput,\n      this.runManager\n    );\n    this.updateIterations();\n    return output;\n  }\n}\n\ntype ExtractToolType<T> = T extends { ToolType: infer ToolInterface }\n  ? ToolInterface\n  : StructuredToolInterface;\n\n/**\n * Interface defining the structure of input data for creating an\n * AgentExecutor. It extends ChainInputs and includes additional\n * properties specific to agent execution.\n */\nexport interface AgentExecutorInput extends ChainInputs {\n  agent:\n    | BaseSingleActionAgent\n    | BaseMultiActionAgent\n    | Runnable<\n        ChainValues & { steps?: AgentStep[] },\n        AgentAction[] | AgentAction | AgentFinish\n      >;\n  tools: ExtractToolType<this[\"agent\"]>[];\n  returnIntermediateSteps?: boolean;\n  maxIterations?: number;\n  earlyStoppingMethod?: StoppingMethod;\n  handleParsingErrors?:\n    | boolean\n    | string\n    | ((e: OutputParserException | ToolInputParsingException) => string);\n  handleToolRuntimeErrors?: (e: Error) => string;\n}\n\n// TODO: Type properly with { intermediateSteps?: AgentStep[] };\nexport type AgentExecutorOutput = ChainValues;\n\n/**\n * Tool that just returns the query.\n * Used for exception tracking.\n */\nexport class ExceptionTool extends Tool {\n  name = \"_Exception\";\n\n  description = \"Exception tool\";\n\n  async _call(query: string) {\n    return query;\n  }\n}\n\n/**\n * A chain managing an agent using tools.\n * @augments BaseChain\n * @example\n * ```typescript\n *\n * const executor = AgentExecutor.fromAgentAndTools({\n *   agent: async () => loadAgentFromLangchainHub(),\n *   tools: [new SerpAPI(), new Calculator()],\n *   returnIntermediateSteps: true,\n * });\n *\n * const result = await executor.invoke({\n *   input: `Who is Olivia Wilde's boyfriend? What is his current age raised to the 0.23 power?`,\n * });\n *\n * ```\n */\nexport class AgentExecutor extends BaseChain<ChainValues, AgentExecutorOutput> {\n  static lc_name() {\n    return \"AgentExecutor\";\n  }\n\n  get lc_namespace() {\n    return [\"langchain\", \"agents\", \"executor\"];\n  }\n\n  agent: BaseSingleActionAgent | BaseMultiActionAgent;\n\n  tools: this[\"agent\"][\"ToolType\"][];\n\n  returnIntermediateSteps = false;\n\n  maxIterations?: number = 15;\n\n  earlyStoppingMethod: StoppingMethod = \"force\";\n\n  // TODO: Update BaseChain implementation on breaking change to include this\n  returnOnlyOutputs = true;\n\n  /**\n   * How to handle errors raised by the agent's output parser.\n    Defaults to `False`, which raises the error.\n\n    If `true`, the error will be sent back to the LLM as an observation.\n    If a string, the string itself will be sent to the LLM as an observation.\n    If a callable function, the function will be called with the exception\n    as an argument, and the result of that function will be passed to the agent\n    as an observation.\n   */\n  handleParsingErrors:\n    | boolean\n    | string\n    | ((e: OutputParserException | ToolInputParsingException) => string) =\n    false;\n\n  handleToolRuntimeErrors?: (e: Error) => string;\n\n  get inputKeys() {\n    return this.agent.inputKeys;\n  }\n\n  get outputKeys() {\n    return this.agent.returnValues;\n  }\n\n  constructor(input: AgentExecutorInput) {\n    let agent: BaseSingleActionAgent | BaseMultiActionAgent;\n    let returnOnlyOutputs = true;\n    if (Runnable.isRunnable(input.agent)) {\n      if (AgentRunnableSequence.isAgentRunnableSequence(input.agent)) {\n        if (input.agent.singleAction) {\n          agent = new RunnableSingleActionAgent({\n            runnable: input.agent,\n            streamRunnable: input.agent.streamRunnable,\n          });\n        } else {\n          agent = new RunnableMultiActionAgent({\n            runnable: input.agent,\n            streamRunnable: input.agent.streamRunnable,\n          });\n        }\n      } else {\n        agent = new RunnableMultiActionAgent({ runnable: input.agent });\n      }\n      // TODO: Update BaseChain implementation on breaking change\n      returnOnlyOutputs = false;\n    } else {\n      if (isRunnableAgent(input.agent)) {\n        returnOnlyOutputs = false;\n      }\n      agent = input.agent;\n    }\n\n    super(input);\n    this.agent = agent;\n    this.tools = input.tools;\n    this.handleParsingErrors =\n      input.handleParsingErrors ?? this.handleParsingErrors;\n    this.handleToolRuntimeErrors = input.handleToolRuntimeErrors;\n    this.returnOnlyOutputs = returnOnlyOutputs;\n    if (this.agent._agentActionType() === \"multi\") {\n      for (const tool of this.tools) {\n        if (tool.returnDirect) {\n          throw new Error(\n            `Tool with return direct ${tool.name} not supported for multi-action agent.`\n          );\n        }\n      }\n    }\n    this.returnIntermediateSteps =\n      input.returnIntermediateSteps ?? this.returnIntermediateSteps;\n    this.maxIterations = input.maxIterations ?? this.maxIterations;\n    this.earlyStoppingMethod =\n      input.earlyStoppingMethod ?? this.earlyStoppingMethod;\n  }\n\n  /** Create from agent and a list of tools. */\n  static fromAgentAndTools(fields: AgentExecutorInput): AgentExecutor {\n    return new AgentExecutor(fields);\n  }\n\n  get shouldContinueGetter() {\n    return this.shouldContinue.bind(this);\n  }\n\n  /**\n   * Method that checks if the agent execution should continue based on the\n   * number of iterations.\n   * @param iterations The current number of iterations.\n   * @returns A boolean indicating whether the agent execution should continue.\n   */\n  private shouldContinue(iterations: number): boolean {\n    return this.maxIterations === undefined || iterations < this.maxIterations;\n  }\n\n  /** @ignore */\n  async _call(\n    inputs: ChainValues,\n    runManager?: CallbackManagerForChainRun,\n    config?: RunnableConfig\n  ): Promise<AgentExecutorOutput> {\n    const toolsByName = Object.fromEntries(\n      this.tools.map((t) => [t.name.toLowerCase(), t])\n    );\n    const steps: AgentStep[] = [];\n    let iterations = 0;\n\n    const getOutput = async (\n      finishStep: AgentFinish\n    ): Promise<AgentExecutorOutput> => {\n      const { returnValues } = finishStep;\n      const additional = await this.agent.prepareForOutput(returnValues, steps);\n\n      await runManager?.handleAgentEnd(finishStep);\n\n      let response;\n\n      if (this.returnIntermediateSteps) {\n        response = { ...returnValues, intermediateSteps: steps, ...additional };\n      } else {\n        response = { ...returnValues, ...additional };\n      }\n      if (!this.returnOnlyOutputs) {\n        response = { ...inputs, ...response };\n      }\n      return response;\n    };\n\n    while (this.shouldContinue(iterations)) {\n      let output;\n      try {\n        output = await this.agent.plan(\n          steps,\n          inputs,\n          runManager?.getChild(),\n          config\n        );\n      } catch (e) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (e instanceof OutputParserException) {\n          let observation;\n          let text = e.message;\n          if (this.handleParsingErrors === true) {\n            if (e.sendToLLM) {\n              observation = e.observation;\n              text = e.llmOutput ?? \"\";\n            } else {\n              observation = \"Invalid or incomplete response\";\n            }\n          } else if (typeof this.handleParsingErrors === \"string\") {\n            observation = this.handleParsingErrors;\n          } else if (typeof this.handleParsingErrors === \"function\") {\n            observation = this.handleParsingErrors(e);\n          } else {\n            throw e;\n          }\n          output = {\n            tool: \"_Exception\",\n            toolInput: observation,\n            log: text,\n          } as AgentAction;\n        } else {\n          throw e;\n        }\n      }\n      // Check if the agent has finished\n      if (\"returnValues\" in output) {\n        return getOutput(output);\n      }\n\n      let actions: AgentAction[];\n      if (Array.isArray(output)) {\n        actions = output as AgentAction[];\n      } else {\n        actions = [output as AgentAction];\n      }\n\n      const newSteps = await Promise.all(\n        actions.map(async (action) => {\n          await runManager?.handleAgentAction(action);\n          const tool =\n            action.tool === \"_Exception\"\n              ? new ExceptionTool()\n              : toolsByName[action.tool?.toLowerCase()];\n          let observation;\n          try {\n            observation = tool\n              ? await tool.invoke(\n                  action.toolInput,\n                  patchConfig(config, { callbacks: runManager?.getChild() })\n                )\n              : `${action.tool} is not a valid tool, try another one.`;\n            if (typeof observation !== \"string\") {\n              throw new Error(\n                \"Received unsupported non-string response from tool call.\"\n              );\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          } catch (e: any) {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (e instanceof ToolInputParsingException) {\n              if (this.handleParsingErrors === true) {\n                observation =\n                  \"Invalid or incomplete tool input. Please try again.\";\n              } else if (typeof this.handleParsingErrors === \"string\") {\n                observation = this.handleParsingErrors;\n              } else if (typeof this.handleParsingErrors === \"function\") {\n                observation = this.handleParsingErrors(e);\n              } else {\n                throw e;\n              }\n              observation = await new ExceptionTool().call(\n                observation,\n                runManager?.getChild()\n              );\n              return { action, observation: observation ?? \"\" };\n            } else if (this.handleToolRuntimeErrors !== undefined) {\n              observation = this.handleToolRuntimeErrors(e);\n            }\n          }\n\n          return { action, observation: observation ?? \"\" };\n        })\n      );\n\n      steps.push(...newSteps);\n\n      const lastStep = steps[steps.length - 1];\n      const lastTool = toolsByName[lastStep.action.tool?.toLowerCase()];\n\n      if (lastTool?.returnDirect) {\n        return getOutput({\n          returnValues: { [this.agent.returnValues[0]]: lastStep.observation },\n          log: \"\",\n        });\n      }\n\n      iterations += 1;\n    }\n\n    const finish = await this.agent.returnStoppedResponse(\n      this.earlyStoppingMethod,\n      steps,\n      inputs\n    );\n\n    return getOutput(finish);\n  }\n\n  async _takeNextStep(\n    nameToolMap: Record<string, ToolInterface>,\n    inputs: ChainValues,\n    intermediateSteps: AgentStep[],\n    runManager?: CallbackManagerForChainRun,\n    config?: RunnableConfig\n  ): Promise<AgentFinish | AgentStep[]> {\n    let output;\n    try {\n      output = await this.agent.plan(\n        intermediateSteps,\n        inputs,\n        runManager?.getChild(),\n        config\n      );\n    } catch (e) {\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      if (e instanceof OutputParserException) {\n        let observation;\n        let text = e.message;\n        if (this.handleParsingErrors === true) {\n          if (e.sendToLLM) {\n            observation = e.observation;\n            text = e.llmOutput ?? \"\";\n          } else {\n            observation = \"Invalid or incomplete response\";\n          }\n        } else if (typeof this.handleParsingErrors === \"string\") {\n          observation = this.handleParsingErrors;\n        } else if (typeof this.handleParsingErrors === \"function\") {\n          observation = this.handleParsingErrors(e);\n        } else {\n          throw e;\n        }\n        output = {\n          tool: \"_Exception\",\n          toolInput: observation,\n          log: text,\n        } as AgentAction;\n      } else {\n        throw e;\n      }\n    }\n\n    if (\"returnValues\" in output) {\n      return output;\n    }\n\n    let actions: AgentAction[];\n    if (Array.isArray(output)) {\n      actions = output as AgentAction[];\n    } else {\n      actions = [output as AgentAction];\n    }\n\n    const result: AgentStep[] = [];\n    for (const agentAction of actions) {\n      let observation = \"\";\n      if (runManager) {\n        await runManager?.handleAgentAction(agentAction);\n      }\n      if (agentAction.tool in nameToolMap) {\n        const tool = nameToolMap[agentAction.tool];\n        try {\n          observation = await tool.call(\n            agentAction.toolInput,\n            runManager?.getChild()\n          );\n          if (typeof observation !== \"string\") {\n            throw new Error(\n              \"Received unsupported non-string response from tool call.\"\n            );\n          }\n        } catch (e) {\n          // eslint-disable-next-line no-instanceof/no-instanceof\n          if (e instanceof ToolInputParsingException) {\n            if (this.handleParsingErrors === true) {\n              observation =\n                \"Invalid or incomplete tool input. Please try again.\";\n            } else if (typeof this.handleParsingErrors === \"string\") {\n              observation = this.handleParsingErrors;\n            } else if (typeof this.handleParsingErrors === \"function\") {\n              observation = this.handleParsingErrors(e);\n            } else {\n              throw e;\n            }\n            observation = await new ExceptionTool().call(\n              observation,\n              runManager?.getChild()\n            );\n          }\n        }\n      } else {\n        observation = `${\n          agentAction.tool\n        } is not a valid tool, try another available tool: ${Object.keys(\n          nameToolMap\n        ).join(\", \")}`;\n      }\n      result.push({\n        action: agentAction,\n        observation,\n      });\n    }\n    return result;\n  }\n\n  async _return(\n    output: AgentFinish,\n    intermediateSteps: AgentStep[],\n    runManager?: CallbackManagerForChainRun\n  ): Promise<AgentExecutorOutput> {\n    if (runManager) {\n      await runManager.handleAgentEnd(output);\n    }\n    const finalOutput: Record<string, unknown> = output.returnValues;\n    if (this.returnIntermediateSteps) {\n      finalOutput.intermediateSteps = intermediateSteps;\n    }\n    return finalOutput;\n  }\n\n  async _getToolReturn(nextStepOutput: AgentStep): Promise<AgentFinish | null> {\n    const { action, observation } = nextStepOutput;\n    const nameToolMap = Object.fromEntries(\n      this.tools.map((t) => [t.name.toLowerCase(), t])\n    );\n    const [returnValueKey = \"output\"] = this.agent.returnValues;\n    // Invalid tools won't be in the map, so we return False.\n    if (action.tool in nameToolMap) {\n      if (nameToolMap[action.tool].returnDirect) {\n        return {\n          returnValues: { [returnValueKey]: observation },\n          log: \"\",\n        };\n      }\n    }\n    return null;\n  }\n\n  _returnStoppedResponse(earlyStoppingMethod: StoppingMethod) {\n    if (earlyStoppingMethod === \"force\") {\n      return {\n        returnValues: {\n          output: \"Agent stopped due to iteration limit or time limit.\",\n        },\n        log: \"\",\n      } as AgentFinish;\n    }\n    throw new Error(\n      `Got unsupported early_stopping_method: ${earlyStoppingMethod}`\n    );\n  }\n\n  async *_streamIterator(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    inputs: Record<string, any>,\n    options?: Partial<RunnableConfig>\n  ): AsyncGenerator<ChainValues> {\n    const agentExecutorIterator = new AgentExecutorIterator({\n      inputs,\n      agentExecutor: this,\n      config: options,\n      // TODO: Deprecate these other parameters\n      metadata: options?.metadata,\n      tags: options?.tags,\n      callbacks: options?.callbacks,\n    });\n    const iterator = agentExecutorIterator.streamIterator();\n    for await (const step of iterator) {\n      if (!step) {\n        continue;\n      }\n      yield step;\n    }\n  }\n\n  _chainType() {\n    return \"agent_executor\" as const;\n  }\n\n  serialize(): SerializedLLMChain {\n    throw new Error(\"Cannot serialize an AgentExecutor\");\n  }\n}\n"],"mappings":";;;;;;;;;;AA8CA,IAAa,wBAAb,cACUA,gDAEV;CACE,eAAe;EAAC;EAAa;EAAU;CAAoB;CAE3D;CAEA;CAEA;;CAGA;;CAGA;;CAGA;;CAGA;CAEA,AAAQ;CAER,IAAI,eAAoD;AACtD,SAAO,KAAK;CACb;;CAGD,MAAM,gBAAgBC,OAA4C;EAChE,KAAK,gBAAgB;AACrB,MAAI,OAAO;GACT,MAAMC,kBACJ,MAAM,KAAK,cAAc,YAAY,KAAK,QAAQ,OAAO,KAAK;GAChE,KAAK,gBAAgB;EACtB;CACF;CAED;CAEA,oBAAiC,CAAE;CAEnC,aAAa;CAEb,IAAI,gBAA+C;EACjD,MAAM,UAAU,KAAK,cAAc,MAAM,IAAI,CAAC,UAAU,GACrD,KAAK,OAAO,KACd,GAAE;AACH,SAAO,OAAO,OAAO,CAAE,GAAE,GAAG,QAAQ;CACrC;CAED,YAAYC,QAAoC;EAC9C,MAAM,OAAO;EACb,KAAK,gBAAgB,OAAO;EAC5B,KAAK,SAAS,OAAO;EACrB,KAAK,YAAY,OAAO;EACxB,KAAK,OAAO,OAAO;EACnB,KAAK,WAAW,OAAO;EACvB,KAAK,UAAU,OAAO;EACtB,KAAK,aAAa,OAAO;EACzB,KAAK,SAAS,OAAO;CACtB;;;;;CAMD,QAAc;EACZ,KAAK,oBAAoB,CAAE;EAC3B,KAAK,aAAa;EAClB,KAAK,gBAAgB;CACtB;CAED,mBAAyB;EACvB,KAAK,cAAc;CACpB;CAED,OAAO,iBAAiB;EACtB,KAAK,OAAO;AAGZ,SAAO,KACL,KAAI;AACF,OAAI,KAAK,eAAe,GACtB,MAAM,KAAK,aAAa;GAG1B,MAAM,SAAS,MAAM,KAAK,WAAW;GACrC,MAAM;EAEP,SAAQC,GAAQ;AACf,OACE,aAAa,KACb,EAAE,QAAQ,WAAW,kCAAkC,EACvD;AACA,QAAI,CAAC,KAAK,aACR,OAAM;AAER,WAAO,KAAK;GACb;AACD,OAAI,KAAK,YACP,MAAM,KAAK,WAAW,iBAAiB,EAAE;AAE3C,SAAM;EACP;CAEJ;;;;;CAMD,MAAM,cAA6B;AACjC,MAAI,KAAK,eAAe,GAAG;GACzB,MAAM,kBAAkB,MAAMC,mDAAgB,UAC5C,KAAK,aAAa,KAAK,QAAQ,WAC/B,KAAK,cAAc,WACnB,KAAK,QAAQ,KAAK,QAAQ,MAC1B,KAAK,cAAc,MACnB,KAAK,YAAY,KAAK,QAAQ,UAC9B,KAAK,cAAc,UACnB,EACE,SAAS,KAAK,cAAc,QAC7B,EACF;GACD,KAAK,aAAa,MAAM,iBAAiB,iBACvC,KAAK,cAAc,QAAQ,EAC3B,KAAK,QACL,KAAK,QAAQ,OACb,QACA,KAAK,QAAQ,KAAK,QAAQ,MAC1B,KAAK,YAAY,KAAK,QAAQ,UAC9B,KAAK,WAAW,KAAK,QAAQ,QAC9B;AACD,OAAI,KAAK,WAAW,QAClB,OAAO,KAAK,OAAO;EAEtB;CACF;;;;;CAMD,MAAM,iBACJC,YACoC;AACpC,SAAO,KAAK,cAAc,cACxB,KAAK,eACL,KAAK,QACL,KAAK,mBACL,YACA,KAAK,OACN;CACF;;;;;CAMD,MAAM,uBACJC,gBACAD,YAC+C;AAC/C,MAAI,kBAAkB,gBAAgB;GACpC,MAAME,WAAS,MAAM,KAAK,cAAc,QACtC,gBACA,KAAK,mBACL,WACD;AACD,OAAI,KAAK,YACP,MAAM,KAAK,WAAW,eAAeA,SAAO;GAE9C,MAAM,KAAK,gBAAgBA,SAAO;AAClC,UAAOA;EACR;EAED,KAAK,oBAAoB,KAAK,kBAAkB,OAC9C,eACD;EAED,IAAIC,SAA+C,CAAE;AACrD,MAAI,MAAM,QAAQ,eAAe,IAAI,eAAe,WAAW,GAAG;GAChE,MAAM,WAAW,eAAe;GAChC,MAAM,aAAa,MAAM,KAAK,cAAc,eAAe,SAAS;AACpE,OAAI,YAAY;IACd,SAAS,MAAM,KAAK,cAAc,QAChC,YACA,KAAK,mBACL,WACD;IACD,MAAM,KAAK,YAAY,eAAe,OAAO;IAC7C,MAAM,KAAK,gBAAgB,OAAO;GACnC;EACF;EACD,SAAS,EAAE,mBAAmB,eAA+B;AAC7D,SAAO;CACR;CAED,MAAM,QAA0C;EAC9C,MAAM,SAAS,MAAM,KAAK,cAAc,MAAM,sBAC5C,KAAK,cAAc,qBACnB,KAAK,mBACL,KAAK,OACN;EACD,MAAM,iBAAiB,MAAM,KAAK,cAAc,QAC9C,QACA,KAAK,mBACL,KAAK,WACN;EACD,MAAM,KAAK,gBAAgB,eAAe;EAC1C,MAAM,KAAK,YAAY,eAAe,eAAe;AACrD,SAAO;CACR;CAED,MAAM,YAA8C;AAElD,MAAI,KAAK,aACP,OAAM,IAAI,MACR,CAAC,+BAA+B,EAAE,KAAK,UACrC,KAAK,cACL,MACA,EACD,EAAE;AAIP,MAAI,CAAC,KAAK,cAAc,qBAAqB,KAAK,WAAW,CAC3D,QAAO,KAAK,OAAO;EAErB,MAAM,iBAAiB,MAAM,KAAK,iBAAiB,KAAK,WAAW;EACnE,MAAM,SAAS,MAAM,KAAK,uBACxB,gBACA,KAAK,WACN;EACD,KAAK,kBAAkB;AACvB,SAAO;CACR;AACF;;;;;AAqCD,IAAa,gBAAb,cAAmCC,4BAAK;CACtC,OAAO;CAEP,cAAc;CAEd,MAAM,MAAMC,OAAe;AACzB,SAAO;CACR;AACF;;;;;;;;;;;;;;;;;;;AAoBD,IAAa,gBAAb,MAAa,sBAAsBC,uBAA4C;CAC7E,OAAO,UAAU;AACf,SAAO;CACR;CAED,IAAI,eAAe;AACjB,SAAO;GAAC;GAAa;GAAU;EAAW;CAC3C;CAED;CAEA;CAEA,0BAA0B;CAE1B,gBAAyB;CAEzB,sBAAsC;CAGtC,oBAAoB;;;;;;;;;;;CAYpB,sBAIE;CAEF;CAEA,IAAI,YAAY;AACd,SAAO,KAAK,MAAM;CACnB;CAED,IAAI,aAAa;AACf,SAAO,KAAK,MAAM;CACnB;CAED,YAAYC,OAA2B;EACrC,IAAIC;EACJ,IAAI,oBAAoB;AACxB,MAAIC,oCAAS,WAAW,MAAM,MAAM,EAAE;AACpC,OAAIC,oCAAsB,wBAAwB,MAAM,MAAM,CAC5D,KAAI,MAAM,MAAM,cACd,QAAQ,IAAIC,wCAA0B;IACpC,UAAU,MAAM;IAChB,gBAAgB,MAAM,MAAM;GAC7B;QAED,QAAQ,IAAIC,uCAAyB;IACnC,UAAU,MAAM;IAChB,gBAAgB,MAAM,MAAM;GAC7B;QAGH,QAAQ,IAAIA,uCAAyB,EAAE,UAAU,MAAM,MAAO;GAGhE,oBAAoB;EACrB,OAAM;AACL,OAAIC,8BAAgB,MAAM,MAAM,EAC9B,oBAAoB;GAEtB,QAAQ,MAAM;EACf;EAED,MAAM,MAAM;EACZ,KAAK,QAAQ;EACb,KAAK,QAAQ,MAAM;EACnB,KAAK,sBACH,MAAM,uBAAuB,KAAK;EACpC,KAAK,0BAA0B,MAAM;EACrC,KAAK,oBAAoB;AACzB,MAAI,KAAK,MAAM,kBAAkB,KAAK,SACpC;QAAK,MAAM,QAAQ,KAAK,MACtB,KAAI,KAAK,aACP,OAAM,IAAI,MACR,CAAC,wBAAwB,EAAE,KAAK,KAAK,sCAAsC,CAAC;EAGjF;EAEH,KAAK,0BACH,MAAM,2BAA2B,KAAK;EACxC,KAAK,gBAAgB,MAAM,iBAAiB,KAAK;EACjD,KAAK,sBACH,MAAM,uBAAuB,KAAK;CACrC;;CAGD,OAAO,kBAAkBC,QAA2C;AAClE,SAAO,IAAI,cAAc;CAC1B;CAED,IAAI,uBAAuB;AACzB,SAAO,KAAK,eAAe,KAAK,KAAK;CACtC;;;;;;;CAQD,AAAQ,eAAeC,YAA6B;AAClD,SAAO,KAAK,kBAAkB,UAAa,aAAa,KAAK;CAC9D;;CAGD,MAAM,MACJC,QACAhB,YACAiB,QAC8B;EAC9B,MAAM,cAAc,OAAO,YACzB,KAAK,MAAM,IAAI,CAAC,MAAM,CAAC,EAAE,KAAK,aAAa,EAAE,CAAE,EAAC,CACjD;EACD,MAAMC,QAAqB,CAAE;EAC7B,IAAI,aAAa;EAEjB,MAAM,YAAY,OAChBC,eACiC;GACjC,MAAM,EAAE,cAAc,GAAG;GACzB,MAAM,aAAa,MAAM,KAAK,MAAM,iBAAiB,cAAc,MAAM;GAEzE,MAAM,YAAY,eAAe,WAAW;GAE5C,IAAI;AAEJ,OAAI,KAAK,yBACP,WAAW;IAAE,GAAG;IAAc,mBAAmB;IAAO,GAAG;GAAY;QAEvE,WAAW;IAAE,GAAG;IAAc,GAAG;GAAY;AAE/C,OAAI,CAAC,KAAK,mBACR,WAAW;IAAE,GAAG;IAAQ,GAAG;GAAU;AAEvC,UAAO;EACR;AAED,SAAO,KAAK,eAAe,WAAW,EAAE;GACtC,IAAI;AACJ,OAAI;IACF,SAAS,MAAM,KAAK,MAAM,KACxB,OACA,QACA,YAAY,UAAU,EACtB,OACD;GACF,SAAQ,GAAG;AAEV,QAAI,aAAaC,uDAAuB;KACtC,IAAI;KACJ,IAAI,OAAO,EAAE;AACb,SAAI,KAAK,wBAAwB,KAC/B,KAAI,EAAE,WAAW;MACf,cAAc,EAAE;MAChB,OAAO,EAAE,aAAa;KACvB,OACC,cAAc;cAEP,OAAO,KAAK,wBAAwB,UAC7C,cAAc,KAAK;cACV,OAAO,KAAK,wBAAwB,YAC7C,cAAc,KAAK,oBAAoB,EAAE;SAEzC,OAAM;KAER,SAAS;MACP,MAAM;MACN,WAAW;MACX,KAAK;KACN;IACF,MACC,OAAM;GAET;AAED,OAAI,kBAAkB,OACpB,QAAO,UAAU,OAAO;GAG1B,IAAIC;AACJ,OAAI,MAAM,QAAQ,OAAO,EACvB,UAAU;QAEV,UAAU,CAAC,MAAsB;GAGnC,MAAM,WAAW,MAAM,QAAQ,IAC7B,QAAQ,IAAI,OAAO,WAAW;IAC5B,MAAM,YAAY,kBAAkB,OAAO;IAC3C,MAAM,OACJ,OAAO,SAAS,eACZ,IAAI,kBACJ,YAAY,OAAO,MAAM,aAAa;IAC5C,IAAI;AACJ,QAAI;KACF,cAAc,OACV,MAAM,KAAK,OACT,OAAO,uDACK,QAAQ,EAAE,WAAW,YAAY,UAAU,CAAE,EAAC,CAC3D,GACD,GAAG,OAAO,KAAK,sCAAsC,CAAC;AAC1D,SAAI,OAAO,gBAAgB,SACzB,OAAM,IAAI,MACR;IAIL,SAAQvB,GAAQ;AAEf,SAAI,aAAawB,kDAA2B;AAC1C,UAAI,KAAK,wBAAwB,MAC/B,cACE;eACO,OAAO,KAAK,wBAAwB,UAC7C,cAAc,KAAK;eACV,OAAO,KAAK,wBAAwB,YAC7C,cAAc,KAAK,oBAAoB,EAAE;UAEzC,OAAM;MAER,cAAc,MAAM,IAAI,gBAAgB,KACtC,aACA,YAAY,UAAU,CACvB;AACD,aAAO;OAAE;OAAQ,aAAa,eAAe;MAAI;KAClD,WAAU,KAAK,4BAA4B,QAC1C,cAAc,KAAK,wBAAwB,EAAE;IAEhD;AAED,WAAO;KAAE;KAAQ,aAAa,eAAe;IAAI;GAClD,EAAC,CACH;GAED,MAAM,KAAK,GAAG,SAAS;GAEvB,MAAM,WAAW,MAAM,MAAM,SAAS;GACtC,MAAM,WAAW,YAAY,SAAS,OAAO,MAAM,aAAa;AAEhE,OAAI,UAAU,aACZ,QAAO,UAAU;IACf,cAAc,GAAG,KAAK,MAAM,aAAa,KAAK,SAAS,YAAa;IACpE,KAAK;GACN,EAAC;GAGJ,cAAc;EACf;EAED,MAAM,SAAS,MAAM,KAAK,MAAM,sBAC9B,KAAK,qBACL,OACA,OACD;AAED,SAAO,UAAU,OAAO;CACzB;CAED,MAAM,cACJC,aACAP,QACAQ,mBACAxB,YACAiB,QACoC;EACpC,IAAI;AACJ,MAAI;GACF,SAAS,MAAM,KAAK,MAAM,KACxB,mBACA,QACA,YAAY,UAAU,EACtB,OACD;EACF,SAAQ,GAAG;AAEV,OAAI,aAAaG,uDAAuB;IACtC,IAAI;IACJ,IAAI,OAAO,EAAE;AACb,QAAI,KAAK,wBAAwB,KAC/B,KAAI,EAAE,WAAW;KACf,cAAc,EAAE;KAChB,OAAO,EAAE,aAAa;IACvB,OACC,cAAc;aAEP,OAAO,KAAK,wBAAwB,UAC7C,cAAc,KAAK;aACV,OAAO,KAAK,wBAAwB,YAC7C,cAAc,KAAK,oBAAoB,EAAE;QAEzC,OAAM;IAER,SAAS;KACP,MAAM;KACN,WAAW;KACX,KAAK;IACN;GACF,MACC,OAAM;EAET;AAED,MAAI,kBAAkB,OACpB,QAAO;EAGT,IAAIC;AACJ,MAAI,MAAM,QAAQ,OAAO,EACvB,UAAU;OAEV,UAAU,CAAC,MAAsB;EAGnC,MAAMI,SAAsB,CAAE;AAC9B,OAAK,MAAM,eAAe,SAAS;GACjC,IAAI,cAAc;AAClB,OAAI,YACF,MAAM,YAAY,kBAAkB,YAAY;AAElD,OAAI,YAAY,QAAQ,aAAa;IACnC,MAAM,OAAO,YAAY,YAAY;AACrC,QAAI;KACF,cAAc,MAAM,KAAK,KACvB,YAAY,WACZ,YAAY,UAAU,CACvB;AACD,SAAI,OAAO,gBAAgB,SACzB,OAAM,IAAI,MACR;IAGL,SAAQ,GAAG;AAEV,SAAI,aAAaH,kDAA2B;AAC1C,UAAI,KAAK,wBAAwB,MAC/B,cACE;eACO,OAAO,KAAK,wBAAwB,UAC7C,cAAc,KAAK;eACV,OAAO,KAAK,wBAAwB,YAC7C,cAAc,KAAK,oBAAoB,EAAE;UAEzC,OAAM;MAER,cAAc,MAAM,IAAI,gBAAgB,KACtC,aACA,YAAY,UAAU,CACvB;KACF;IACF;GACF,OACC,cAAc,GACZ,YAAY,KACb,kDAAkD,EAAE,OAAO,KAC1D,YACD,CAAC,KAAK,KAAK,EAAE;GAEhB,OAAO,KAAK;IACV,QAAQ;IACR;GACD,EAAC;EACH;AACD,SAAO;CACR;CAED,MAAM,QACJI,QACAF,mBACAxB,YAC8B;AAC9B,MAAI,YACF,MAAM,WAAW,eAAe,OAAO;EAEzC,MAAM2B,cAAuC,OAAO;AACpD,MAAI,KAAK,yBACP,YAAY,oBAAoB;AAElC,SAAO;CACR;CAED,MAAM,eAAeC,gBAAwD;EAC3E,MAAM,EAAE,QAAQ,aAAa,GAAG;EAChC,MAAM,cAAc,OAAO,YACzB,KAAK,MAAM,IAAI,CAAC,MAAM,CAAC,EAAE,KAAK,aAAa,EAAE,CAAE,EAAC,CACjD;EACD,MAAM,CAAC,iBAAiB,SAAS,GAAG,KAAK,MAAM;AAE/C,MAAI,OAAO,QAAQ,aACjB;OAAI,YAAY,OAAO,MAAM,aAC3B,QAAO;IACL,cAAc,GAAG,iBAAiB,YAAa;IAC/C,KAAK;GACN;EACF;AAEH,SAAO;CACR;CAED,uBAAuBC,qBAAqC;AAC1D,MAAI,wBAAwB,QAC1B,QAAO;GACL,cAAc,EACZ,QAAQ,sDACT;GACD,KAAK;EACN;AAEH,QAAM,IAAI,MACR,CAAC,uCAAuC,EAAE,qBAAqB;CAElE;CAED,OAAO,gBAELC,QACAC,SAC6B;EAC7B,MAAM,wBAAwB,IAAI,sBAAsB;GACtD;GACA,eAAe;GACf,QAAQ;GAER,UAAU,SAAS;GACnB,MAAM,SAAS;GACf,WAAW,SAAS;EACrB;EACD,MAAM,WAAW,sBAAsB,gBAAgB;AACvD,aAAW,MAAM,QAAQ,UAAU;AACjC,OAAI,CAAC,KACH;GAEF,MAAM;EACP;CACF;CAED,aAAa;AACX,SAAO;CACR;CAED,YAAgC;AAC9B,QAAM,IAAI,MAAM;CACjB;AACF"}