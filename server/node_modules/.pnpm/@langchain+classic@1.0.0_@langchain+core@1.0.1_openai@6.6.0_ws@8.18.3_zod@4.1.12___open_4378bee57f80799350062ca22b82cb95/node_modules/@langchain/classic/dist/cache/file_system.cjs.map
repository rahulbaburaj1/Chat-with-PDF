{"version":3,"file":"file_system.cjs","names":["BaseCache","cacheDir: string","cacheDir?: string","fs","prompt: string","llmKey: string","path","deserializeStoredGeneration","generations: Generation[]","serializeGeneration"],"sources":["../../src/cache/file_system.ts"],"sourcesContent":["import path from \"node:path\";\nimport fs from \"node:fs/promises\";\n\nimport {\n  BaseCache,\n  serializeGeneration,\n  deserializeStoredGeneration,\n} from \"@langchain/core/caches\";\nimport { Generation } from \"@langchain/core/outputs\";\n\n/**\n * A cache that uses the local filesystem as the backing store.\n * This is useful for local development and testing. But it is not recommended for production use.\n */\nexport class LocalFileCache extends BaseCache {\n  private cacheDir: string;\n\n  private constructor(cacheDir: string) {\n    super();\n    this.cacheDir = cacheDir;\n  }\n\n  /**\n   * Create a new cache backed by the local filesystem.\n   * It ensures that the cache directory exists before returning.\n   * @param cacheDir\n   */\n  public static async create(cacheDir?: string): Promise<LocalFileCache> {\n    if (!cacheDir) {\n      // eslint-disable-next-line no-param-reassign\n      cacheDir = await fs.mkdtemp(\"langchain-cache-\");\n    } else {\n      // ensure the cache directory exists\n      await fs.mkdir(cacheDir, { recursive: true });\n    }\n    return new LocalFileCache(cacheDir);\n  }\n\n  /**\n   * Retrieves data from the cache. It constructs a cache key from the given\n   * `prompt` and `llmKey`, and retrieves the corresponding value from the\n   * cache files.\n   * @param prompt The prompt used to construct the cache key.\n   * @param llmKey The LLM key used to construct the cache key.\n   * @returns An array of Generations if found, null otherwise.\n   */\n  public async lookup(prompt: string, llmKey: string) {\n    const key = `${this.keyEncoder(prompt, llmKey)}.json`;\n    try {\n      const content = await fs.readFile(path.join(this.cacheDir, key));\n      return JSON.parse(content.toString()).map(deserializeStoredGeneration);\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Updates the cache with new data. It constructs a cache key from the\n   * given `prompt` and `llmKey`, and stores the `value` in a specific\n   * file in the cache directory.\n   * @param prompt The prompt used to construct the cache key.\n   * @param llmKey The LLM key used to construct the cache key.\n   * @param generations The value to be stored in the cache.\n   */\n  public async update(\n    prompt: string,\n    llmKey: string,\n    generations: Generation[]\n  ) {\n    const key = `${this.keyEncoder(prompt, llmKey)}.json`;\n    await fs.writeFile(\n      path.join(this.cacheDir, key),\n      JSON.stringify(generations.map(serializeGeneration))\n    );\n  }\n}\n"],"mappings":";;;;;;;;;;;;AAcA,IAAa,iBAAb,MAAa,uBAAuBA,kCAAU;CAC5C,AAAQ;CAER,AAAQ,YAAYC,UAAkB;EACpC,OAAO;EACP,KAAK,WAAW;CACjB;;;;;;CAOD,aAAoB,OAAOC,UAA4C;AACrE,MAAI,CAAC,UAEH,WAAW,MAAMC,yBAAG,QAAQ,mBAAmB;OAG/C,MAAMA,yBAAG,MAAM,UAAU,EAAE,WAAW,KAAM,EAAC;AAE/C,SAAO,IAAI,eAAe;CAC3B;;;;;;;;;CAUD,MAAa,OAAOC,QAAgBC,QAAgB;EAClD,MAAM,MAAM,GAAG,KAAK,WAAW,QAAQ,OAAO,CAAC,KAAK,CAAC;AACrD,MAAI;GACF,MAAM,UAAU,MAAMF,yBAAG,SAASG,kBAAK,KAAK,KAAK,UAAU,IAAI,CAAC;AAChE,UAAO,KAAK,MAAM,QAAQ,UAAU,CAAC,CAAC,IAAIC,oDAA4B;EACvE,QAAO;AACN,UAAO;EACR;CACF;;;;;;;;;CAUD,MAAa,OACXH,QACAC,QACAG,aACA;EACA,MAAM,MAAM,GAAG,KAAK,WAAW,QAAQ,OAAO,CAAC,KAAK,CAAC;EACrD,MAAML,yBAAG,UACPG,kBAAK,KAAK,KAAK,UAAU,IAAI,EAC7B,KAAK,UAAU,YAAY,IAAIG,4CAAoB,CAAC,CACrD;CACF;AACF"}