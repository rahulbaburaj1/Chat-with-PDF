{"version":3,"file":"encoder_backed.js","names":["fields: {\n    store: BaseStore<string, SerializedType>;\n    keyEncoder: (key: K) => string;\n    valueSerializer: (value: V) => SerializedType;\n    valueDeserializer: (value: SerializedType) => V;\n  }","keys: K[]","keyValuePairs: [K, V][]","encodedPairs: [string, SerializedType][]","prefix?: string | undefined","store: BaseStore<string, Uint8Array>","key: string","doc: Document","bytes: Uint8Array"],"sources":["../../src/storage/encoder_backed.ts"],"sourcesContent":["import { Document } from \"@langchain/core/documents\";\nimport { BaseStore } from \"@langchain/core/stores\";\n\n/**\n * Class that provides a layer of abstraction over the base storage,\n * allowing for the encoding and decoding of keys and values. It extends\n * the BaseStore class.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class EncoderBackedStore<K, V, SerializedType = any> extends BaseStore<\n  K,\n  V\n> {\n  lc_namespace = [\"langchain\", \"storage\"];\n\n  store: BaseStore<string, SerializedType>;\n\n  keyEncoder: (key: K) => string;\n\n  valueSerializer: (value: V) => SerializedType;\n\n  valueDeserializer: (value: SerializedType) => V;\n\n  constructor(fields: {\n    store: BaseStore<string, SerializedType>;\n    keyEncoder: (key: K) => string;\n    valueSerializer: (value: V) => SerializedType;\n    valueDeserializer: (value: SerializedType) => V;\n  }) {\n    super(fields);\n    this.store = fields.store;\n    this.keyEncoder = fields.keyEncoder;\n    this.valueSerializer = fields.valueSerializer;\n    this.valueDeserializer = fields.valueDeserializer;\n  }\n\n  /**\n   * Method to get multiple keys at once. It works with the encoded keys and\n   * serialized values.\n   * @param keys Array of keys to get\n   * @returns Promise that resolves with an array of values or undefined for each key\n   */\n  async mget(keys: K[]): Promise<(V | undefined)[]> {\n    const encodedKeys = keys.map(this.keyEncoder);\n    const values = await this.store.mget(encodedKeys);\n    return values.map((value) => {\n      if (value === undefined) {\n        return undefined;\n      }\n      return this.valueDeserializer(value);\n    });\n  }\n\n  /**\n   * Method to set multiple keys at once. It works with the encoded keys and\n   * serialized values.\n   * @param keyValuePairs Array of key-value pairs to set\n   * @returns Promise that resolves when the operation is complete\n   */\n  async mset(keyValuePairs: [K, V][]): Promise<void> {\n    const encodedPairs: [string, SerializedType][] = keyValuePairs.map(\n      ([key, value]) => [this.keyEncoder(key), this.valueSerializer(value)]\n    );\n    return this.store.mset(encodedPairs);\n  }\n\n  /**\n   * Method to delete multiple keys at once. It works with the encoded keys.\n   * @param keys Array of keys to delete\n   * @returns Promise that resolves when the operation is complete\n   */\n  async mdelete(keys: K[]): Promise<void> {\n    const encodedKeys = keys.map(this.keyEncoder);\n    return this.store.mdelete(encodedKeys);\n  }\n\n  /**\n   * Method to yield keys. It works with the encoded keys.\n   * @param prefix Optional prefix to filter keys\n   * @returns AsyncGenerator that yields keys\n   */\n  async *yieldKeys(prefix?: string | undefined): AsyncGenerator<string | K> {\n    yield* this.store.yieldKeys(prefix);\n  }\n}\n\nexport function createDocumentStoreFromByteStore(\n  store: BaseStore<string, Uint8Array>\n) {\n  const encoder = new TextEncoder();\n  const decoder = new TextDecoder();\n  return new EncoderBackedStore({\n    store,\n    keyEncoder: (key: string) => key,\n    valueSerializer: (doc: Document) =>\n      encoder.encode(\n        JSON.stringify({ pageContent: doc.pageContent, metadata: doc.metadata })\n      ),\n    valueDeserializer: (bytes: Uint8Array) =>\n      new Document(JSON.parse(decoder.decode(bytes))),\n  });\n}\n"],"mappings":";;;;;;;;;;;;;;;AASA,IAAa,qBAAb,cAAoE,UAGlE;CACA,eAAe,CAAC,aAAa,SAAU;CAEvC;CAEA;CAEA;CAEA;CAEA,YAAYA,QAKT;EACD,MAAM,OAAO;EACb,KAAK,QAAQ,OAAO;EACpB,KAAK,aAAa,OAAO;EACzB,KAAK,kBAAkB,OAAO;EAC9B,KAAK,oBAAoB,OAAO;CACjC;;;;;;;CAQD,MAAM,KAAKC,MAAuC;EAChD,MAAM,cAAc,KAAK,IAAI,KAAK,WAAW;EAC7C,MAAM,SAAS,MAAM,KAAK,MAAM,KAAK,YAAY;AACjD,SAAO,OAAO,IAAI,CAAC,UAAU;AAC3B,OAAI,UAAU,OACZ,QAAO;AAET,UAAO,KAAK,kBAAkB,MAAM;EACrC,EAAC;CACH;;;;;;;CAQD,MAAM,KAAKC,eAAwC;EACjD,MAAMC,eAA2C,cAAc,IAC7D,CAAC,CAAC,KAAK,MAAM,KAAK,CAAC,KAAK,WAAW,IAAI,EAAE,KAAK,gBAAgB,MAAM,AAAC,EACtE;AACD,SAAO,KAAK,MAAM,KAAK,aAAa;CACrC;;;;;;CAOD,MAAM,QAAQF,MAA0B;EACtC,MAAM,cAAc,KAAK,IAAI,KAAK,WAAW;AAC7C,SAAO,KAAK,MAAM,QAAQ,YAAY;CACvC;;;;;;CAOD,OAAO,UAAUG,QAAyD;EACxE,OAAO,KAAK,MAAM,UAAU,OAAO;CACpC;AACF;AAED,SAAgB,iCACdC,OACA;CACA,MAAM,UAAU,IAAI;CACpB,MAAM,UAAU,IAAI;AACpB,QAAO,IAAI,mBAAmB;EAC5B;EACA,YAAY,CAACC,QAAgB;EAC7B,iBAAiB,CAACC,QAChB,QAAQ,OACN,KAAK,UAAU;GAAE,aAAa,IAAI;GAAa,UAAU,IAAI;EAAU,EAAC,CACzE;EACH,mBAAmB,CAACC,UAClB,IAAI,SAAS,KAAK,MAAM,QAAQ,OAAO,MAAM,CAAC;CACjD;AACF"}