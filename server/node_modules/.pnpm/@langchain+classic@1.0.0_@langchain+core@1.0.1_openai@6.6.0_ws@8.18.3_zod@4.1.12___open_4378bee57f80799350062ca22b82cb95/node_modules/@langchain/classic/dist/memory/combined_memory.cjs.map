{"version":3,"file":"combined_memory.cjs","names":["BaseChatMemory","fields?: CombinedMemoryInput","allVariables: string[]","inputValues: InputValues","memoryData: Record<string, unknown>","outputValues: OutputValues","memoryKeys: string[]"],"sources":["../../src/memory/combined_memory.ts"],"sourcesContent":["import {\n  InputValues,\n  MemoryVariables,\n  BaseMemory,\n  OutputValues,\n} from \"@langchain/core/memory\";\nimport { BaseChatMemory, BaseChatMemoryInput } from \"./chat_memory.js\";\n\n/**\n * Interface that defines the shape of the input object that the\n * CombinedMemory constructor accepts. It extends the BaseChatMemoryInput\n * interface and adds additional properties.\n */\nexport interface CombinedMemoryInput extends BaseChatMemoryInput {\n  memories: BaseMemory[];\n  humanPrefix?: string;\n  aiPrefix?: string;\n  memoryKey?: string;\n}\n\n/**\n * Class that manages and manipulates previous chat messages. It extends\n * from the BaseChatMemory class and implements the CombinedMemoryInput\n * interface.\n */\nexport class CombinedMemory\n  extends BaseChatMemory\n  implements CombinedMemoryInput\n{\n  humanPrefix = \"Human\";\n\n  aiPrefix = \"AI\";\n\n  memoryKey = \"history\";\n\n  memories: BaseMemory[] = [];\n\n  constructor(fields?: CombinedMemoryInput) {\n    super({\n      chatHistory: fields?.chatHistory,\n      returnMessages: fields?.returnMessages ?? false,\n      inputKey: fields?.inputKey,\n      outputKey: fields?.outputKey,\n    });\n\n    this.memories = fields?.memories ?? this.memories;\n    this.humanPrefix = fields?.humanPrefix ?? this.humanPrefix;\n    this.aiPrefix = fields?.aiPrefix ?? this.aiPrefix;\n    this.memoryKey = fields?.memoryKey ?? this.memoryKey;\n    this.checkRepeatedMemoryVariable();\n    this.checkInputKey();\n  }\n\n  /**\n   * Checks for repeated memory variables across all memory objects. Throws\n   * an error if any are found.\n   */\n  checkRepeatedMemoryVariable() {\n    const allVariables: string[] = [];\n    for (const memory of this.memories) {\n      const overlap = allVariables.filter((x) => memory.memoryKeys.includes(x));\n      if (overlap.length > 0) {\n        throw new Error(\n          `The same variables ${[\n            ...overlap,\n          ]} are found in multiple memory objects, which is not allowed by CombinedMemory.`\n        );\n      }\n      allVariables.push(...memory.memoryKeys);\n    }\n  }\n\n  /**\n   * Checks if input keys are set for all memory objects. Logs a warning if\n   * any are missing.\n   */\n  checkInputKey() {\n    for (const memory of this.memories) {\n      if (\n        (memory as BaseChatMemory).chatHistory !== undefined &&\n        (memory as BaseChatMemory).inputKey === undefined\n      ) {\n        console.warn(\n          `When using CombinedMemory, input keys should be set so the input is known. Was not set on ${memory}.`\n        );\n      }\n    }\n  }\n\n  /**\n   * Loads memory variables from all memory objects.\n   * @param inputValues Input values to load memory variables from.\n   * @returns Promise that resolves with an object containing the loaded memory variables.\n   */\n  async loadMemoryVariables(\n    inputValues: InputValues\n  ): Promise<MemoryVariables> {\n    let memoryData: Record<string, unknown> = {};\n\n    for (const memory of this.memories) {\n      const data = await memory.loadMemoryVariables(inputValues);\n      memoryData = {\n        ...memoryData,\n        ...data,\n      };\n    }\n    return memoryData;\n  }\n\n  /**\n   * Saves the context to all memory objects.\n   * @param inputValues Input values to save.\n   * @param outputValues Output values to save.\n   * @returns Promise that resolves when the context has been saved to all memory objects.\n   */\n  async saveContext(inputValues: InputValues, outputValues: OutputValues) {\n    for (const memory of this.memories) {\n      await memory.saveContext(inputValues, outputValues);\n    }\n  }\n\n  /**\n   * Clears all memory objects.\n   * @returns Promise that resolves when all memory objects have been cleared.\n   */\n  async clear() {\n    for (const memory of this.memories) {\n      if (typeof (memory as BaseChatMemory).clear === \"function\") {\n        await (memory as BaseChatMemory).clear();\n      }\n    }\n  }\n\n  get memoryKeys() {\n    const memoryKeys: string[] = [];\n    for (const memory of this.memories) {\n      memoryKeys.push(...memory.memoryKeys);\n    }\n    return memoryKeys;\n  }\n}\n"],"mappings":";;;;;;;;AAyBA,IAAa,iBAAb,cACUA,0CAEV;CACE,cAAc;CAEd,WAAW;CAEX,YAAY;CAEZ,WAAyB,CAAE;CAE3B,YAAYC,QAA8B;EACxC,MAAM;GACJ,aAAa,QAAQ;GACrB,gBAAgB,QAAQ,kBAAkB;GAC1C,UAAU,QAAQ;GAClB,WAAW,QAAQ;EACpB,EAAC;EAEF,KAAK,WAAW,QAAQ,YAAY,KAAK;EACzC,KAAK,cAAc,QAAQ,eAAe,KAAK;EAC/C,KAAK,WAAW,QAAQ,YAAY,KAAK;EACzC,KAAK,YAAY,QAAQ,aAAa,KAAK;EAC3C,KAAK,6BAA6B;EAClC,KAAK,eAAe;CACrB;;;;;CAMD,8BAA8B;EAC5B,MAAMC,eAAyB,CAAE;AACjC,OAAK,MAAM,UAAU,KAAK,UAAU;GAClC,MAAM,UAAU,aAAa,OAAO,CAAC,MAAM,OAAO,WAAW,SAAS,EAAE,CAAC;AACzE,OAAI,QAAQ,SAAS,EACnB,OAAM,IAAI,MACR,CAAC,mBAAmB,EAAE,CACpB,GAAG,OACJ,EAAC,8EAA8E,CAAC;GAGrF,aAAa,KAAK,GAAG,OAAO,WAAW;EACxC;CACF;;;;;CAMD,gBAAgB;AACd,OAAK,MAAM,UAAU,KAAK,SACxB,KACG,OAA0B,gBAAgB,UAC1C,OAA0B,aAAa,QAExC,QAAQ,KACN,CAAC,0FAA0F,EAAE,OAAO,CAAC,CAAC,CACvG;CAGN;;;;;;CAOD,MAAM,oBACJC,aAC0B;EAC1B,IAAIC,aAAsC,CAAE;AAE5C,OAAK,MAAM,UAAU,KAAK,UAAU;GAClC,MAAM,OAAO,MAAM,OAAO,oBAAoB,YAAY;GAC1D,aAAa;IACX,GAAG;IACH,GAAG;GACJ;EACF;AACD,SAAO;CACR;;;;;;;CAQD,MAAM,YAAYD,aAA0BE,cAA4B;AACtE,OAAK,MAAM,UAAU,KAAK,UACxB,MAAM,OAAO,YAAY,aAAa,aAAa;CAEtD;;;;;CAMD,MAAM,QAAQ;AACZ,OAAK,MAAM,UAAU,KAAK,SACxB,KAAI,OAAQ,OAA0B,UAAU,YAC9C,MAAO,OAA0B,OAAO;CAG7C;CAED,IAAI,aAAa;EACf,MAAMC,aAAuB,CAAE;AAC/B,OAAK,MAAM,UAAU,KAAK,UACxB,WAAW,KAAK,GAAG,OAAO,WAAW;AAEvC,SAAO;CACR;AACF"}