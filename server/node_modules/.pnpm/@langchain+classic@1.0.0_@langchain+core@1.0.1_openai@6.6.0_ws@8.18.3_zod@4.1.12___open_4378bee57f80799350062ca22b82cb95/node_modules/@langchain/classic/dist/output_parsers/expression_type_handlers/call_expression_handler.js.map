{"version":3,"file":"call_expression_handler.js","names":["node: ExpressionNode","node: CallExpression","arg: ExpressionNode"],"sources":["../../../src/output_parsers/expression_type_handlers/call_expression_handler.ts"],"sourcesContent":["import { NodeHandler, ASTParser } from \"./base.js\";\nimport { CallExpressionType, MemberExpressionType } from \"./types.js\";\nimport type {\n  ExpressionNode,\n  CallExpression,\n  MemberExpression,\n} from \"../../types/expression-parser.js\";\n\n/**\n * Handles call expressions in the AST parsed by the `ASTParser`. This\n * class is part of the LangChain Expression Language (LCEL), a\n * declarative way to compose chains together in LangChain.\n */\nexport class CallExpressionHandler extends NodeHandler {\n  /**\n   * Checks if a given node is a call expression. If it is, it returns the\n   * node; otherwise, it returns false.\n   * @param node The node to check.\n   * @returns The node if it is a call expression, or false otherwise.\n   */\n  async accepts(node: ExpressionNode): Promise<CallExpression | boolean> {\n    if (ASTParser.isCallExpression(node)) {\n      return node;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Processes a call expression node. It checks the type of the callee (the\n   * function being called) and the arguments passed to it. If the callee is\n   * an identifier, it extracts the function name. If the callee is a member\n   * expression, it delegates handling to the parent handler. It also checks\n   * the types of the arguments and delegates their handling to the parent\n   * handler. The method returns an object representing the call expression,\n   * including the function call and its arguments.\n   * @param node The call expression node to process.\n   * @returns An object representing the call expression, including the function call and its arguments.\n   */\n  async handle(node: CallExpression): Promise<CallExpressionType> {\n    function checkCallExpressionArgumentType(arg: ExpressionNode): boolean {\n      return [\n        ASTParser.isStringLiteral,\n        ASTParser.isNumericLiteral,\n        ASTParser.isBooleanLiteral,\n        ASTParser.isArrayExpression,\n        ASTParser.isObjectExpression,\n        ASTParser.isCallExpression,\n        ASTParser.isIdentifier,\n      ].reduce((acc, func) => acc || func(arg), false);\n    }\n    if (this.parentHandler === undefined) {\n      throw new Error(\n        \"ArrayLiteralExpressionHandler must have a parent handler\"\n      );\n    }\n    const { callee } = node;\n    let funcCall;\n    if (ASTParser.isIdentifier(callee)) {\n      funcCall = callee.name.replace(/^[\"'](.+(?=[\"']$))[\"']$/, \"$1\");\n    } else if (ASTParser.isMemberExpression(callee)) {\n      funcCall = (await this.parentHandler.handle(\n        callee as MemberExpression\n      )) as MemberExpressionType;\n    } else {\n      throw new Error(\"Unknown expression type\");\n    }\n\n    const args = await Promise.all(\n      node.arguments.map((arg) => {\n        if (!checkCallExpressionArgumentType(arg)) {\n          throw new Error(\"Unknown argument type\");\n        }\n        if (!this.parentHandler) {\n          throw new Error(\"CallExpressionHandler must have a parent handler\");\n        }\n        return this.parentHandler.handle(arg as ExpressionNode);\n      })\n    );\n    return { type: \"call_expression\", funcCall, args };\n  }\n}\n"],"mappings":";;;;;;;;AAaA,IAAa,wBAAb,cAA2C,YAAY;;;;;;;CAOrD,MAAM,QAAQA,MAAyD;AACrE,MAAI,UAAU,iBAAiB,KAAK,CAClC,QAAO;MAEP,QAAO;CAEV;;;;;;;;;;;;CAaD,MAAM,OAAOC,MAAmD;EAC9D,SAAS,gCAAgCC,KAA8B;AACrE,UAAO;IACL,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;GACX,EAAC,OAAO,CAAC,KAAK,SAAS,OAAO,KAAK,IAAI,EAAE,MAAM;EACjD;AACD,MAAI,KAAK,kBAAkB,OACzB,OAAM,IAAI,MACR;EAGJ,MAAM,EAAE,QAAQ,GAAG;EACnB,IAAI;AACJ,MAAI,UAAU,aAAa,OAAO,EAChC,WAAW,OAAO,KAAK,QAAQ,2BAA2B,KAAK;WACtD,UAAU,mBAAmB,OAAO,EAC7C,WAAY,MAAM,KAAK,cAAc,OACnC,OACD;MAED,OAAM,IAAI,MAAM;EAGlB,MAAM,OAAO,MAAM,QAAQ,IACzB,KAAK,UAAU,IAAI,CAAC,QAAQ;AAC1B,OAAI,CAAC,gCAAgC,IAAI,CACvC,OAAM,IAAI,MAAM;AAElB,OAAI,CAAC,KAAK,cACR,OAAM,IAAI,MAAM;AAElB,UAAO,KAAK,cAAc,OAAO,IAAsB;EACxD,EAAC,CACH;AACD,SAAO;GAAE,MAAM;GAAmB;GAAU;EAAM;CACnD;AACF"}