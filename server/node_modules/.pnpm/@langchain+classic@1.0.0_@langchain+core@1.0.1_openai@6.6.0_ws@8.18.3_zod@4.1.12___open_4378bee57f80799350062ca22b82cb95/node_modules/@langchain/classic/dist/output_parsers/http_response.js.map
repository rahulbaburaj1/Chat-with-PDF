{"version":3,"file":"http_response.js","names":["fields?: HttpResponseOutputParserInput","inputGenerator: AsyncGenerator<string | BaseMessage>","text: string"],"sources":["../../src/output_parsers/http_response.ts"],"sourcesContent":["import { BaseMessage } from \"@langchain/core/messages\";\nimport {\n  BaseTransformOutputParser,\n  StringOutputParser,\n} from \"@langchain/core/output_parsers\";\n\nexport type HttpResponseOutputParserInput = {\n  outputParser?: BaseTransformOutputParser;\n  contentType?: \"text/plain\" | \"text/event-stream\";\n};\n\n/**\n * OutputParser that formats chunks emitted from an LLM for different HTTP content types.\n */\nexport class HttpResponseOutputParser extends BaseTransformOutputParser<Uint8Array> {\n  static lc_name() {\n    return \"HttpResponseOutputParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parser\"];\n\n  lc_serializable = true;\n\n  outputParser: BaseTransformOutputParser = new StringOutputParser();\n\n  contentType: \"text/plain\" | \"text/event-stream\" = \"text/plain\";\n\n  constructor(fields?: HttpResponseOutputParserInput) {\n    super(fields);\n    this.outputParser = fields?.outputParser ?? this.outputParser;\n    this.contentType = fields?.contentType ?? this.contentType;\n  }\n\n  async *_transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>\n  ): AsyncGenerator<Uint8Array> {\n    for await (const chunk of this.outputParser._transform(inputGenerator)) {\n      if (typeof chunk === \"string\") {\n        yield this.parse(chunk);\n      } else {\n        yield this.parse(JSON.stringify(chunk));\n      }\n    }\n    if (this.contentType === \"text/event-stream\") {\n      const encoder = new TextEncoder();\n      yield encoder.encode(`event: end\\n\\n`);\n    }\n  }\n\n  /**\n   * Parses a string output from an LLM call. This method is meant to be\n   * implemented by subclasses to define how a string output from an LLM\n   * should be parsed.\n   * @param text The string output from an LLM call.\n   * @param callbacks Optional callbacks.\n   * @returns A promise of the parsed output.\n   */\n  async parse(text: string): Promise<Uint8Array> {\n    const chunk = await this.outputParser.parse(text);\n    const encoder = new TextEncoder();\n    if (this.contentType === \"text/event-stream\") {\n      return encoder.encode(`event: data\\ndata: ${JSON.stringify(chunk)}\\n\\n`);\n    }\n    let parsedChunk;\n    if (typeof chunk === \"string\") {\n      parsedChunk = chunk;\n    } else {\n      parsedChunk = JSON.stringify(chunk);\n    }\n    return encoder.encode(parsedChunk);\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n}\n"],"mappings":";;;;;;AAcA,IAAa,2BAAb,cAA8C,0BAAsC;CAClF,OAAO,UAAU;AACf,SAAO;CACR;CAED,eAAe,CAAC,aAAa,eAAgB;CAE7C,kBAAkB;CAElB,eAA0C,IAAI;CAE9C,cAAkD;CAElD,YAAYA,QAAwC;EAClD,MAAM,OAAO;EACb,KAAK,eAAe,QAAQ,gBAAgB,KAAK;EACjD,KAAK,cAAc,QAAQ,eAAe,KAAK;CAChD;CAED,OAAO,WACLC,gBAC4B;AAC5B,aAAW,MAAM,SAAS,KAAK,aAAa,WAAW,eAAe,CACpE,KAAI,OAAO,UAAU,UACnB,MAAM,KAAK,MAAM,MAAM;OAEvB,MAAM,KAAK,MAAM,KAAK,UAAU,MAAM,CAAC;AAG3C,MAAI,KAAK,gBAAgB,qBAAqB;GAC5C,MAAM,UAAU,IAAI;GACpB,MAAM,QAAQ,OAAO,CAAC,cAAc,CAAC,CAAC;EACvC;CACF;;;;;;;;;CAUD,MAAM,MAAMC,MAAmC;EAC7C,MAAM,QAAQ,MAAM,KAAK,aAAa,MAAM,KAAK;EACjD,MAAM,UAAU,IAAI;AACpB,MAAI,KAAK,gBAAgB,oBACvB,QAAO,QAAQ,OAAO,CAAC,mBAAmB,EAAE,KAAK,UAAU,MAAM,CAAC,IAAI,CAAC,CAAC;EAE1E,IAAI;AACJ,MAAI,OAAO,UAAU,UACnB,cAAc;OAEd,cAAc,KAAK,UAAU,MAAM;AAErC,SAAO,QAAQ,OAAO,YAAY;CACnC;CAED,wBAAgC;AAC9B,SAAO;CACR;AACF"}