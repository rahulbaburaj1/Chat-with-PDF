{"version":3,"file":"directory.d.cts","names":["extname","ExtnameT","resolve","ResolveT","readdir","ReaddirT","Document","BaseDocumentLoader","UnknownHandling","LoadersMapping","DirectoryLoader","Promise"],"sources":["../../../src/document_loaders/fs/directory.d.ts"],"sourcesContent":["import type { extname as ExtnameT, resolve as ResolveT } from \"node:path\";\nimport type { readdir as ReaddirT } from \"node:fs/promises\";\nimport { Document } from \"@langchain/core/documents\";\nimport { BaseDocumentLoader } from \"@langchain/core/document_loaders/base\";\n// TypeScript enums are not tree-shakeable, so doing this instead\n// See https://bargsten.org/jsts/enums/\nexport declare const UnknownHandling: {\n    readonly Ignore: \"ignore\";\n    readonly Warn: \"warn\";\n    readonly Error: \"error\";\n};\n/**\n * An enumeration of possible handling strategies for unknown file types.\n */\nexport type UnknownHandling = (typeof UnknownHandling)[keyof typeof UnknownHandling];\n/**\n * A mapping of file extensions to loader functions. Each loader function\n * takes a file path as a parameter and returns a `BaseDocumentLoader`\n * instance.\n */\nexport interface LoadersMapping {\n    [extension: string]: (filePath: string) => BaseDocumentLoader;\n}\n/**\n * A document loader that loads documents from a directory. It extends the\n * `BaseDocumentLoader` class and implements the `load()` method.\n * @example\n * ```typescript\n *\n * const directoryLoader = new DirectoryLoader(\n *   \"src/document_loaders/example_data/\",\n *   {\n *     \".pdf\": (path: string) => new PDFLoader(path),\n *   },\n * );\n *\n * const docs = await directoryLoader.load();\n * console.log({ docs });\n *\n * ```\n */\nexport declare class DirectoryLoader extends BaseDocumentLoader {\n    directoryPath: string;\n    loaders: LoadersMapping;\n    recursive: boolean;\n    unknown: UnknownHandling;\n    constructor(directoryPath: string, loaders: LoadersMapping, recursive?: boolean, unknown?: UnknownHandling);\n    /**\n     * Loads the documents from the directory. If a file is a directory and\n     * `recursive` is `true`, it recursively loads documents from the\n     * subdirectory. If a file is a file, it checks if there is a\n     * corresponding loader function for the file extension in the `loaders`\n     * mapping. If there is, it loads the documents. If there is no\n     * corresponding loader function and `unknown` is set to `Warn`, it logs a\n     * warning message. If `unknown` is set to `Error`, it throws an error.\n     * @returns A promise that resolves to an array of loaded documents.\n     */\n    load(): Promise<Document[]>;\n    /**\n     * Imports the necessary functions from the `node:path` and\n     * `node:fs/promises` modules. It is used to dynamically import the\n     * functions when needed. If the import fails, it throws an error\n     * indicating that the modules failed to load.\n     * @returns A promise that resolves to an object containing the imported functions.\n     */\n    static imports(): Promise<{\n        readdir: typeof ReaddirT;\n        extname: typeof ExtnameT;\n        resolve: typeof ResolveT;\n    }>;\n}\n"],"mappings":";;;;;;;;AAMqBQ,cAAAA,eAIpB,EAAA;EAIWA,SAAAA,MAAAA,EAAAA,QAAe;EAAA,SAAA,IAAA,EAAA,MAAA;EAAA,SAAWA,KAAAA,EAAAA,OAAAA;CAAe;AAA8B;AAMnF;AAqBA;AAAoC,KA3BxBA,eAAAA,GA2BwB,CAAA,OA3BEA,eA2BF,CAAA,CAAA,MAAA,OA3BgCA,eA2BhC,CAAA;;;;;;AAgBxBG,UArCKF,cAAAA,CAqCLE;EAAO,CAAA,SASKN,EAAAA,MAAAA,CAAAA,EAAAA,CAAAA,QAAAA,EAAAA,MAAAA,EAAAA,GA7CuBE,kBA6CvBF;;;;;AAzBuC;;;;;;;;;;;;;;;cAA1CK,eAAAA,SAAwBH,kBAAAA;;WAEhCE;;WAEAD;8CACmCC,+CAA+CD;;;;;;;;;;;UAWnFG,QAAQL;;;;;;;;oBAQEK;oBACEN;oBACAJ;oBACAE"}