{"version":3,"file":"index.cjs","names":["BaseRetriever","options: SelfQueryRetrieverArgs<T>","query: string","runManager?: CallbackManagerForRetrieverRun","options: QueryConstructorRunnableOptions &\n      Omit<SelfQueryRetrieverArgs<T>, \"queryConstructor\">","loadQueryConstructorRunnable"],"sources":["../../../src/retrievers/self_query/index.ts"],"sourcesContent":["import { RunnableInterface } from \"@langchain/core/runnables\";\nimport {\n  BaseRetriever,\n  type BaseRetrieverInput,\n} from \"@langchain/core/retrievers\";\nimport { Document } from \"@langchain/core/documents\";\nimport { VectorStore } from \"@langchain/core/vectorstores\";\nimport {\n  BaseTranslator,\n  StructuredQuery,\n} from \"@langchain/core/structured_query\";\nimport { CallbackManagerForRetrieverRun } from \"@langchain/core/callbacks/manager\";\nimport {\n  loadQueryConstructorRunnable,\n  QueryConstructorRunnableOptions,\n} from \"../../chains/query_constructor/index.js\";\n\nexport { BaseTranslator } from \"@langchain/core/structured_query\";\nexport {\n  BasicTranslator,\n  FunctionalTranslator,\n} from \"@langchain/core/structured_query\";\n\n/**\n * Interface for the arguments required to create a SelfQueryRetriever\n * instance. It extends the BaseRetrieverInput interface.\n */\nexport interface SelfQueryRetrieverArgs<T extends VectorStore>\n  extends BaseRetrieverInput {\n  vectorStore: T;\n  structuredQueryTranslator: BaseTranslator<T>;\n  queryConstructor: RunnableInterface<{ query: string }, StructuredQuery>;\n  verbose?: boolean;\n  useOriginalQuery?: boolean;\n  searchParams?: {\n    k?: number;\n    filter?: T[\"FilterType\"];\n    mergeFiltersOperator?: \"or\" | \"and\" | \"replace\";\n    forceDefaultFilter?: boolean;\n  };\n}\n\n/**\n * Class for question answering over an index. It retrieves relevant\n * documents based on a query. It extends the BaseRetriever class and\n * implements the SelfQueryRetrieverArgs interface.\n * @example\n * ```typescript\n * const selfQueryRetriever = SelfQueryRetriever.fromLLM({\n *   llm: new ChatOpenAI({ model: \"gpt-4o-mini\" }),\n *   vectorStore: await HNSWLib.fromDocuments(docs, new OpenAIEmbeddings()),\n *   documentContents: \"Brief summary of a movie\",\n *   attributeInfo: attributeInfo,\n *   structuredQueryTranslator: new FunctionalTranslator(),\n * });\n * const relevantDocuments = await selfQueryRetriever.invoke(\n *   \"Which movies are directed by Greta Gerwig?\",\n * );\n * ```\n */\nexport class SelfQueryRetriever<T extends VectorStore>\n  extends BaseRetriever\n  implements SelfQueryRetrieverArgs<T>\n{\n  static lc_name() {\n    return \"SelfQueryRetriever\";\n  }\n\n  get lc_namespace() {\n    return [\"langchain\", \"retrievers\", \"self_query\"];\n  }\n\n  vectorStore: T;\n\n  queryConstructor: RunnableInterface<{ query: string }, StructuredQuery>;\n\n  verbose?: boolean;\n\n  structuredQueryTranslator: BaseTranslator<T>;\n\n  useOriginalQuery = false;\n\n  searchParams?: {\n    k?: number;\n    filter?: T[\"FilterType\"];\n    mergeFiltersOperator?: \"or\" | \"and\" | \"replace\";\n    forceDefaultFilter?: boolean;\n  } = { k: 4, forceDefaultFilter: false };\n\n  constructor(options: SelfQueryRetrieverArgs<T>) {\n    super(options);\n    this.vectorStore = options.vectorStore;\n    this.queryConstructor = options.queryConstructor;\n    this.verbose = options.verbose ?? false;\n    this.searchParams = options.searchParams ?? this.searchParams;\n    this.useOriginalQuery = options.useOriginalQuery ?? this.useOriginalQuery;\n    this.structuredQueryTranslator = options.structuredQueryTranslator;\n  }\n\n  async _getRelevantDocuments(\n    query: string,\n    runManager?: CallbackManagerForRetrieverRun\n  ): Promise<Document<Record<string, unknown>>[]> {\n    const generatedStructuredQuery = await this.queryConstructor.invoke(\n      { query },\n      {\n        callbacks: runManager?.getChild(\"query_constructor\"),\n        runName: \"query_constructor\",\n      }\n    );\n\n    const nextArg = this.structuredQueryTranslator.visitStructuredQuery(\n      generatedStructuredQuery\n    );\n\n    const filter = this.structuredQueryTranslator.mergeFilters(\n      this.searchParams?.filter,\n      nextArg.filter,\n      this.searchParams?.mergeFiltersOperator,\n      this.searchParams?.forceDefaultFilter\n    );\n\n    const generatedQuery = generatedStructuredQuery.query;\n    let myQuery = query;\n\n    if (!this.useOriginalQuery && generatedQuery && generatedQuery.length > 0) {\n      myQuery = generatedQuery;\n    }\n\n    return this.vectorStore\n      .asRetriever({\n        k: this.searchParams?.k,\n        filter,\n      })\n      .invoke(myQuery, { callbacks: runManager?.getChild(\"retriever\") });\n  }\n\n  /**\n   * Static method to create a new SelfQueryRetriever instance from a\n   * BaseLanguageModel and a VectorStore. It first loads a query constructor\n   * chain using the loadQueryConstructorChain function, then creates a new\n   * SelfQueryRetriever instance with the loaded chain and the provided\n   * options.\n   * @param options The options used to create the SelfQueryRetriever instance. It includes the QueryConstructorChainOptions and all the SelfQueryRetrieverArgs except 'llmChain'.\n   * @returns A new instance of SelfQueryRetriever.\n   */\n  static fromLLM<T extends VectorStore>(\n    options: QueryConstructorRunnableOptions &\n      Omit<SelfQueryRetrieverArgs<T>, \"queryConstructor\">\n  ): SelfQueryRetriever<T> {\n    const {\n      structuredQueryTranslator,\n      allowedComparators,\n      allowedOperators,\n      llm,\n      documentContents,\n      attributeInfo,\n      examples,\n      vectorStore,\n      ...rest\n    } = options;\n    const queryConstructor = loadQueryConstructorRunnable({\n      llm,\n      documentContents,\n      attributeInfo,\n      examples,\n      allowedComparators:\n        allowedComparators ?? structuredQueryTranslator.allowedComparators,\n      allowedOperators:\n        allowedOperators ?? structuredQueryTranslator.allowedOperators,\n    });\n    return new SelfQueryRetriever<T>({\n      ...rest,\n      queryConstructor,\n      vectorStore,\n      structuredQueryTranslator,\n    });\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4DA,IAAa,qBAAb,MAAa,2BACHA,0CAEV;CACE,OAAO,UAAU;AACf,SAAO;CACR;CAED,IAAI,eAAe;AACjB,SAAO;GAAC;GAAa;GAAc;EAAa;CACjD;CAED;CAEA;CAEA;CAEA;CAEA,mBAAmB;CAEnB,eAKI;EAAE,GAAG;EAAG,oBAAoB;CAAO;CAEvC,YAAYC,SAAoC;EAC9C,MAAM,QAAQ;EACd,KAAK,cAAc,QAAQ;EAC3B,KAAK,mBAAmB,QAAQ;EAChC,KAAK,UAAU,QAAQ,WAAW;EAClC,KAAK,eAAe,QAAQ,gBAAgB,KAAK;EACjD,KAAK,mBAAmB,QAAQ,oBAAoB,KAAK;EACzD,KAAK,4BAA4B,QAAQ;CAC1C;CAED,MAAM,sBACJC,OACAC,YAC8C;EAC9C,MAAM,2BAA2B,MAAM,KAAK,iBAAiB,OAC3D,EAAE,MAAO,GACT;GACE,WAAW,YAAY,SAAS,oBAAoB;GACpD,SAAS;EACV,EACF;EAED,MAAM,UAAU,KAAK,0BAA0B,qBAC7C,yBACD;EAED,MAAM,SAAS,KAAK,0BAA0B,aAC5C,KAAK,cAAc,QACnB,QAAQ,QACR,KAAK,cAAc,sBACnB,KAAK,cAAc,mBACpB;EAED,MAAM,iBAAiB,yBAAyB;EAChD,IAAI,UAAU;AAEd,MAAI,CAAC,KAAK,oBAAoB,kBAAkB,eAAe,SAAS,GACtE,UAAU;AAGZ,SAAO,KAAK,YACT,YAAY;GACX,GAAG,KAAK,cAAc;GACtB;EACD,EAAC,CACD,OAAO,SAAS,EAAE,WAAW,YAAY,SAAS,YAAY,CAAE,EAAC;CACrE;;;;;;;;;;CAWD,OAAO,QACLC,SAEuB;EACvB,MAAM,EACJ,2BACA,oBACA,kBACA,KACA,kBACA,eACA,UACA,YACA,GAAG,MACJ,GAAG;EACJ,MAAM,mBAAmBC,oEAA6B;GACpD;GACA;GACA;GACA;GACA,oBACE,sBAAsB,0BAA0B;GAClD,kBACE,oBAAoB,0BAA0B;EACjD,EAAC;AACF,SAAO,IAAI,mBAAsB;GAC/B,GAAG;GACH;GACA;GACA;EACD;CACF;AACF"}