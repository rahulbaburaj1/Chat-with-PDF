{"version":3,"file":"fix.d.cts","names":["BaseLanguageModelInterface","Callbacks","BaseOutputParser","OutputParserException","BasePromptTemplate","Runnable","LLMChain","OutputFixingParserRetryInput","OutputFixingParser","T","parser","retryChain","Promise"],"sources":["../../src/output_parsers/fix.d.ts"],"sourcesContent":["import type { BaseLanguageModelInterface } from \"@langchain/core/language_models/base\";\nimport { Callbacks } from \"@langchain/core/callbacks/manager\";\nimport { BaseOutputParser, OutputParserException } from \"@langchain/core/output_parsers\";\nimport { BasePromptTemplate } from \"@langchain/core/prompts\";\nimport { Runnable } from \"@langchain/core/runnables\";\nimport { LLMChain } from \"../chains/llm_chain.js\";\ninterface OutputFixingParserRetryInput {\n    instructions: string;\n    completion: string;\n    error: OutputParserException;\n}\n/**\n * Class that extends the BaseOutputParser to handle situations where the\n * initial parsing attempt fails. It contains a retryChain for retrying\n * the parsing process in case of a failure.\n */\nexport declare class OutputFixingParser<T> extends BaseOutputParser<T> {\n    static lc_name(): string;\n    lc_namespace: string[];\n    lc_serializable: boolean;\n    parser: BaseOutputParser<T>;\n    retryChain: LLMChain | Runnable<OutputFixingParserRetryInput, T>;\n    /**\n     * Static method to create a new instance of OutputFixingParser using a\n     * given language model, parser, and optional fields.\n     * @param llm The language model to be used.\n     * @param parser The parser to be used.\n     * @param fields Optional fields which may contain a prompt.\n     * @returns A new instance of OutputFixingParser.\n     */\n    static fromLLM<T>(llm: BaseLanguageModelInterface, parser: BaseOutputParser<T>, fields?: {\n        prompt?: BasePromptTemplate;\n    }): OutputFixingParser<T>;\n    constructor({ parser, retryChain }: {\n        parser: BaseOutputParser<T>;\n        retryChain: LLMChain | Runnable<OutputFixingParserRetryInput, T>;\n    });\n    /**\n     * Method to parse the completion using the parser. If the initial parsing\n     * fails, it uses the retryChain to attempt to fix the output and retry\n     * the parsing process.\n     * @param completion The completion to be parsed.\n     * @param callbacks Optional callbacks to be used during parsing.\n     * @returns The parsed output.\n     */\n    parse(completion: string, callbacks?: Callbacks): Promise<T>;\n    /**\n     * Method to get the format instructions for the parser.\n     * @returns The format instructions for the parser.\n     */\n    getFormatInstructions(): string;\n}\nexport {};\n"],"mappings":";;;;;;;;UAMUO,4BAAAA;;EAAAA,UAAAA,EAAAA,MAAAA;EAUWC,KAAAA,EAPVL,qBAO4B;;;;;;;AAK2BM,cAL7CD,kBAK6CC,CAAAA,CAAAA,CAAAA,SALfP,gBAKeO,CALEA,CAKFA,CAAAA,CAAAA;EAAC,OAAxCJ,OAAAA,CAAAA,CAAAA,EAAAA,MAAAA;EAAQ,YASRL,EAAAA,MAAAA,EAAAA;EAA0B,eAA2BS,EAAAA,OAAAA;EAAC,MAAlBP,EAVnDA,gBAUmDA,CAVlCO,CAUkCP,CAAAA;EAAgB,UAC9DE,EAVDE,QAUCF,GAVUC,QAUVD,CAVmBG,4BAUnBH,EAViDK,CAUjDL,CAAAA;EAAkB;;;;;;;;EAIiC,OAAEK,OAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,EAL3CT,0BAK2CS,EAAAA,MAAAA,EALPP,gBAKOO,CALUA,CAKVA,CAAAA,EAAAA,MAA/B,CAA+BA,EAAAA;IAAvCJ,MAAAA,CAAAA,EAJdD,kBAIcC;EAAQ,CAAA,CAAA,EAH/BG,kBAakCP,CAbfQ,CAaeR,CAAAA;EAAS,WAAWQ,CAAAA;IAAAA,MAAAA;IAAAA;EA7BK,CA6BLA,EAAAA;IAARG,MAAAA,EAXtCV,gBAWsCU,CAXrBH,CAWqBG,CAAAA;IA7BHV,UAAAA,EAmB/BI,QAnB+BJ,GAmBpBG,QAnBoBH,CAmBXK,4BAnBWL,EAmBmBO,CAnBnBP,CAAAA;EAAgB,CAAA;;;;;;;;;wCA6BzBD,YAAYW,QAAQH"}