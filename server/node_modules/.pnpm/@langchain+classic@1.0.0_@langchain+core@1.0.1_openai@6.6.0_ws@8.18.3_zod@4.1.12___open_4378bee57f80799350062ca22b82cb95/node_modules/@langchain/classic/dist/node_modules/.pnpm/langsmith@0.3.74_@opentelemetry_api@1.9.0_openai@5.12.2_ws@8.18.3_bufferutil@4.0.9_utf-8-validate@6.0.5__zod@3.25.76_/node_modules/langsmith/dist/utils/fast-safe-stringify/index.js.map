{"version":3,"file":"index.js","names":[],"sources":["../../../../../../../../../../../node_modules/.pnpm/langsmith@0.3.74_@opentelemetry+api@1.9.0_openai@5.12.2_ws@8.18.3_bufferutil@4.0.9_utf-8-validate@6.0.5__zod@3.25.76_/node_modules/langsmith/dist/utils/fast-safe-stringify/index.js"],"sourcesContent":["/* eslint-disable */\n// @ts-nocheck\nimport { getLangSmithEnvironmentVariable } from \"../../utils/env.js\";\nvar LIMIT_REPLACE_NODE = \"[...]\";\nvar CIRCULAR_REPLACE_NODE = { result: \"[Circular]\" };\nvar arr = [];\nvar replacerStack = [];\nconst encoder = new TextEncoder();\nfunction defaultOptions() {\n    return {\n        depthLimit: Number.MAX_SAFE_INTEGER,\n        edgesLimit: Number.MAX_SAFE_INTEGER,\n    };\n}\nfunction encodeString(str) {\n    return encoder.encode(str);\n}\n// Shared function to handle well-known types\nfunction serializeWellKnownTypes(val) {\n    if (val && typeof val === \"object\" && val !== null) {\n        if (val instanceof Map) {\n            return Object.fromEntries(val);\n        }\n        else if (val instanceof Set) {\n            return Array.from(val);\n        }\n        else if (val instanceof Date) {\n            return val.toISOString();\n        }\n        else if (val instanceof RegExp) {\n            return val.toString();\n        }\n        else if (val instanceof Error) {\n            return {\n                name: val.name,\n                message: val.message,\n            };\n        }\n    }\n    else if (typeof val === \"bigint\") {\n        return val.toString();\n    }\n    return val;\n}\n// Default replacer function to handle well-known types\nfunction createDefaultReplacer(userReplacer) {\n    return function (key, val) {\n        // Apply user replacer first if provided\n        if (userReplacer) {\n            const userResult = userReplacer.call(this, key, val);\n            // If user replacer returned undefined, fall back to our serialization\n            if (userResult !== undefined) {\n                return userResult;\n            }\n        }\n        // Fall back to our well-known type handling\n        return serializeWellKnownTypes(val);\n    };\n}\n// Regular stringify\nexport function serialize(obj, errorContext, replacer, spacer, options) {\n    try {\n        const str = JSON.stringify(obj, createDefaultReplacer(replacer), spacer);\n        return encodeString(str);\n    }\n    catch (e) {\n        // Fall back to more complex stringify if circular reference\n        if (!e.message?.includes(\"Converting circular structure to JSON\")) {\n            console.warn(`[WARNING]: LangSmith received unserializable value.${errorContext ? `\\nContext: ${errorContext}` : \"\"}`);\n            return encodeString(\"[Unserializable]\");\n        }\n        getLangSmithEnvironmentVariable(\"SUPPRESS_CIRCULAR_JSON_WARNINGS\") !==\n            \"true\" &&\n            console.warn(`[WARNING]: LangSmith received circular JSON. This will decrease tracer performance. ${errorContext ? `\\nContext: ${errorContext}` : \"\"}`);\n        if (typeof options === \"undefined\") {\n            options = defaultOptions();\n        }\n        decirc(obj, \"\", 0, [], undefined, 0, options);\n        let res;\n        try {\n            if (replacerStack.length === 0) {\n                res = JSON.stringify(obj, replacer, spacer);\n            }\n            else {\n                res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n            }\n        }\n        catch (_) {\n            return encodeString(\"[unable to serialize, circular reference is too complex to analyze]\");\n        }\n        finally {\n            while (arr.length !== 0) {\n                const part = arr.pop();\n                if (part.length === 4) {\n                    Object.defineProperty(part[0], part[1], part[3]);\n                }\n                else {\n                    part[0][part[1]] = part[2];\n                }\n            }\n        }\n        return encodeString(res);\n    }\n}\nfunction setReplace(replace, val, k, parent) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n    if (propertyDescriptor.get !== undefined) {\n        if (propertyDescriptor.configurable) {\n            Object.defineProperty(parent, k, { value: replace });\n            arr.push([parent, k, val, propertyDescriptor]);\n        }\n        else {\n            replacerStack.push([val, k, replace]);\n        }\n    }\n    else {\n        parent[k] = replace;\n        arr.push([parent, k, val]);\n    }\n}\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for (i = 0; i < stack.length; i++) {\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        if (typeof options.depthLimit !== \"undefined\" &&\n            depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" &&\n            edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for (i = 0; i < val.length; i++) {\n                decirc(val[i], i, i, stack, val, depth, options);\n            }\n        }\n        else {\n            // Handle well-known types before Object.keys iteration\n            val = serializeWellKnownTypes(val);\n            var keys = Object.keys(val);\n            for (i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                decirc(val[key], key, i, stack, val, depth, options);\n            }\n        }\n        stack.pop();\n    }\n}\n// Stable-stringify\nfunction compareFunction(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nfunction deterministicStringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(tmp, replacer, spacer);\n        }\n        else {\n            res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n        }\n    }\n    catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    }\n    finally {\n        // Ensure that we restore the object as it was.\n        while (arr.length !== 0) {\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            }\n            else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for (i = 0; i < stack.length; i++) {\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        try {\n            if (typeof val.toJSON === \"function\") {\n                return;\n            }\n        }\n        catch (_) {\n            return;\n        }\n        if (typeof options.depthLimit !== \"undefined\" &&\n            depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" &&\n            edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for (i = 0; i < val.length; i++) {\n                deterministicDecirc(val[i], i, i, stack, val, depth, options);\n            }\n        }\n        else {\n            // Handle well-known types before Object.keys iteration\n            val = serializeWellKnownTypes(val);\n            // Create a temporary object in the required way\n            var tmp = {};\n            var keys = Object.keys(val).sort(compareFunction);\n            for (i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                deterministicDecirc(val[key], key, i, stack, val, depth, options);\n                tmp[key] = val[key];\n            }\n            if (typeof parent !== \"undefined\") {\n                arr.push([parent, k, val]);\n                parent[k] = tmp;\n            }\n            else {\n                return tmp;\n            }\n        }\n        stack.pop();\n    }\n}\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n    replacer =\n        typeof replacer !== \"undefined\"\n            ? replacer\n            : function (k, v) {\n                return v;\n            };\n    return function (key, val) {\n        if (replacerStack.length > 0) {\n            for (var i = 0; i < replacerStack.length; i++) {\n                var part = replacerStack[i];\n                if (part[1] === key && part[0] === val) {\n                    val = part[2];\n                    replacerStack.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        return replacer.call(this, key, val);\n    };\n}\n"],"x_google_ignoreList":[0],"mappings":"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"}