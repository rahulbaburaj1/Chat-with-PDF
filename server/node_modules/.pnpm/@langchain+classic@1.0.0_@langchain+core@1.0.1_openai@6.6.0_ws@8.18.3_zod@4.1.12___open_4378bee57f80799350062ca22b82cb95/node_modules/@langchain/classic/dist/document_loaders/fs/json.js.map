{"version":3,"file":"json.js","names":["filePathOrBlob: string | Blob","pointers: string | string[]","raw: string","json: any","pointers: jsonpointer[]","extractedString: string[]","entry: object","extractedStrings: string[]","json: object","pointer: string"],"sources":["../../../src/document_loaders/fs/json.ts"],"sourcesContent":["import jsonpointer from \"jsonpointer\";\nimport { TextLoader } from \"./text.js\";\n\n/**\n * Class that extends the `TextLoader` class. It represents a document\n * loader that loads documents from JSON files. It has a constructor that\n * takes a `filePathOrBlob` parameter representing the path to the JSON\n * file or a `Blob` object, and an optional `pointers` parameter that\n * specifies the JSON pointers to extract.\n */\nexport class JSONLoader extends TextLoader {\n  public pointers: string[];\n\n  constructor(filePathOrBlob: string | Blob, pointers: string | string[] = []) {\n    super(filePathOrBlob);\n    this.pointers = Array.isArray(pointers) ? pointers : [pointers];\n  }\n\n  /**\n   * Method that takes a `raw` string as a parameter and returns a promise\n   * that resolves to an array of strings. It parses the raw JSON string and\n   * extracts the values based on the specified JSON pointers. If no JSON\n   * pointers are specified, it extracts all the strings from the JSON\n   * object.\n   * @param raw The raw JSON string to parse.\n   * @returns A promise that resolves to an array of strings.\n   */\n  protected async parse(raw: string): Promise<string[]> {\n    const json = JSON.parse(raw.trim());\n    // If there is no pointers specified we extract all strings we found\n    const extractAllStrings = !(this.pointers.length > 0);\n    const compiledPointers = this.pointers.map((pointer) =>\n      jsonpointer.compile(pointer)\n    );\n\n    return this.extractArrayStringsFromObject(\n      json,\n      compiledPointers,\n      extractAllStrings\n    );\n  }\n\n  /**\n   * If JSON pointers are specified, return all strings below any of them\n   * and exclude all other nodes expect if they match a JSON pointer (to allow to extract strings from different levels)\n   *\n   * If no JSON pointer is specified then return all string in the object\n   */\n  private extractArrayStringsFromObject(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    json: any,\n    pointers: jsonpointer[],\n    extractAllStrings = false,\n    keyHasBeenFound = false\n  ): string[] {\n    if (!json) {\n      return [];\n    }\n\n    if (typeof json === \"string\" && extractAllStrings) {\n      return [json];\n    }\n\n    if (Array.isArray(json) && extractAllStrings) {\n      let extractedString: string[] = [];\n      for (const element of json) {\n        extractedString = extractedString.concat(\n          this.extractArrayStringsFromObject(element, pointers, true)\n        );\n      }\n\n      return extractedString;\n    }\n\n    if (typeof json === \"object\") {\n      if (extractAllStrings) {\n        return this.extractArrayStringsFromObject(\n          Object.values(json),\n          pointers,\n          true\n        );\n      }\n\n      const targetedEntries = this.getTargetedEntries(json, pointers);\n      const thisLevelEntries = Object.values(json) as object[];\n      const notTargetedEntries = thisLevelEntries.filter(\n        (entry: object) => !targetedEntries.includes(entry)\n      );\n\n      let extractedStrings: string[] = [];\n      // If we found a targeted entry, we extract all strings from it\n      if (targetedEntries.length > 0) {\n        for (const oneEntry of targetedEntries) {\n          extractedStrings = extractedStrings.concat(\n            this.extractArrayStringsFromObject(oneEntry, pointers, true, true)\n          );\n        }\n\n        for (const oneEntry of notTargetedEntries) {\n          extractedStrings = extractedStrings.concat(\n            this.extractArrayStringsFromObject(oneEntry, pointers, false, true)\n          );\n        }\n      } else if (extractAllStrings || !keyHasBeenFound) {\n        for (const oneEntry of notTargetedEntries) {\n          extractedStrings = extractedStrings.concat(\n            this.extractArrayStringsFromObject(\n              oneEntry,\n              pointers,\n              extractAllStrings\n            )\n          );\n        }\n      }\n\n      return extractedStrings;\n    }\n\n    return [];\n  }\n\n  /**\n   * Method that takes a `json` object and an array of `pointers` as\n   * parameters and returns an array of targeted entries. It iterates over\n   * the JSON pointers and uses the `jsonpointer.get()` function to get the\n   * targeted entries from the JSON object.\n   * @param json The JSON object to get targeted entries from.\n   * @param pointers The JSON pointers to get targeted entries.\n   * @returns An array of targeted entries.\n   */\n  private getTargetedEntries(json: object, pointers: jsonpointer[]): object[] {\n    const targetEntries = [];\n    for (const pointer of pointers) {\n      const targetedEntry = pointer.get(json);\n      if (targetedEntry) {\n        targetEntries.push(targetedEntry);\n      }\n    }\n\n    return targetEntries;\n  }\n}\n\n/**\n * Class that extends the `TextLoader` class. It represents a document\n * loader that loads documents from JSON Lines files. It has a constructor\n * that takes a `filePathOrBlob` parameter representing the path to the\n * JSON Lines file or a `Blob` object, and a `pointer` parameter that\n * specifies the JSON pointer to extract.\n */\nexport class JSONLinesLoader extends TextLoader {\n  constructor(filePathOrBlob: string | Blob, public pointer: string) {\n    super(filePathOrBlob);\n  }\n\n  /**\n   * Method that takes a `raw` string as a parameter and returns a promise\n   * that resolves to an array of strings. It parses the raw JSON Lines\n   * string, splits it into lines, parses each line as JSON, and extracts\n   * the values based on the specified JSON pointer.\n   * @param raw The raw JSON Lines string to parse.\n   * @returns A promise that resolves to an array of strings.\n   */\n  protected async parse(raw: string): Promise<string[]> {\n    const lines = raw.split(\"\\n\");\n    const jsons = lines\n      .map((line) => line.trim())\n      .filter(Boolean)\n      .map((line) => JSON.parse(line));\n    const pointer = jsonpointer.compile(this.pointer);\n    return jsons.map((json) => {\n      const data = pointer.get(json);\n      if (typeof data === \"string\") {\n        return data;\n      }\n      if (!data) {\n        return \"\";\n      }\n      if (typeof data === \"object\") {\n        return JSON.stringify(data);\n      }\n      return \"\";\n    });\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;AAUA,IAAa,aAAb,cAAgC,WAAW;CACzC,AAAO;CAEP,YAAYA,gBAA+BC,WAA8B,CAAE,GAAE;EAC3E,MAAM,eAAe;EACrB,KAAK,WAAW,MAAM,QAAQ,SAAS,GAAG,WAAW,CAAC,QAAS;CAChE;;;;;;;;;;CAWD,MAAgB,MAAMC,KAAgC;EACpD,MAAM,OAAO,KAAK,MAAM,IAAI,MAAM,CAAC;EAEnC,MAAM,oBAAoB,EAAE,KAAK,SAAS,SAAS;EACnD,MAAM,mBAAmB,KAAK,SAAS,IAAI,CAAC,YAC1C,YAAY,QAAQ,QAAQ,CAC7B;AAED,SAAO,KAAK,8BACV,MACA,kBACA,kBACD;CACF;;;;;;;CAQD,AAAQ,8BAENC,MACAC,UACA,oBAAoB,OACpB,kBAAkB,OACR;AACV,MAAI,CAAC,KACH,QAAO,CAAE;AAGX,MAAI,OAAO,SAAS,YAAY,kBAC9B,QAAO,CAAC,IAAK;AAGf,MAAI,MAAM,QAAQ,KAAK,IAAI,mBAAmB;GAC5C,IAAIC,kBAA4B,CAAE;AAClC,QAAK,MAAM,WAAW,MACpB,kBAAkB,gBAAgB,OAChC,KAAK,8BAA8B,SAAS,UAAU,KAAK,CAC5D;AAGH,UAAO;EACR;AAED,MAAI,OAAO,SAAS,UAAU;AAC5B,OAAI,kBACF,QAAO,KAAK,8BACV,OAAO,OAAO,KAAK,EACnB,UACA,KACD;GAGH,MAAM,kBAAkB,KAAK,mBAAmB,MAAM,SAAS;GAC/D,MAAM,mBAAmB,OAAO,OAAO,KAAK;GAC5C,MAAM,qBAAqB,iBAAiB,OAC1C,CAACC,UAAkB,CAAC,gBAAgB,SAAS,MAAM,CACpD;GAED,IAAIC,mBAA6B,CAAE;AAEnC,OAAI,gBAAgB,SAAS,GAAG;AAC9B,SAAK,MAAM,YAAY,iBACrB,mBAAmB,iBAAiB,OAClC,KAAK,8BAA8B,UAAU,UAAU,MAAM,KAAK,CACnE;AAGH,SAAK,MAAM,YAAY,oBACrB,mBAAmB,iBAAiB,OAClC,KAAK,8BAA8B,UAAU,UAAU,OAAO,KAAK,CACpE;GAEJ,WAAU,qBAAqB,CAAC,gBAC/B,MAAK,MAAM,YAAY,oBACrB,mBAAmB,iBAAiB,OAClC,KAAK,8BACH,UACA,UACA,kBACD,CACF;AAIL,UAAO;EACR;AAED,SAAO,CAAE;CACV;;;;;;;;;;CAWD,AAAQ,mBAAmBC,MAAcJ,UAAmC;EAC1E,MAAM,gBAAgB,CAAE;AACxB,OAAK,MAAM,WAAW,UAAU;GAC9B,MAAM,gBAAgB,QAAQ,IAAI,KAAK;AACvC,OAAI,eACF,cAAc,KAAK,cAAc;EAEpC;AAED,SAAO;CACR;AACF;;;;;;;;AASD,IAAa,kBAAb,cAAqC,WAAW;CAC9C,YAAYJ,gBAAsCS,SAAiB;EACjE,MAAM,eAAe;EAD2B;CAEjD;;;;;;;;;CAUD,MAAgB,MAAMP,KAAgC;EACpD,MAAM,QAAQ,IAAI,MAAM,KAAK;EAC7B,MAAM,QAAQ,MACX,IAAI,CAAC,SAAS,KAAK,MAAM,CAAC,CAC1B,OAAO,QAAQ,CACf,IAAI,CAAC,SAAS,KAAK,MAAM,KAAK,CAAC;EAClC,MAAM,UAAU,YAAY,QAAQ,KAAK,QAAQ;AACjD,SAAO,MAAM,IAAI,CAAC,SAAS;GACzB,MAAM,OAAO,QAAQ,IAAI,KAAK;AAC9B,OAAI,OAAO,SAAS,SAClB,QAAO;AAET,OAAI,CAAC,KACH,QAAO;AAET,OAAI,OAAO,SAAS,SAClB,QAAO,KAAK,UAAU,KAAK;AAE7B,UAAO;EACR,EAAC;CACH;AACF"}