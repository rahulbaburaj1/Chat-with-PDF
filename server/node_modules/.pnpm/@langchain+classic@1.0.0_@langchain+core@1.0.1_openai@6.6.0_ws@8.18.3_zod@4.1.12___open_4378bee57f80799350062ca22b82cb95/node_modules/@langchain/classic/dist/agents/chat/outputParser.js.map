{"version":3,"file":"outputParser.js","names":["text: string"],"sources":["../../../src/agents/chat/outputParser.ts"],"sourcesContent":["import type { AgentFinish } from \"@langchain/core/agents\";\nimport { OutputParserException } from \"@langchain/core/output_parsers\";\nimport { AgentActionOutputParser } from \"../types.js\";\nimport { FORMAT_INSTRUCTIONS } from \"./prompt.js\";\n\nexport const FINAL_ANSWER_ACTION = \"Final Answer:\";\n/**\n * A class that extends the AgentActionOutputParser to parse the output of\n * the ChatAgent in LangChain. It checks if the output text contains the\n * final answer action or a JSON response, and parses it accordingly.\n * @example\n * ```typescript\n * const prompt = ChatPromptTemplate.fromMessages([\n *   [\n *     \"ai\",\n *     `{PREFIX}\n * {FORMAT_INSTRUCTIONS}\n * {SUFFIX}`,\n *   ],\n *   [\"human\", \"Question: {input}\"],\n * ]);\n * const runnableAgent = RunnableSequence.from([\n *   {\n *     input: (i: { input: string; steps: AgentStep[] }) => i.input,\n *     agent_scratchpad: (i: { input: string; steps: AgentStep[] }) =>\n *       formatLogToString(i.steps),\n *   },\n *   prompt,\n *   new OpenAI({ temperature: 0 }),\n *   new ChatAgentOutputParser(),\n * ]);\n *\n * const executor = AgentExecutor.fromAgentAndTools({\n *   agent: runnableAgent,\n *   tools: [new SerpAPI(), new Calculator()],\n * });\n *\n * const result = await executor.invoke({\n *   input:\n *     \"Who is Olivia Wilde's boyfriend? What is his current age raised to the 0.23 power?\",\n * });\n * ```\n */\nexport class ChatAgentOutputParser extends AgentActionOutputParser {\n  lc_namespace = [\"langchain\", \"agents\", \"chat\"];\n\n  /**\n   * Parses the output text from the MRKL chain into an agent action or\n   * agent finish. If the text contains the final answer action or does not\n   * contain an action, it returns an AgentFinish with the output and log.\n   * If the text contains a JSON response, it returns the tool, toolInput,\n   * and log.\n   * @param text The output text from the MRKL chain.\n   * @returns An object that satisfies the AgentFinish interface or an object with the tool, toolInput, and log.\n   */\n  async parse(text: string) {\n    if (text.includes(FINAL_ANSWER_ACTION) || !text.includes(`\"action\":`)) {\n      const parts = text.split(FINAL_ANSWER_ACTION);\n      const output = parts[parts.length - 1].trim();\n      return { returnValues: { output }, log: text } satisfies AgentFinish;\n    }\n\n    const action = text.includes(\"```\")\n      ? text.trim().split(/```(?:json)?/)[1]\n      : text.trim();\n    try {\n      const response = JSON.parse(action.trim());\n      return {\n        tool: response.action,\n        toolInput: response.action_input,\n        log: text,\n      };\n    } catch {\n      throw new OutputParserException(\n        `Unable to parse JSON response from chat agent.\\n\\n${text}`\n      );\n    }\n  }\n\n  /**\n   * Returns the format instructions used in the output parser for the\n   * ChatAgent class.\n   * @returns The format instructions as a string.\n   */\n  getFormatInstructions(): string {\n    return FORMAT_INSTRUCTIONS;\n  }\n}\n"],"mappings":";;;;;AAKA,MAAa,sBAAsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCnC,IAAa,wBAAb,cAA2C,wBAAwB;CACjE,eAAe;EAAC;EAAa;EAAU;CAAO;;;;;;;;;;CAW9C,MAAM,MAAMA,MAAc;AACxB,MAAI,KAAK,SAAS,oBAAoB,IAAI,CAAC,KAAK,SAAS,CAAC,SAAS,CAAC,CAAC,EAAE;GACrE,MAAM,QAAQ,KAAK,MAAM,oBAAoB;GAC7C,MAAM,SAAS,MAAM,MAAM,SAAS,GAAG,MAAM;AAC7C,UAAO;IAAE,cAAc,EAAE,OAAQ;IAAE,KAAK;GAAM;EAC/C;EAED,MAAM,SAAS,KAAK,SAAS,MAAM,GAC/B,KAAK,MAAM,CAAC,MAAM,eAAe,CAAC,KAClC,KAAK,MAAM;AACf,MAAI;GACF,MAAM,WAAW,KAAK,MAAM,OAAO,MAAM,CAAC;AAC1C,UAAO;IACL,MAAM,SAAS;IACf,WAAW,SAAS;IACpB,KAAK;GACN;EACF,QAAO;AACN,SAAM,IAAI,sBACR,CAAC,kDAAkD,EAAE,MAAM;EAE9D;CACF;;;;;;CAOD,wBAAgC;AAC9B,SAAO;CACR;AACF"}