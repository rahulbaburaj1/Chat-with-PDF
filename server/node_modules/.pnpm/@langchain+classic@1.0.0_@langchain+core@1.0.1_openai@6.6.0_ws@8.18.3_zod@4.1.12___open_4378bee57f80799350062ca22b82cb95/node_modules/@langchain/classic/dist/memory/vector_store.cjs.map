{"version":3,"file":"vector_store.cjs","names":["BaseMemory","fields: VectorStoreRetrieverMemoryParams","values: InputValues","formatDocumentsAsString","inputValues: InputValues","outputValues: OutputValues","Document"],"sources":["../../src/memory/vector_store.ts"],"sourcesContent":["import type { VectorStoreRetrieverInterface } from \"@langchain/core/vectorstores\";\nimport { Document } from \"@langchain/core/documents\";\nimport {\n  BaseMemory,\n  getInputValue,\n  InputValues,\n  MemoryVariables,\n  OutputValues,\n} from \"@langchain/core/memory\";\nimport { formatDocumentsAsString } from \"../util/document.js\";\n\ntype Metadata = Record<string, unknown>;\ntype MetadataFunction = (\n  inputValues?: InputValues,\n  outputValues?: OutputValues\n) => Metadata;\n\n/**\n * Interface for the parameters required to initialize a\n * VectorStoreRetrieverMemory instance.\n */\nexport interface VectorStoreRetrieverMemoryParams {\n  vectorStoreRetriever: VectorStoreRetrieverInterface;\n  inputKey?: string;\n  outputKey?: string;\n  memoryKey?: string;\n  returnDocs?: boolean;\n  /**\n   * Metadata to be added to the document when saving context.\n   */\n  metadata?: Metadata | MetadataFunction;\n}\n\n/**\n * Class for managing long-term memory in Large Language Model (LLM)\n * applications. It provides a way to persist and retrieve relevant\n * documents from a vector store database, which can be useful for\n * maintaining conversation history or other types of memory in an LLM\n * application.\n * @example\n * ```typescript\n * const vectorStore = new MemoryVectorStore(new OpenAIEmbeddings());\n * const memory = new VectorStoreRetrieverMemory({\n *   vectorStoreRetriever: vectorStore.asRetriever(1),\n *   memoryKey: \"history\",\n * });\n *\n * // Saving context to memory\n * await memory.saveContext(\n *   { input: \"My favorite food is pizza\" },\n *   { output: \"thats good to know\" },\n * );\n * await memory.saveContext(\n *   { input: \"My favorite sport is soccer\" },\n *   { output: \"...\" },\n * );\n * await memory.saveContext({ input: \"I don't the Celtics\" }, { output: \"ok\" });\n *\n * // Loading memory variables\n * console.log(\n *   await memory.loadMemoryVariables({ prompt: \"what sport should i watch?\" }),\n * );\n * ```\n */\nexport class VectorStoreRetrieverMemory\n  extends BaseMemory\n  implements VectorStoreRetrieverMemoryParams\n{\n  vectorStoreRetriever: VectorStoreRetrieverInterface;\n\n  inputKey?: string;\n\n  memoryKey: string;\n\n  returnDocs: boolean;\n\n  metadata?: Metadata | MetadataFunction;\n\n  constructor(fields: VectorStoreRetrieverMemoryParams) {\n    super();\n    this.vectorStoreRetriever = fields.vectorStoreRetriever;\n    this.inputKey = fields.inputKey;\n    this.memoryKey = fields.memoryKey ?? \"memory\";\n    this.returnDocs = fields.returnDocs ?? false;\n    this.metadata = fields.metadata;\n  }\n\n  get memoryKeys(): string[] {\n    return [this.memoryKey];\n  }\n\n  /**\n   * Method to load memory variables. It uses the vectorStoreRetriever to\n   * get relevant documents based on the query obtained from the input\n   * values.\n   * @param values An InputValues object.\n   * @returns A Promise that resolves to a MemoryVariables object.\n   */\n  async loadMemoryVariables(values: InputValues): Promise<MemoryVariables> {\n    const query = getInputValue(values, this.inputKey);\n    const results = await this.vectorStoreRetriever.invoke(query);\n    return {\n      [this.memoryKey]: this.returnDocs\n        ? results\n        : formatDocumentsAsString(results),\n    };\n  }\n\n  /**\n   * Method to save context. It constructs a document from the input and\n   * output values (excluding the memory key) and adds it to the vector\n   * store database using the vectorStoreRetriever.\n   * @param inputValues An InputValues object.\n   * @param outputValues An OutputValues object.\n   * @returns A Promise that resolves to void.\n   */\n  async saveContext(\n    inputValues: InputValues,\n    outputValues: OutputValues\n  ): Promise<void> {\n    const metadata =\n      typeof this.metadata === \"function\"\n        ? this.metadata(inputValues, outputValues)\n        : this.metadata;\n    const text = Object.entries(inputValues)\n      .filter(([k]) => k !== this.memoryKey)\n      .concat(Object.entries(outputValues))\n      .map(([k, v]) => `${k}: ${v}`)\n      .join(\"\\n\");\n    await this.vectorStoreRetriever.addDocuments([\n      new Document({ pageContent: text, metadata }),\n    ]);\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgEA,IAAa,6BAAb,cACUA,mCAEV;CACE;CAEA;CAEA;CAEA;CAEA;CAEA,YAAYC,QAA0C;EACpD,OAAO;EACP,KAAK,uBAAuB,OAAO;EACnC,KAAK,WAAW,OAAO;EACvB,KAAK,YAAY,OAAO,aAAa;EACrC,KAAK,aAAa,OAAO,cAAc;EACvC,KAAK,WAAW,OAAO;CACxB;CAED,IAAI,aAAuB;AACzB,SAAO,CAAC,KAAK,SAAU;CACxB;;;;;;;;CASD,MAAM,oBAAoBC,QAA+C;EACvE,MAAM,mDAAsB,QAAQ,KAAK,SAAS;EAClD,MAAM,UAAU,MAAM,KAAK,qBAAqB,OAAO,MAAM;AAC7D,SAAO,GACJ,KAAK,YAAY,KAAK,aACnB,UACAC,8CAAwB,QAAQ,CACrC;CACF;;;;;;;;;CAUD,MAAM,YACJC,aACAC,cACe;EACf,MAAM,WACJ,OAAO,KAAK,aAAa,aACrB,KAAK,SAAS,aAAa,aAAa,GACxC,KAAK;EACX,MAAM,OAAO,OAAO,QAAQ,YAAY,CACrC,OAAO,CAAC,CAAC,EAAE,KAAK,MAAM,KAAK,UAAU,CACrC,OAAO,OAAO,QAAQ,aAAa,CAAC,CACpC,IAAI,CAAC,CAAC,GAAG,EAAE,KAAK,GAAG,EAAE,EAAE,EAAE,GAAG,CAAC,CAC7B,KAAK,KAAK;EACb,MAAM,KAAK,qBAAqB,aAAa,CAC3C,IAAIC,oCAAS;GAAE,aAAa;GAAM;EAAU,EAC7C,EAAC;CACH;AACF"}