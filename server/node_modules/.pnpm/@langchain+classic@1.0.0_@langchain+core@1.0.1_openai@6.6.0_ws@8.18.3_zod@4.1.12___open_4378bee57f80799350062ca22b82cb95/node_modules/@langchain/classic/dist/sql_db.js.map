{"version":3,"file":"sql_db.js","names":["fields: SqlDatabaseDataSourceParams","table: SqlTable","fields: SqlDatabaseOptionsParams","targetTables?: Array<string>","command: string","fetch: \"all\" | \"one\""],"sources":["../src/sql_db.ts"],"sourcesContent":["import type { DataSource as DataSourceT, DataSourceOptions } from \"typeorm\";\nimport { Serializable } from \"@langchain/core/load/serializable\";\nimport {\n  generateTableInfoFromTables,\n  getTableAndColumnsName,\n  SerializedSqlDatabase,\n  SqlDatabaseDataSourceParams,\n  SqlDatabaseOptionsParams,\n  SqlTable,\n  verifyIgnoreTablesExistInDatabase,\n  verifyIncludeTablesExistInDatabase,\n  verifyListTablesExistInDatabase,\n} from \"./util/sql_utils.js\";\n\nexport type { SqlDatabaseDataSourceParams, SqlDatabaseOptionsParams };\n\n/**\n * Class that represents a SQL database in the LangChain framework.\n *\n * @security **Security Notice**\n * This class generates SQL queries for the given database.\n * The SQLDatabase class provides a getTableInfo method that can be used\n * to get column information as well as sample data from the table.\n * To mitigate risk of leaking sensitive data, limit permissions\n * to read and scope to the tables that are needed.\n * Optionally, use the includesTables or ignoreTables class parameters\n * to limit which tables can/cannot be accessed.\n *\n * @link See https://js.langchain.com/docs/security for more information.\n */\nexport class SqlDatabase\n  extends Serializable\n  implements SqlDatabaseOptionsParams, SqlDatabaseDataSourceParams\n{\n  lc_namespace = [\"langchain\", \"sql_db\"];\n\n  toJSON() {\n    return this.toJSONNotImplemented();\n  }\n\n  appDataSourceOptions: DataSourceOptions;\n\n  appDataSource: DataSourceT;\n\n  allTables: Array<SqlTable> = [];\n\n  includesTables: Array<string> = [];\n\n  ignoreTables: Array<string> = [];\n\n  sampleRowsInTableInfo = 3;\n\n  customDescription?: Record<string, string>;\n\n  protected constructor(fields: SqlDatabaseDataSourceParams) {\n    super(...arguments);\n    this.appDataSource = fields.appDataSource;\n    this.appDataSourceOptions = fields.appDataSource.options;\n    if (fields?.includesTables && fields?.ignoreTables) {\n      throw new Error(\"Cannot specify both includeTables and ignoreTables\");\n    }\n    this.includesTables = fields?.includesTables ?? [];\n    this.ignoreTables = fields?.ignoreTables ?? [];\n    this.sampleRowsInTableInfo =\n      fields?.sampleRowsInTableInfo ?? this.sampleRowsInTableInfo;\n  }\n\n  static async fromDataSourceParams(\n    fields: SqlDatabaseDataSourceParams\n  ): Promise<SqlDatabase> {\n    const sqlDatabase = new SqlDatabase(fields);\n    if (!sqlDatabase.appDataSource.isInitialized) {\n      await sqlDatabase.appDataSource.initialize();\n    }\n    sqlDatabase.allTables = await getTableAndColumnsName(\n      sqlDatabase.appDataSource\n    );\n    sqlDatabase.customDescription = Object.fromEntries(\n      Object.entries(fields?.customDescription ?? {}).filter(([key, _]) =>\n        sqlDatabase.allTables\n          .map((table: SqlTable) => table.tableName)\n          .includes(key)\n      )\n    );\n    verifyIncludeTablesExistInDatabase(\n      sqlDatabase.allTables,\n      sqlDatabase.includesTables\n    );\n    verifyIgnoreTablesExistInDatabase(\n      sqlDatabase.allTables,\n      sqlDatabase.ignoreTables\n    );\n    return sqlDatabase;\n  }\n\n  static async fromOptionsParams(\n    fields: SqlDatabaseOptionsParams\n  ): Promise<SqlDatabase> {\n    const { DataSource } = await import(\"typeorm\");\n    const dataSource = new DataSource(fields.appDataSourceOptions);\n    return SqlDatabase.fromDataSourceParams({\n      ...fields,\n      appDataSource: dataSource,\n    });\n  }\n\n  /**\n   * Get information about specified tables.\n   *\n   * Follows best practices as specified in: Rajkumar et al, 2022\n   * (https://arxiv.org/abs/2204.00498)\n   *\n   * If `sample_rows_in_table_info`, the specified number of sample rows will be\n   * appended to each table description. This can increase performance as\n   * demonstrated in the paper.\n   */\n  async getTableInfo(targetTables?: Array<string>): Promise<string> {\n    let selectedTables =\n      this.includesTables.length > 0\n        ? this.allTables.filter((currentTable) =>\n            this.includesTables.includes(currentTable.tableName)\n          )\n        : this.allTables;\n\n    if (this.ignoreTables.length > 0) {\n      selectedTables = selectedTables.filter(\n        (currentTable) => !this.ignoreTables.includes(currentTable.tableName)\n      );\n    }\n\n    if (targetTables && targetTables.length > 0) {\n      verifyListTablesExistInDatabase(\n        this.allTables,\n        targetTables,\n        \"Wrong target table name:\"\n      );\n      selectedTables = this.allTables.filter((currentTable) =>\n        targetTables.includes(currentTable.tableName)\n      );\n    }\n\n    return generateTableInfoFromTables(\n      selectedTables,\n      this.appDataSource,\n      this.sampleRowsInTableInfo,\n      this.customDescription\n    );\n  }\n\n  /**\n   * Execute a SQL command and return a string representing the results.\n   * If the statement returns rows, a string of the results is returned.\n   * If the statement returns no rows, an empty string is returned.\n   */\n  async run(command: string, fetch: \"all\" | \"one\" = \"all\"): Promise<string> {\n    // TODO: Potential security issue here\n    const res = await this.appDataSource.query(command);\n\n    if (fetch === \"all\") {\n      return JSON.stringify(res);\n    }\n\n    if (res?.length > 0) {\n      return JSON.stringify(res[0]);\n    }\n\n    return \"\";\n  }\n\n  serialize(): SerializedSqlDatabase {\n    return {\n      _type: \"sql_database\",\n      appDataSourceOptions: this.appDataSourceOptions,\n      includesTables: this.includesTables,\n      ignoreTables: this.ignoreTables,\n      sampleRowsInTableInfo: this.sampleRowsInTableInfo,\n    };\n  }\n\n  /** @ignore */\n  static async imports() {\n    try {\n      const { DataSource } = await import(\"typeorm\");\n      return { DataSource };\n    } catch (e) {\n      console.error(e);\n      throw new Error(\n        \"Failed to load typeorm. Please install it with eg. `yarn add typeorm`.\"\n      );\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AA8BA,IAAa,cAAb,MAAa,oBACH,aAEV;CACE,eAAe,CAAC,aAAa,QAAS;CAEtC,SAAS;AACP,SAAO,KAAK,sBAAsB;CACnC;CAED;CAEA;CAEA,YAA6B,CAAE;CAE/B,iBAAgC,CAAE;CAElC,eAA8B,CAAE;CAEhC,wBAAwB;CAExB;CAEA,AAAU,YAAYA,QAAqC;EACzD,MAAM,GAAG,UAAU;EACnB,KAAK,gBAAgB,OAAO;EAC5B,KAAK,uBAAuB,OAAO,cAAc;AACjD,MAAI,QAAQ,kBAAkB,QAAQ,aACpC,OAAM,IAAI,MAAM;EAElB,KAAK,iBAAiB,QAAQ,kBAAkB,CAAE;EAClD,KAAK,eAAe,QAAQ,gBAAgB,CAAE;EAC9C,KAAK,wBACH,QAAQ,yBAAyB,KAAK;CACzC;CAED,aAAa,qBACXA,QACsB;EACtB,MAAM,cAAc,IAAI,YAAY;AACpC,MAAI,CAAC,YAAY,cAAc,eAC7B,MAAM,YAAY,cAAc,YAAY;EAE9C,YAAY,YAAY,MAAM,uBAC5B,YAAY,cACb;EACD,YAAY,oBAAoB,OAAO,YACrC,OAAO,QAAQ,QAAQ,qBAAqB,CAAE,EAAC,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,KAC9D,YAAY,UACT,IAAI,CAACC,UAAoB,MAAM,UAAU,CACzC,SAAS,IAAI,CACjB,CACF;EACD,mCACE,YAAY,WACZ,YAAY,eACb;EACD,kCACE,YAAY,WACZ,YAAY,aACb;AACD,SAAO;CACR;CAED,aAAa,kBACXC,QACsB;EACtB,MAAM,EAAE,YAAY,GAAG,MAAM,OAAO;EACpC,MAAM,aAAa,IAAI,WAAW,OAAO;AACzC,SAAO,YAAY,qBAAqB;GACtC,GAAG;GACH,eAAe;EAChB,EAAC;CACH;;;;;;;;;;;CAYD,MAAM,aAAaC,cAA+C;EAChE,IAAI,iBACF,KAAK,eAAe,SAAS,IACzB,KAAK,UAAU,OAAO,CAAC,iBACrB,KAAK,eAAe,SAAS,aAAa,UAAU,CACrD,GACD,KAAK;AAEX,MAAI,KAAK,aAAa,SAAS,GAC7B,iBAAiB,eAAe,OAC9B,CAAC,iBAAiB,CAAC,KAAK,aAAa,SAAS,aAAa,UAAU,CACtE;AAGH,MAAI,gBAAgB,aAAa,SAAS,GAAG;GAC3C,gCACE,KAAK,WACL,cACA,2BACD;GACD,iBAAiB,KAAK,UAAU,OAAO,CAAC,iBACtC,aAAa,SAAS,aAAa,UAAU,CAC9C;EACF;AAED,SAAO,4BACL,gBACA,KAAK,eACL,KAAK,uBACL,KAAK,kBACN;CACF;;;;;;CAOD,MAAM,IAAIC,SAAiBC,QAAuB,OAAwB;EAExE,MAAM,MAAM,MAAM,KAAK,cAAc,MAAM,QAAQ;AAEnD,MAAI,UAAU,MACZ,QAAO,KAAK,UAAU,IAAI;AAG5B,MAAI,KAAK,SAAS,EAChB,QAAO,KAAK,UAAU,IAAI,GAAG;AAG/B,SAAO;CACR;CAED,YAAmC;AACjC,SAAO;GACL,OAAO;GACP,sBAAsB,KAAK;GAC3B,gBAAgB,KAAK;GACrB,cAAc,KAAK;GACnB,uBAAuB,KAAK;EAC7B;CACF;;CAGD,aAAa,UAAU;AACrB,MAAI;GACF,MAAM,EAAE,YAAY,GAAG,MAAM,OAAO;AACpC,UAAO,EAAE,WAAY;EACtB,SAAQ,GAAG;GACV,QAAQ,MAAM,EAAE;AAChB,SAAM,IAAI,MACR;EAEH;CACF;AACF"}