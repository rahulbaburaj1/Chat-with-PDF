{"version":3,"file":"eval_chain.cjs","names":["xs: Set<string>","ys: Set<string>","LLMChain","llm: BaseLanguageModelInterface","options: {\n      prompt?: PromptTemplate;\n      chainInput?: Omit<LLMChainInput, \"llm\">;\n    }","QA_PROMPT","expectedInputVars: Set<string>","inputVarsSet: Set<string>","examples: ChainValues","predictions: ChainValues","args: EvaluateArgs","example: ChainValues","i: number"],"sources":["../../../src/evaluation/qa/eval_chain.ts"],"sourcesContent":["import type { BaseLanguageModelInterface } from \"@langchain/core/language_models/base\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport { PromptTemplate } from \"@langchain/core/prompts\";\nimport { QA_PROMPT } from \"./prompt.js\";\nimport { LLMChain, LLMChainInput } from \"../../chains/llm_chain.js\";\n\nexport interface EvaluateArgs {\n  questionKey: string;\n  answerKey: string;\n  predictionKey: string;\n}\n\nconst eqSet = (xs: Set<string>, ys: Set<string>) =>\n  xs.size === ys.size && [...xs].every((x) => ys.has(x));\n\nexport class QAEvalChain extends LLMChain {\n  static lc_name() {\n    return \"QAEvalChain\";\n  }\n\n  static fromLlm(\n    llm: BaseLanguageModelInterface,\n    options: {\n      prompt?: PromptTemplate;\n      chainInput?: Omit<LLMChainInput, \"llm\">;\n    } = {}\n  ): QAEvalChain {\n    const prompt = options.prompt || QA_PROMPT;\n    const expectedInputVars: Set<string> = new Set([\n      \"query\",\n      \"answer\",\n      \"result\",\n    ]);\n    // Create a Set from inputVariables for a valid comparison\n    const inputVarsSet: Set<string> = new Set(prompt.inputVariables);\n\n    if (!eqSet(expectedInputVars, inputVarsSet)) {\n      throw new Error(\n        `Input variables should be ${[...expectedInputVars]}, but got ${\n          prompt.inputVariables\n        }`\n      );\n    }\n    return new this({ llm, prompt, ...options.chainInput });\n  }\n\n  async evaluate(\n    examples: ChainValues,\n    predictions: ChainValues,\n    args: EvaluateArgs = {\n      questionKey: \"query\",\n      answerKey: \"answer\",\n      predictionKey: \"result\",\n    }\n  ): Promise<ChainValues> {\n    const inputs = examples.map((example: ChainValues, i: number) => ({\n      query: example[args.questionKey],\n      answer: example[args.answerKey],\n      result: predictions[i][args.predictionKey],\n    }));\n\n    return await this.apply(inputs);\n  }\n}\n"],"mappings":";;;;AAYA,MAAM,QAAQ,CAACA,IAAiBC,OAC9B,GAAG,SAAS,GAAG,QAAQ,CAAC,GAAG,EAAG,EAAC,MAAM,CAAC,MAAM,GAAG,IAAI,EAAE,CAAC;AAExD,IAAa,cAAb,cAAiCC,2BAAS;CACxC,OAAO,UAAU;AACf,SAAO;CACR;CAED,OAAO,QACLC,KACAC,UAGI,CAAE,GACO;EACb,MAAM,SAAS,QAAQ,UAAUC;EACjC,MAAMC,oBAAiC,IAAI,IAAI;GAC7C;GACA;GACA;EACD;EAED,MAAMC,eAA4B,IAAI,IAAI,OAAO;AAEjD,MAAI,CAAC,MAAM,mBAAmB,aAAa,CACzC,OAAM,IAAI,MACR,CAAC,0BAA0B,EAAE,CAAC,GAAG,iBAAkB,EAAC,UAAU,EAC5D,OAAO,gBACP;AAGN,SAAO,IAAI,KAAK;GAAE;GAAK;GAAQ,GAAG,QAAQ;EAAY;CACvD;CAED,MAAM,SACJC,UACAC,aACAC,OAAqB;EACnB,aAAa;EACb,WAAW;EACX,eAAe;CAChB,GACqB;EACtB,MAAM,SAAS,SAAS,IAAI,CAACC,SAAsBC,OAAe;GAChE,OAAO,QAAQ,KAAK;GACpB,QAAQ,QAAQ,KAAK;GACrB,QAAQ,YAAY,GAAG,KAAK;EAC7B,GAAE;AAEH,SAAO,MAAM,KAAK,MAAM,OAAO;CAChC;AACF"}