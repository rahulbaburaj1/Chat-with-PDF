{"version":3,"file":"types.d.ts","names":["MessageContent","DirectToolOutput","ToolCall","ToolMessage","InferInteropZodInput","InferInteropZodOutput","InteropZodType","CallbackManagerForToolRun","RunnableConfig","RunnableInterface","RunnableToolLike","JsonSchema7Type","BaseLangChainParams","ToolDefinition","z","ResponseFormat","ToolOutputType","ContentAndArtifact","ToolReturnType","TOutput","TConfig","TInput","ToolInputSchemaBase","ZodTypeAny","ToolParams","ToolRunnableConfig","Record","ConfigurableFieldType","ContextSchema","StructuredToolParams","StructuredToolInterface","Pick","ToolInputSchemaOutputType","T","ToolInputSchemaInputType","StructuredToolCallInput","SchemaT","SchemaInputT","StringInputToolSchema","ZodTypeDef","ZodType","ToolOutputT","TArg","Promise","ToolInterface","NonNullable","BaseDynamicToolInput","DynamicToolInput","DynamicStructuredToolInput","SchemaOutputT","isStructuredTool","isRunnableToolLike","isStructuredToolParams","isLangChainTool"],"sources":["../../../../../../langchain-core/dist/tools/types.d.ts"],"sourcesContent":["import { MessageContent } from \"../messages/base.js\";\nimport { DirectToolOutput, ToolCall, ToolMessage } from \"../messages/tool.js\";\nimport { InferInteropZodInput, InferInteropZodOutput, InteropZodType } from \"../utils/types/zod.js\";\nimport { CallbackManagerForToolRun } from \"../callbacks/manager.js\";\nimport { RunnableConfig, RunnableInterface } from \"../runnables/types.js\";\nimport { RunnableToolLike } from \"../runnables/base.js\";\nimport { JsonSchema7Type } from \"../utils/zod-to-json-schema/parseTypes.js\";\nimport { BaseLangChainParams, ToolDefinition } from \"../language_models/base.js\";\nimport { z } from \"zod/v3\";\n\n//#region src/tools/types.d.ts\ntype ResponseFormat = \"content\" | \"content_and_artifact\" | string;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ToolOutputType = any;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ContentAndArtifact = [MessageContent, any];\n/**\n * Conditional type that determines the return type of the {@link StructuredTool.invoke} method.\n * - If the input is a ToolCall, it returns a ToolMessage\n * - If the config is a runnable config and contains a toolCall property, it returns a ToolMessage\n * - Otherwise, it returns the original output type\n */\ntype ToolReturnType<TInput, TConfig, TOutput> = TOutput extends DirectToolOutput ? TOutput : TConfig extends {\n  toolCall: {\n    id: string;\n  };\n} ? ToolMessage : TConfig extends {\n  toolCall: {\n    id: undefined;\n  };\n} ? TOutput : TConfig extends {\n  toolCall: {\n    id?: string;\n  };\n} ? TOutput | ToolMessage : TInput extends ToolCall ? ToolMessage : TOutput;\n/**\n * Base type that establishes the types of input schemas that can be used for LangChain tool\n * definitions.\n */\ntype ToolInputSchemaBase = z.ZodTypeAny | JsonSchema7Type;\n/**\n * Parameters for the Tool classes.\n */\ninterface ToolParams extends BaseLangChainParams {\n  /**\n   * The tool response format.\n   *\n   * If \"content\" then the output of the tool is interpreted as the contents of a\n   * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n   * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n   *\n   * @default \"content\"\n   */\n  responseFormat?: ResponseFormat;\n  /**\n   * Default config object for the tool runnable.\n   */\n  defaultConfig?: ToolRunnableConfig;\n  /**\n   * Whether to show full details in the thrown parsing errors.\n   *\n   * @default false\n   */\n  verboseParsingErrors?: boolean;\n  /**\n   * Metadata for the tool.\n   */\n  metadata?: Record<string, unknown>;\n}\ntype ToolRunnableConfig<\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nConfigurableFieldType extends Record<string, any> = Record<string, any>,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nContextSchema = any> = RunnableConfig<ConfigurableFieldType> & {\n  toolCall?: ToolCall;\n  context?: ContextSchema;\n};\n/**\n * Schema for defining tools.\n *\n * @version 0.2.19\n */\ninterface StructuredToolParams extends Pick<StructuredToolInterface, \"name\" | \"schema\"> {\n  /**\n   * An optional description of the tool to pass to the model.\n   */\n  description?: string;\n}\n/**\n * Utility type that resolves the output type of a tool input schema.\n *\n * Input & Output types are a concept used with Zod schema, as Zod allows for transforms to occur\n * during parsing. When using JSONSchema, input and output types are the same.\n *\n * The input type for a given schema should match the structure of the arguments that the LLM\n * generates as part of its {@link ToolCall}. The output type will be the type that results from\n * applying any transforms defined in your schema. If there are no transforms, the input and output\n * types will be the same.\n */\ntype ToolInputSchemaOutputType<T> = T extends InteropZodType ? InferInteropZodOutput<T> : T extends JsonSchema7Type ? unknown : never;\n/**\n * Utility type that resolves the input type of a tool input schema.\n *\n * Input & Output types are a concept used with Zod schema, as Zod allows for transforms to occur\n * during parsing. When using JSONSchema, input and output types are the same.\n *\n * The input type for a given schema should match the structure of the arguments that the LLM\n * generates as part of its {@link ToolCall}. The output type will be the type that results from\n * applying any transforms defined in your schema. If there are no transforms, the input and output\n * types will be the same.\n */\ntype ToolInputSchemaInputType<T> = T extends InteropZodType ? InferInteropZodInput<T> : T extends JsonSchema7Type ? unknown : never;\n/**\n * Defines the type that will be passed into a tool handler function as a result of a tool call.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\ntype StructuredToolCallInput<SchemaT = ToolInputSchemaBase, SchemaInputT = ToolInputSchemaInputType<SchemaT>> = (ToolInputSchemaOutputType<SchemaT> extends string ? string : never) | SchemaInputT | ToolCall;\n/**\n * An input schema type for tools that accept a single string input.\n *\n * This schema defines a tool that takes an optional string parameter named \"input\".\n * It uses Zod's effects to transform the input and strip any extra properties.\n *\n * This is primarily used for creating simple string-based tools where the LLM\n * only needs to provide a single text value as input to the tool.\n */\ntype StringInputToolSchema = z.ZodType<string | undefined, z.ZodTypeDef,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nany>;\n/**\n * Defines the type for input to a tool's call method.\n *\n * This type is a convenience alias for StructuredToolCallInput with the input type\n * derived from the schema. It represents the possible inputs that can be passed to a tool,\n * which can be either:\n * - A string (if the tool accepts string input)\n * - A structured input matching the tool's schema\n * - A ToolCall object (typically from an LLM)\n *\n * @param SchemaT - The schema type for the tool input, defaults to StringInputToolSchema\n */\n\n/**\n * Interface that defines the shape of a LangChain structured tool.\n *\n * A structured tool is a tool that uses a schema to define the structure of the arguments that the\n * LLM generates as part of its {@link ToolCall}.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\ninterface StructuredToolInterface<SchemaT = ToolInputSchemaBase, SchemaInputT = ToolInputSchemaInputType<SchemaT>, ToolOutputT = ToolOutputType> extends RunnableInterface<StructuredToolCallInput<SchemaT, SchemaInputT>, ToolOutputT | ToolMessage> {\n  lc_namespace: string[];\n  /**\n   * A Zod schema representing the parameters of the tool.\n   */\n  schema: SchemaT;\n  /**\n   * Invokes the tool with the provided argument and configuration.\n   * @param arg The input argument for the tool.\n   * @param configArg Optional configuration for the tool call.\n   * @returns A Promise that resolves with the tool's output.\n   */\n  invoke<TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>, TConfig extends ToolRunnableConfig | undefined>(arg: TArg, configArg?: TConfig): Promise<ToolReturnType<TArg, TConfig, ToolOutputT>>;\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument, configuration, and tags. It\n   * parses the input according to the schema, handles any errors, and\n   * manages callbacks.\n   * @param arg The input argument for the tool.\n   * @param configArg Optional configuration or callbacks for the tool.\n   * @param tags Optional tags for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  call<TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>, TConfig extends ToolRunnableConfig | undefined>(arg: TArg, configArg?: TConfig, /** @deprecated */\n  tags?: string[]): Promise<ToolReturnType<TArg, TConfig, ToolOutputT>>;\n  /**\n   * The name of the tool.\n   */\n  name: string;\n  /**\n   * A description of the tool.\n   */\n  description: string;\n  /**\n   * Whether to return the tool's output directly.\n   *\n   * Setting this to true means that after the tool is called,\n   * an agent should stop looping.\n   */\n  returnDirect: boolean;\n}\n/**\n * A special interface for tools that accept a string input, usually defined with the {@link Tool} class.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\ninterface ToolInterface<SchemaT = StringInputToolSchema, SchemaInputT = ToolInputSchemaInputType<SchemaT>, ToolOutputT = ToolOutputType> extends StructuredToolInterface<SchemaT, SchemaInputT, ToolOutputT> {\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument and callbacks. It handles\n   * string inputs specifically.\n   * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n   * @param callbacks Optional callbacks for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  call<TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>, TConfig extends ToolRunnableConfig | undefined>(\n  // TODO: shouldn't this be narrowed based on SchemaT?\n  arg: TArg, callbacks?: TConfig): Promise<ToolReturnType<NonNullable<TArg>, TConfig, ToolOutputT>>;\n}\n/**\n * Base interface for the input parameters of the {@link DynamicTool} and\n * {@link DynamicStructuredTool} classes.\n */\ninterface BaseDynamicToolInput extends ToolParams {\n  name: string;\n  description: string;\n  /**\n   * Whether to return the tool's output directly.\n   *\n   * Setting this to true means that after the tool is called,\n   * an agent should stop looping.\n   */\n  returnDirect?: boolean;\n}\n/**\n * Interface for the input parameters of the DynamicTool class.\n */\ninterface DynamicToolInput<ToolOutputT = ToolOutputType> extends BaseDynamicToolInput {\n  func: (input: string, runManager?: CallbackManagerForToolRun, config?: ToolRunnableConfig) => Promise<ToolOutputT>;\n}\n/**\n * Interface for the input parameters of the DynamicStructuredTool class.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaOutputT - The TypeScript type representing the result of applying the schema to the tool arguments. Useful for type checking tool handler functions when using JSONSchema.\n */\ninterface DynamicStructuredToolInput<SchemaT = ToolInputSchemaBase, SchemaOutputT = ToolInputSchemaOutputType<SchemaT>, ToolOutputT = ToolOutputType> extends BaseDynamicToolInput {\n  /**\n   * Tool handler function - the function that will be called when the tool is invoked.\n   *\n   * @param input - The input to the tool.\n   * @param runManager - The run manager for the tool.\n   * @param config - The configuration for the tool.\n   * @returns The result of the tool.\n   */\n  func: (input: SchemaOutputT, runManager?: CallbackManagerForToolRun, config?: RunnableConfig) => Promise<ToolOutputT>;\n  schema: SchemaT;\n}\n/**\n * Confirm whether the inputted tool is an instance of `StructuredToolInterface`.\n *\n * @param {StructuredToolInterface | JSONSchema | undefined} tool The tool to check if it is an instance of `StructuredToolInterface`.\n * @returns {tool is StructuredToolInterface} Whether the inputted tool is an instance of `StructuredToolInterface`.\n */\ndeclare function isStructuredTool(tool?: StructuredToolInterface | ToolDefinition | JsonSchema7Type): tool is StructuredToolInterface;\n/**\n * Confirm whether the inputted tool is an instance of `RunnableToolLike`.\n *\n * @param {unknown | undefined} tool The tool to check if it is an instance of `RunnableToolLike`.\n * @returns {tool is RunnableToolLike} Whether the inputted tool is an instance of `RunnableToolLike`.\n */\ndeclare function isRunnableToolLike(tool?: unknown): tool is RunnableToolLike;\n/**\n * Confirm whether or not the tool contains the necessary properties to be considered a `StructuredToolParams`.\n *\n * @param {unknown | undefined} tool The object to check if it is a `StructuredToolParams`.\n * @returns {tool is StructuredToolParams} Whether the inputted object is a `StructuredToolParams`.\n */\ndeclare function isStructuredToolParams(tool?: unknown): tool is StructuredToolParams;\n/**\n * Whether or not the tool is one of StructuredTool, RunnableTool or StructuredToolParams.\n * It returns `is StructuredToolParams` since that is the most minimal interface of the three,\n * while still containing the necessary properties to be passed to a LLM for tool calling.\n *\n * @param {unknown | undefined} tool The tool to check if it is a LangChain tool.\n * @returns {tool is StructuredToolParams} Whether the inputted tool is a LangChain tool.\n */\ndeclare function isLangChainTool(tool?: unknown): tool is StructuredToolParams;\n//#endregion\nexport { BaseDynamicToolInput, ContentAndArtifact, DynamicStructuredToolInput, DynamicToolInput, ResponseFormat, StringInputToolSchema, StructuredToolCallInput, StructuredToolInterface, StructuredToolParams, ToolInputSchemaBase, ToolInputSchemaInputType, ToolInputSchemaOutputType, ToolInterface, ToolOutputType, ToolParams, ToolReturnType, ToolRunnableConfig, isLangChainTool, isRunnableToolLike, isStructuredTool, isStructuredToolParams };\n//# sourceMappingURL=types.d.ts.map"],"mappings":";;;;;;;;;;;;;;;;;;;KAgIKsC,qBAAAA,GAAwBxB,CAAAA,CAAE0B,4BAA4B1B,CAAAA,CAAEyB"}