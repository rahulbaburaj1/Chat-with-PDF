{"version":3,"file":"multi_vector.js","names":["args: MultiVectorRetrieverInput","query: string","ids: string[]"],"sources":["../../src/retrievers/multi_vector.ts"],"sourcesContent":["import {\n  BaseRetriever,\n  type BaseRetrieverInput,\n} from \"@langchain/core/retrievers\";\nimport type { VectorStoreInterface } from \"@langchain/core/vectorstores\";\nimport { Document } from \"@langchain/core/documents\";\nimport { BaseStore, type BaseStoreInterface } from \"@langchain/core/stores\";\nimport { createDocumentStoreFromByteStore } from \"../storage/encoder_backed.js\";\n\n/**\n * Arguments for the MultiVectorRetriever class.\n */\nexport interface MultiVectorRetrieverInput extends BaseRetrieverInput {\n  vectorstore: VectorStoreInterface;\n  /** @deprecated Prefer `byteStore`. */\n  docstore?: BaseStoreInterface<string, Document>;\n  byteStore?: BaseStore<string, Uint8Array>;\n  idKey?: string;\n  childK?: number;\n  parentK?: number;\n}\n\n/**\n * A retriever that retrieves documents from a vector store and a document\n * store. It uses the vector store to find relevant documents based on a\n * query, and then retrieves the full documents from the document store.\n * @example\n * ```typescript\n * const retriever = new MultiVectorRetriever({\n *   vectorstore: new FaissStore(),\n *   byteStore: new InMemoryStore<Unit8Array>(),\n *   idKey: \"doc_id\",\n *   childK: 20,\n *   parentK: 5,\n * });\n *\n * const retrieverResult = await retriever.invoke(\"justice breyer\");\n * console.log(retrieverResult[0].pageContent.length);\n * ```\n */\nexport class MultiVectorRetriever extends BaseRetriever {\n  static lc_name() {\n    return \"MultiVectorRetriever\";\n  }\n\n  lc_namespace = [\"langchain\", \"retrievers\", \"multi_vector\"];\n\n  public vectorstore: VectorStoreInterface;\n\n  public docstore: BaseStoreInterface<string, Document>;\n\n  protected idKey: string;\n\n  protected childK?: number;\n\n  protected parentK?: number;\n\n  constructor(args: MultiVectorRetrieverInput) {\n    super(args);\n    this.vectorstore = args.vectorstore;\n    if (args.byteStore) {\n      this.docstore = createDocumentStoreFromByteStore(args.byteStore);\n    } else if (args.docstore) {\n      this.docstore = args.docstore;\n    } else {\n      throw new Error(\n        \"byteStore and docstore are undefined. Please provide at least one.\"\n      );\n    }\n    this.idKey = args.idKey ?? \"doc_id\";\n    this.childK = args.childK;\n    this.parentK = args.parentK;\n  }\n\n  async _getRelevantDocuments(query: string): Promise<Document[]> {\n    const subDocs = await this.vectorstore.similaritySearch(query, this.childK);\n    const ids: string[] = [];\n    for (const doc of subDocs) {\n      if (doc.metadata[this.idKey] && !ids.includes(doc.metadata[this.idKey])) {\n        ids.push(doc.metadata[this.idKey]);\n      }\n    }\n    const docs = await this.docstore.mget(ids);\n    return docs\n      .filter((doc) => doc !== undefined)\n      .slice(0, this.parentK) as Document[];\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAwCA,IAAa,uBAAb,cAA0C,cAAc;CACtD,OAAO,UAAU;AACf,SAAO;CACR;CAED,eAAe;EAAC;EAAa;EAAc;CAAe;CAE1D,AAAO;CAEP,AAAO;CAEP,AAAU;CAEV,AAAU;CAEV,AAAU;CAEV,YAAYA,MAAiC;EAC3C,MAAM,KAAK;EACX,KAAK,cAAc,KAAK;AACxB,MAAI,KAAK,WACP,KAAK,WAAW,iCAAiC,KAAK,UAAU;WACvD,KAAK,UACd,KAAK,WAAW,KAAK;MAErB,OAAM,IAAI,MACR;EAGJ,KAAK,QAAQ,KAAK,SAAS;EAC3B,KAAK,SAAS,KAAK;EACnB,KAAK,UAAU,KAAK;CACrB;CAED,MAAM,sBAAsBC,OAAoC;EAC9D,MAAM,UAAU,MAAM,KAAK,YAAY,iBAAiB,OAAO,KAAK,OAAO;EAC3E,MAAMC,MAAgB,CAAE;AACxB,OAAK,MAAM,OAAO,QAChB,KAAI,IAAI,SAAS,KAAK,UAAU,CAAC,IAAI,SAAS,IAAI,SAAS,KAAK,OAAO,EACrE,IAAI,KAAK,IAAI,SAAS,KAAK,OAAO;EAGtC,MAAM,OAAO,MAAM,KAAK,SAAS,KAAK,IAAI;AAC1C,SAAO,KACJ,OAAO,CAAC,QAAQ,QAAQ,OAAU,CAClC,MAAM,GAAG,KAAK,QAAQ;CAC1B;AACF"}