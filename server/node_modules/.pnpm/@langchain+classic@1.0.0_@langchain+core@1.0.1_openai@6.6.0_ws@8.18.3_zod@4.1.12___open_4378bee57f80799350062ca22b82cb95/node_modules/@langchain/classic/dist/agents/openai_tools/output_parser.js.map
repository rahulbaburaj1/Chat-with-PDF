{"version":3,"file":"output_parser.js","names":["text: string","generations: ChatGeneration[]","message: BaseMessage","toolCalls: OpenAIClient.Chat.ChatCompletionMessageToolCall[]"],"sources":["../../../src/agents/openai_tools/output_parser.ts"],"sourcesContent":["import type { OpenAIClient } from \"@langchain/openai\";\nimport { AgentAction, AgentFinish } from \"@langchain/core/agents\";\nimport { BaseMessage, isBaseMessage } from \"@langchain/core/messages\";\nimport { ChatGeneration } from \"@langchain/core/outputs\";\nimport { OutputParserException } from \"@langchain/core/output_parsers\";\nimport { AgentMultiActionOutputParser } from \"../types.js\";\nimport {\n  ToolsAgentAction,\n  ToolsAgentStep,\n} from \"../tool_calling/output_parser.js\";\n\nexport type { ToolsAgentAction, ToolsAgentStep };\n\n/**\n * @example\n * ```typescript\n * const prompt = ChatPromptTemplate.fromMessages([\n *   [\"ai\", \"You are a helpful assistant\"],\n *   [\"human\", \"{input}\"],\n *   new MessagesPlaceholder(\"agent_scratchpad\"),\n * ]);\n *\n * const runnableAgent = RunnableSequence.from([\n *   {\n *     input: (i: { input: string; steps: ToolsAgentStep[] }) => i.input,\n *     agent_scratchpad: (i: { input: string; steps: ToolsAgentStep[] }) =>\n *       formatToOpenAIToolMessages(i.steps),\n *   },\n *   prompt,\n *   new ChatOpenAI({\n *     model: \"gpt-3.5-turbo-1106\",\n *     temperature: 0,\n *   }).bindTools(tools),\n *   new OpenAIToolsAgentOutputParser(),\n * ]).withConfig({ runName: \"OpenAIToolsAgent\" });\n *\n * const result = await runnableAgent.invoke({\n *   input:\n *     \"What is the sum of the current temperature in San Francisco, New York, and Tokyo?\",\n * });\n * ```\n */\nexport class OpenAIToolsAgentOutputParser extends AgentMultiActionOutputParser {\n  lc_namespace = [\"langchain\", \"agents\", \"openai\"];\n\n  static lc_name() {\n    return \"OpenAIToolsAgentOutputParser\";\n  }\n\n  async parse(text: string): Promise<AgentAction[] | AgentFinish> {\n    throw new Error(\n      `OpenAIFunctionsAgentOutputParser can only parse messages.\\nPassed input: ${text}`\n    );\n  }\n\n  async parseResult(generations: ChatGeneration[]) {\n    if (\"message\" in generations[0] && isBaseMessage(generations[0].message)) {\n      return this.parseAIMessage(generations[0].message);\n    }\n    throw new Error(\n      \"parseResult on OpenAIFunctionsAgentOutputParser only works on ChatGeneration output\"\n    );\n  }\n\n  /**\n   * Parses the output message into a ToolsAgentAction[] or AgentFinish\n   * object.\n   * @param message The BaseMessage to parse.\n   * @returns A ToolsAgentAction[] or AgentFinish object.\n   */\n  parseAIMessage(message: BaseMessage): ToolsAgentAction[] | AgentFinish {\n    if (message.content && typeof message.content !== \"string\") {\n      throw new Error(\"This agent cannot parse non-string model responses.\");\n    }\n    if (message.additional_kwargs.tool_calls) {\n      const toolCalls: OpenAIClient.Chat.ChatCompletionMessageToolCall[] =\n        message.additional_kwargs.tool_calls;\n      try {\n        return toolCalls\n          .map((toolCall, i) => {\n            if (toolCall.type === \"function\") {\n              const toolInput = toolCall.function.arguments\n                ? JSON.parse(toolCall.function.arguments)\n                : {};\n              const messageLog = i === 0 ? [message] : [];\n              return {\n                tool: toolCall.function.name as string,\n                toolInput,\n                toolCallId: toolCall.id,\n                log: `Invoking \"${toolCall.function.name}\" with ${\n                  toolCall.function.arguments ?? \"{}\"\n                }\\n${message.content}`,\n                messageLog,\n              };\n            }\n            return undefined;\n          })\n          .filter(Boolean) as ToolsAgentAction[];\n      } catch (error) {\n        throw new OutputParserException(\n          `Failed to parse tool arguments from chat model response. Text: \"${JSON.stringify(\n            toolCalls\n          )}\". ${error}`\n        );\n      }\n    } else {\n      return {\n        returnValues: { output: message.content },\n        log: message.content,\n      };\n    }\n  }\n\n  getFormatInstructions(): string {\n    throw new Error(\n      \"getFormatInstructions not implemented inside OpenAIToolsAgentOutputParser.\"\n    );\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CA,IAAa,+BAAb,cAAkD,6BAA6B;CAC7E,eAAe;EAAC;EAAa;EAAU;CAAS;CAEhD,OAAO,UAAU;AACf,SAAO;CACR;CAED,MAAM,MAAMA,MAAoD;AAC9D,QAAM,IAAI,MACR,CAAC,yEAAyE,EAAE,MAAM;CAErF;CAED,MAAM,YAAYC,aAA+B;AAC/C,MAAI,aAAa,YAAY,MAAM,cAAc,YAAY,GAAG,QAAQ,CACtE,QAAO,KAAK,eAAe,YAAY,GAAG,QAAQ;AAEpD,QAAM,IAAI,MACR;CAEH;;;;;;;CAQD,eAAeC,SAAwD;AACrE,MAAI,QAAQ,WAAW,OAAO,QAAQ,YAAY,SAChD,OAAM,IAAI,MAAM;AAElB,MAAI,QAAQ,kBAAkB,YAAY;GACxC,MAAMC,YACJ,QAAQ,kBAAkB;AAC5B,OAAI;AACF,WAAO,UACJ,IAAI,CAAC,UAAU,MAAM;AACpB,SAAI,SAAS,SAAS,YAAY;MAChC,MAAM,YAAY,SAAS,SAAS,YAChC,KAAK,MAAM,SAAS,SAAS,UAAU,GACvC,CAAE;MACN,MAAM,aAAa,MAAM,IAAI,CAAC,OAAQ,IAAG,CAAE;AAC3C,aAAO;OACL,MAAM,SAAS,SAAS;OACxB;OACA,YAAY,SAAS;OACrB,KAAK,CAAC,UAAU,EAAE,SAAS,SAAS,KAAK,OAAO,EAC9C,SAAS,SAAS,aAAa,KAChC,EAAE,EAAE,QAAQ,SAAS;OACtB;MACD;KACF;AACD,YAAO;IACR,EAAC,CACD,OAAO,QAAQ;GACnB,SAAQ,OAAO;AACd,UAAM,IAAI,sBACR,CAAC,gEAAgE,EAAE,KAAK,UACtE,UACD,CAAC,GAAG,EAAE,OAAO;GAEjB;EACF,MACC,QAAO;GACL,cAAc,EAAE,QAAQ,QAAQ,QAAS;GACzC,KAAK,QAAQ;EACd;CAEJ;CAED,wBAAgC;AAC9B,QAAM,IAAI,MACR;CAEH;AACF"}