{"version":3,"file":"index.js","names":["x: LanguageModelLike","input: { steps: ToolsAgentStep[] }"],"sources":["../../../src/agents/tool_calling/index.ts"],"sourcesContent":["import { ChatPromptTemplate } from \"@langchain/core/prompts\";\nimport { StructuredToolInterface } from \"@langchain/core/tools\";\nimport { RunnablePassthrough } from \"@langchain/core/runnables\";\nimport {\n  LanguageModelLike,\n  ToolDefinition,\n} from \"@langchain/core/language_models/base\";\nimport { BaseChatModel } from \"@langchain/core/language_models/chat_models\";\nimport { AgentRunnableSequence } from \"../agent.js\";\nimport {\n  ToolCallingAgentOutputParser,\n  ToolsAgentStep,\n} from \"./output_parser.js\";\nimport { formatToToolMessages } from \"../format_scratchpad/tool_calling.js\";\n\nfunction _isBaseChatModel(x: LanguageModelLike): x is BaseChatModel {\n  const model = x as BaseChatModel;\n  return (\n    typeof model._modelType === \"function\" &&\n    model._modelType() === \"base_chat_model\"\n  );\n}\n\n/**\n * Params used by the createOpenAIToolsAgent function.\n */\nexport type CreateToolCallingAgentParams = {\n  /**\n   * LLM to use as the agent. Should work with OpenAI tool calling,\n   * so must either be an OpenAI model that supports that or a wrapper of\n   * a different model that adds in equivalent support.\n   */\n  llm: LanguageModelLike;\n  /** Tools this agent has access to. */\n  tools: StructuredToolInterface[] | ToolDefinition[];\n  /** The prompt to use, must have an input key of `agent_scratchpad`. */\n  prompt: ChatPromptTemplate;\n  /**\n   * Whether to invoke the underlying model in streaming mode,\n   * allowing streaming of intermediate steps. Defaults to true.\n   */\n  streamRunnable?: boolean;\n};\n\n/**\n * Create an agent that uses tools.\n * @param params Params required to create the agent. Includes an LLM, tools, and prompt.\n * @returns A runnable sequence representing an agent. It takes as input all the same input\n *     variables as the prompt passed in does. It returns as output either an\n *     AgentAction or AgentFinish.\n * @example\n * ```typescript\n * import { ChatAnthropic } from \"@langchain/anthropic\";\n * import { ChatPromptTemplate, MessagesPlaceholder } from \"@langchain/core/prompts\";\n * import { AgentExecutor, createToolCallingAgent } from \"langchain/agents\";\n *\n * const prompt = ChatPromptTemplate.fromMessages(\n *   [\n *     [\"system\", \"You are a helpful assistant\"],\n *     [\"placeholder\", \"{chat_history}\"],\n *     [\"human\", \"{input}\"],\n *     [\"placeholder\", \"{agent_scratchpad}\"],\n *   ]\n * );\n *\n *\n * const llm = new ChatAnthropic({\n *   modelName: \"claude-3-opus-20240229\",\n *   temperature: 0,\n * });\n *\n * // Define the tools the agent will have access to.\n * const tools = [...];\n *\n * const agent = createToolCallingAgent({ llm, tools, prompt });\n *\n * const agentExecutor = new AgentExecutor({ agent, tools });\n *\n * const result = await agentExecutor.invoke({input: \"what is LangChain?\"});\n *\n * // Using with chat history\n * import { AIMessage, HumanMessage } from \"@langchain/core/messages\";\n *\n * const result2 = await agentExecutor.invoke(\n *   {\n *     input: \"what's my name?\",\n *     chat_history: [\n *       new HumanMessage({content: \"hi! my name is bob\"}),\n *       new AIMessage({content: \"Hello Bob! How can I assist you today?\"}),\n *     ],\n *   }\n * );\n * ```\n */\nexport function createToolCallingAgent({\n  llm,\n  tools,\n  prompt,\n  streamRunnable,\n}: CreateToolCallingAgentParams) {\n  if (!prompt.inputVariables.includes(\"agent_scratchpad\")) {\n    throw new Error(\n      [\n        `Prompt must have an input variable named \"agent_scratchpad\".`,\n        `Found ${JSON.stringify(prompt.inputVariables)} instead.`,\n      ].join(\"\\n\")\n    );\n  }\n  let modelWithTools;\n  if (_isBaseChatModel(llm)) {\n    if (llm.bindTools === undefined) {\n      throw new Error(\n        `This agent requires that the \"bind_tools()\" method be implemented on the input model.`\n      );\n    }\n    modelWithTools = llm.bindTools(tools);\n  } else {\n    modelWithTools = llm;\n  }\n\n  const agent = AgentRunnableSequence.fromRunnables(\n    [\n      RunnablePassthrough.assign({\n        agent_scratchpad: (input: { steps: ToolsAgentStep[] }) =>\n          formatToToolMessages(input.steps),\n      }),\n      prompt,\n      modelWithTools,\n      new ToolCallingAgentOutputParser(),\n    ],\n    {\n      name: \"ToolCallingAgent\",\n      streamRunnable,\n      singleAction: false,\n    }\n  );\n  return agent;\n}\n"],"mappings":";;;;;;AAeA,SAAS,iBAAiBA,GAA0C;CAClE,MAAM,QAAQ;AACd,QACE,OAAO,MAAM,eAAe,cAC5B,MAAM,YAAY,KAAK;AAE1B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyED,SAAgB,uBAAuB,EACrC,KACA,OACA,QACA,gBAC6B,EAAE;AAC/B,KAAI,CAAC,OAAO,eAAe,SAAS,mBAAmB,CACrD,OAAM,IAAI,MACR,CACE,CAAC,4DAA4D,CAAC,EAC9D,CAAC,MAAM,EAAE,KAAK,UAAU,OAAO,eAAe,CAAC,SAAS,CAAC,AAC1D,EAAC,KAAK,KAAK;CAGhB,IAAI;AACJ,KAAI,iBAAiB,IAAI,EAAE;AACzB,MAAI,IAAI,cAAc,OACpB,OAAM,IAAI,MACR,CAAC,qFAAqF,CAAC;EAG3F,iBAAiB,IAAI,UAAU,MAAM;CACtC,OACC,iBAAiB;CAGnB,MAAM,QAAQ,sBAAsB,cAClC;EACE,oBAAoB,OAAO,EACzB,kBAAkB,CAACC,UACjB,qBAAqB,MAAM,MAAM,CACpC,EAAC;EACF;EACA;EACA,IAAI;CACL,GACD;EACE,MAAM;EACN;EACA,cAAc;CACf,EACF;AACD,QAAO;AACR"}