{"version":3,"file":"base.js","names":["distanceType: EmbeddingDistanceType","distanceFunctions: { [key in EmbeddingDistanceType]: VectorFunction }","X: number[]","Y: number[]","vectors: number[][]","distanceMetric: EmbeddingDistanceType","fields: EmbeddingDistanceEvalChainInput","args: StringEvaluatorArgs","config: Callbacks | BaseCallbackConfig | undefined","values: ChainValues","_runManager: CallbackManagerForChainRun | undefined","args: PairwiseStringEvaluatorArgs","config?: Callbacks | BaseCallbackConfig"],"sources":["../../../src/evaluation/embedding_distance/base.ts"],"sourcesContent":["import type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport {\n  CallbackManagerForChainRun,\n  Callbacks,\n  BaseCallbackConfig,\n} from \"@langchain/core/callbacks/manager\";\nimport {\n  PairwiseStringEvaluator,\n  PairwiseStringEvaluatorArgs,\n  StringEvaluator,\n  StringEvaluatorArgs,\n} from \"../base.js\";\nimport { cosine } from \"../../util/ml-distance/similarities.js\";\nimport { chebyshev, manhattan } from \"../../util/ml-distance/distances.js\";\nimport { euclidean } from \"../../util/ml-distance-euclidean/euclidean.js\";\n\n/**\n *\n * Embedding Distance Metric.\n *\n * COSINE: Cosine distance metric.\n * EUCLIDEAN: Euclidean distance metric.\n * MANHATTAN: Manhattan distance metric.\n * CHEBYSHEV: Chebyshev distance metric.\n * HAMMING: Hamming distance metric.\n */\nexport type EmbeddingDistanceType =\n  | \"cosine\"\n  | \"euclidean\"\n  | \"manhattan\"\n  | \"chebyshev\";\n\n/**\n * Embedding Distance Evaluation Chain Input.\n */\nexport interface EmbeddingDistanceEvalChainInput {\n  /**\n   * The embedding objects to vectorize the outputs.\n   */\n  embedding?: EmbeddingsInterface;\n\n  /**\n   * The distance metric to use\n   * for comparing the embeddings.\n   */\n  distanceMetric?: EmbeddingDistanceType;\n}\n\ntype VectorFunction = (xVector: number[], yVector: number[]) => number;\n\n/**\n * Get the distance function for the given distance type.\n * @param distance The distance type.\n * @return The distance function.\n */\nexport function getDistanceCalculationFunction(\n  distanceType: EmbeddingDistanceType\n): VectorFunction {\n  const distanceFunctions: { [key in EmbeddingDistanceType]: VectorFunction } =\n    {\n      cosine: (X: number[], Y: number[]) => 1.0 - cosine(X, Y),\n      euclidean,\n      manhattan,\n      chebyshev,\n    };\n\n  return distanceFunctions[distanceType];\n}\n\n/**\n * Compute the score based on the distance metric.\n * @param vectors The input vectors.\n * @param distanceMetric The distance metric.\n * @return The computed score.\n */\nexport function computeEvaluationScore(\n  vectors: number[][],\n  distanceMetric: EmbeddingDistanceType\n): number {\n  const metricFunction = getDistanceCalculationFunction(distanceMetric);\n  return metricFunction(vectors[0], vectors[1]);\n}\n\n/**\n * Use embedding distances to score semantic difference between\n * a prediction and reference.\n */\nexport class EmbeddingDistanceEvalChain\n  extends StringEvaluator\n  implements EmbeddingDistanceEvalChainInput\n{\n  requiresReference = true;\n\n  requiresInput = false;\n\n  outputKey = \"score\";\n\n  embedding?: EmbeddingsInterface;\n\n  distanceMetric: EmbeddingDistanceType = \"cosine\";\n\n  constructor(fields: EmbeddingDistanceEvalChainInput) {\n    super();\n    this.embedding = fields?.embedding;\n    this.distanceMetric = fields?.distanceMetric || \"cosine\";\n  }\n\n  _chainType() {\n    return `embedding_${this.distanceMetric}_distance` as const;\n  }\n\n  async _evaluateStrings(\n    args: StringEvaluatorArgs,\n    config: Callbacks | BaseCallbackConfig | undefined\n  ): Promise<ChainValues> {\n    const result = await this.call(args, config);\n\n    return { [this.outputKey]: result[this.outputKey] };\n  }\n\n  get inputKeys(): string[] {\n    return [\"reference\", \"prediction\"];\n  }\n\n  get outputKeys(): string[] {\n    return [this.outputKey];\n  }\n\n  async _call(\n    values: ChainValues,\n    _runManager: CallbackManagerForChainRun | undefined\n  ): Promise<ChainValues> {\n    const { prediction, reference } = values;\n\n    if (!this.embedding) throw new Error(\"Embedding is undefined\");\n\n    const vectors = await this.embedding.embedDocuments([\n      prediction,\n      reference,\n    ]);\n\n    const score = computeEvaluationScore(vectors, this.distanceMetric);\n\n    return { [this.outputKey]: score };\n  }\n}\n\n/**\n * Use embedding distances to score semantic difference between two predictions.\n */\nexport class PairwiseEmbeddingDistanceEvalChain\n  extends PairwiseStringEvaluator\n  implements EmbeddingDistanceEvalChainInput\n{\n  requiresReference = false;\n\n  requiresInput = false;\n\n  outputKey = \"score\";\n\n  embedding?: EmbeddingsInterface;\n\n  distanceMetric: EmbeddingDistanceType = \"cosine\";\n\n  constructor(fields: EmbeddingDistanceEvalChainInput) {\n    super();\n    this.embedding = fields?.embedding;\n    this.distanceMetric = fields?.distanceMetric || \"cosine\";\n  }\n\n  _chainType() {\n    return `pairwise_embedding_${this.distanceMetric}_distance` as const;\n  }\n\n  async _evaluateStringPairs(\n    args: PairwiseStringEvaluatorArgs,\n    config?: Callbacks | BaseCallbackConfig\n  ): Promise<ChainValues> {\n    const result = await this.call(args, config);\n\n    return { [this.outputKey]: result[this.outputKey] };\n  }\n\n  get inputKeys(): string[] {\n    return [\"prediction\", \"predictionB\"];\n  }\n\n  get outputKeys(): string[] {\n    return [this.outputKey];\n  }\n\n  async _call(\n    values: ChainValues,\n    _runManager: CallbackManagerForChainRun | undefined\n  ): Promise<ChainValues> {\n    const { prediction, predictionB } = values;\n\n    if (!this.embedding) throw new Error(\"Embedding is undefined\");\n\n    const vectors = await this.embedding.embedDocuments([\n      prediction,\n      predictionB,\n    ]);\n\n    const score = computeEvaluationScore(vectors, this.distanceMetric);\n\n    return { [this.outputKey]: score };\n  }\n}\n"],"mappings":";;;;;;;;;;;AAwDA,SAAgB,+BACdA,cACgB;CAChB,MAAMC,oBACJ;EACE,QAAQ,CAACC,GAAaC,MAAgB,IAAM,OAAO,GAAG,EAAE;EACxD;EACA;EACA;CACD;AAEH,QAAO,kBAAkB;AAC1B;;;;;;;AAQD,SAAgB,uBACdC,SACAC,gBACQ;CACR,MAAM,iBAAiB,+BAA+B,eAAe;AACrE,QAAO,eAAe,QAAQ,IAAI,QAAQ,GAAG;AAC9C;;;;;AAMD,IAAa,6BAAb,cACU,gBAEV;CACE,oBAAoB;CAEpB,gBAAgB;CAEhB,YAAY;CAEZ;CAEA,iBAAwC;CAExC,YAAYC,QAAyC;EACnD,OAAO;EACP,KAAK,YAAY,QAAQ;EACzB,KAAK,iBAAiB,QAAQ,kBAAkB;CACjD;CAED,aAAa;AACX,SAAO,CAAC,UAAU,EAAE,KAAK,eAAe,SAAS,CAAC;CACnD;CAED,MAAM,iBACJC,MACAC,QACsB;EACtB,MAAM,SAAS,MAAM,KAAK,KAAK,MAAM,OAAO;AAE5C,SAAO,GAAG,KAAK,YAAY,OAAO,KAAK,WAAY;CACpD;CAED,IAAI,YAAsB;AACxB,SAAO,CAAC,aAAa,YAAa;CACnC;CAED,IAAI,aAAuB;AACzB,SAAO,CAAC,KAAK,SAAU;CACxB;CAED,MAAM,MACJC,QACAC,aACsB;EACtB,MAAM,EAAE,YAAY,WAAW,GAAG;AAElC,MAAI,CAAC,KAAK,UAAW,OAAM,IAAI,MAAM;EAErC,MAAM,UAAU,MAAM,KAAK,UAAU,eAAe,CAClD,YACA,SACD,EAAC;EAEF,MAAM,QAAQ,uBAAuB,SAAS,KAAK,eAAe;AAElE,SAAO,GAAG,KAAK,YAAY,MAAO;CACnC;AACF;;;;AAKD,IAAa,qCAAb,cACU,wBAEV;CACE,oBAAoB;CAEpB,gBAAgB;CAEhB,YAAY;CAEZ;CAEA,iBAAwC;CAExC,YAAYJ,QAAyC;EACnD,OAAO;EACP,KAAK,YAAY,QAAQ;EACzB,KAAK,iBAAiB,QAAQ,kBAAkB;CACjD;CAED,aAAa;AACX,SAAO,CAAC,mBAAmB,EAAE,KAAK,eAAe,SAAS,CAAC;CAC5D;CAED,MAAM,qBACJK,MACAC,QACsB;EACtB,MAAM,SAAS,MAAM,KAAK,KAAK,MAAM,OAAO;AAE5C,SAAO,GAAG,KAAK,YAAY,OAAO,KAAK,WAAY;CACpD;CAED,IAAI,YAAsB;AACxB,SAAO,CAAC,cAAc,aAAc;CACrC;CAED,IAAI,aAAuB;AACzB,SAAO,CAAC,KAAK,SAAU;CACxB;CAED,MAAM,MACJH,QACAC,aACsB;EACtB,MAAM,EAAE,YAAY,aAAa,GAAG;AAEpC,MAAI,CAAC,KAAK,UAAW,OAAM,IAAI,MAAM;EAErC,MAAM,UAAU,MAAM,KAAK,UAAU,eAAe,CAClD,YACA,WACD,EAAC;EAEF,MAAM,QAAQ,uBAAuB,SAAS,KAAK,eAAe;AAElE,SAAO,GAAG,KAAK,YAAY,MAAO;CACnC;AACF"}