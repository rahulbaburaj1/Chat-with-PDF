{"version":3,"file":"generative_agent_memory.js","names":["llm: BaseLanguageModelInterface","memoryRetriever: TimeWeightedVectorStoreRetriever","config: Omit<GenerativeAgentMemoryConfig, \"maxTokensLimit\">","prompt: PromptTemplate","values: ChainValues","runManager?: CallbackManagerForChainRun","now?: Date","newInsights: string[]","memoryContent: string","lastK: number","o: { pageContent: string }","topic: string","relatedStatements: string","text: string","observation: string","_now?: Date","config?: GenerativeAgentMemoryConfig","metadata?: Record<string, unknown>","callbacks?: Callbacks","relevantMemories: Document[]","consumedTokens: number","inputs: InputValues","query: string","_inputs: InputValues","outputs: OutputValues"],"sources":["../../../src/experimental/generative_agents/generative_agent_memory.ts"],"sourcesContent":["import type { BaseLanguageModelInterface } from \"@langchain/core/language_models/base\";\nimport { PromptTemplate } from \"@langchain/core/prompts\";\nimport { Document } from \"@langchain/core/documents\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport { BaseMemory, InputValues, OutputValues } from \"@langchain/core/memory\";\nimport {\n  CallbackManagerForChainRun,\n  Callbacks,\n} from \"@langchain/core/callbacks/manager\";\nimport { TimeWeightedVectorStoreRetriever } from \"../../retrievers/time_weighted.js\";\nimport { BaseChain } from \"../../chains/base.js\";\nimport { LLMChain } from \"../../chains/llm_chain.js\";\n\nexport type GenerativeAgentMemoryConfig = {\n  reflectionThreshold?: number;\n  importanceWeight?: number;\n  verbose?: boolean;\n  maxTokensLimit?: number;\n};\n\n/**\n * Class that manages the memory of a generative agent in LangChain. It\n * extends the `BaseChain` class and has methods for adding observations\n * or memories to the agent's memory, scoring the importance of a memory,\n * reflecting on recent events to add synthesized memories, and generating\n * insights on a topic of reflection based on pertinent memories.\n */\nclass GenerativeAgentMemoryChain extends BaseChain {\n  static lc_name() {\n    return \"GenerativeAgentMemoryChain\";\n  }\n\n  reflecting = false;\n\n  reflectionThreshold?: number;\n\n  importanceWeight = 0.15;\n\n  memoryRetriever: TimeWeightedVectorStoreRetriever;\n\n  llm: BaseLanguageModelInterface;\n\n  verbose = false;\n\n  private aggregateImportance = 0.0;\n\n  constructor(\n    llm: BaseLanguageModelInterface,\n    memoryRetriever: TimeWeightedVectorStoreRetriever,\n    config: Omit<GenerativeAgentMemoryConfig, \"maxTokensLimit\">\n  ) {\n    super();\n    this.llm = llm;\n    this.memoryRetriever = memoryRetriever;\n    this.reflectionThreshold = config.reflectionThreshold;\n    this.importanceWeight = config.importanceWeight ?? this.importanceWeight;\n    this.verbose = config.verbose ?? this.verbose;\n  }\n\n  _chainType(): string {\n    return \"generative_agent_memory\";\n  }\n\n  get inputKeys(): string[] {\n    return [\"memory_content\", \"now\", \"memory_metadata\"];\n  }\n\n  get outputKeys(): string[] {\n    return [\"output\"];\n  }\n\n  /**\n   * Method that creates a new LLMChain with the given prompt.\n   * @param prompt The PromptTemplate to use for the new LLMChain.\n   * @returns A new LLMChain instance.\n   */\n  chain(prompt: PromptTemplate): LLMChain {\n    const chain = new LLMChain({\n      llm: this.llm,\n      prompt,\n      verbose: this.verbose,\n      outputKey: \"output\",\n    });\n    return chain;\n  }\n\n  async _call(values: ChainValues, runManager?: CallbackManagerForChainRun) {\n    const { memory_content: memoryContent, now } = values;\n    // add an observation or memory to the agent's memory\n    const importanceScore = await this.scoreMemoryImportance(\n      memoryContent,\n      runManager\n    );\n    this.aggregateImportance += importanceScore;\n    const document = new Document({\n      pageContent: memoryContent,\n      metadata: {\n        importance: importanceScore,\n        ...values.memory_metadata,\n      },\n    });\n    await this.memoryRetriever.addDocuments([document]);\n    // after an agent has processed a certain amount of memories (as measured by aggregate importance),\n    // it is time to pause and reflect on recent events to add more synthesized memories to the agent's\n    // memory stream.\n    if (\n      this.reflectionThreshold !== undefined &&\n      this.aggregateImportance > this.reflectionThreshold &&\n      !this.reflecting\n    ) {\n      console.log(\"Reflecting on current memories...\");\n      this.reflecting = true;\n      await this.pauseToReflect(now, runManager);\n      this.aggregateImportance = 0.0;\n      this.reflecting = false;\n    }\n    return { output: importanceScore };\n  }\n\n  /**\n   * Method that pauses the agent to reflect on recent events and generate\n   * new insights.\n   * @param now The current date.\n   * @param runManager The CallbackManagerForChainRun to use for the reflection.\n   * @returns An array of new insights as strings.\n   */\n  async pauseToReflect(\n    now?: Date,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<string[]> {\n    if (this.verbose) {\n      console.log(\"Pausing to reflect...\");\n    }\n    const newInsights: string[] = [];\n    const topics = await this.getTopicsOfReflection(50, runManager);\n    for (const topic of topics) {\n      const insights = await this.getInsightsOnTopic(topic, now, runManager);\n      for (const insight of insights) {\n        // add memory\n        await this.call(\n          {\n            memory_content: insight,\n            now,\n            memory_metadata: {\n              source: \"reflection_insight\",\n            },\n          },\n          runManager?.getChild(\"reflection_insight_memory\")\n        );\n      }\n      newInsights.push(...insights);\n    }\n    return newInsights;\n  }\n\n  /**\n   * Method that scores the importance of a given memory.\n   * @param memoryContent The content of the memory to score.\n   * @param runManager The CallbackManagerForChainRun to use for scoring.\n   * @returns The importance score of the memory as a number.\n   */\n  async scoreMemoryImportance(\n    memoryContent: string,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<number> {\n    // score the absolute importance of a given memory\n    const prompt = PromptTemplate.fromTemplate(\n      \"On the scale of 1 to 10, where 1 is purely mundane\" +\n        \" (e.g., brushing teeth, making bed) and 10 is\" +\n        \" extremely poignant (e.g., a break up, college\" +\n        \" acceptance), rate the likely poignancy of the\" +\n        \" following piece of memory. Respond with a single integer.\" +\n        \"\\nMemory: {memory_content}\" +\n        \"\\nRating: \"\n    );\n    const score = await this.chain(prompt).run(\n      memoryContent,\n      runManager?.getChild(\"determine_importance\")\n    );\n\n    const strippedScore = score.trim();\n\n    if (this.verbose) {\n      console.log(\"Importance score:\", strippedScore);\n    }\n    const match = strippedScore.match(/^\\D*(\\d+)/);\n    if (match) {\n      const capturedNumber = parseFloat(match[1]);\n      const result = (capturedNumber / 10) * this.importanceWeight;\n      return result;\n    } else {\n      return 0.0;\n    }\n  }\n\n  /**\n   * Method that retrieves the topics of reflection based on the last K\n   * memories.\n   * @param lastK The number of most recent memories to consider for generating topics.\n   * @param runManager The CallbackManagerForChainRun to use for retrieving topics.\n   * @returns An array of topics of reflection as strings.\n   */\n  async getTopicsOfReflection(\n    lastK: number,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<string[]> {\n    const prompt = PromptTemplate.fromTemplate(\n      \"{observations}\\n\\n\" +\n        \"Given only the information above, what are the 3 most salient\" +\n        \" high-level questions we can answer about the subjects in\" +\n        \" the statements? Provide each question on a new line.\\n\\n\"\n    );\n\n    const observations = this.memoryRetriever.getMemoryStream().slice(-lastK);\n    const observationStr = observations\n      .map((o: { pageContent: string }) => o.pageContent)\n      .join(\"\\n\");\n    const result = await this.chain(prompt).run(\n      observationStr,\n      runManager?.getChild(\"reflection_topics\")\n    );\n    return GenerativeAgentMemoryChain.parseList(result);\n  }\n\n  /**\n   * Method that generates insights on a given topic of reflection based on\n   * pertinent memories.\n   * @param topic The topic of reflection.\n   * @param now The current date.\n   * @param runManager The CallbackManagerForChainRun to use for generating insights.\n   * @returns An array of insights as strings.\n   */\n  async getInsightsOnTopic(\n    topic: string,\n    now?: Date,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<string[]> {\n    // generate insights on a topic of reflection, based on pertinent memories\n    const prompt = PromptTemplate.fromTemplate(\n      \"Statements about {topic}\\n\" +\n        \"{related_statements}\\n\\n\" +\n        \"What 5 high-level insights can you infer from the above statements?\" +\n        \" (example format: insight (because of 1, 5, 3))\"\n    );\n\n    const relatedMemories = await this.fetchMemories(topic, now, runManager);\n    const relatedStatements: string = relatedMemories\n      .map((memory, index) => `${index + 1}. ${memory.pageContent}`)\n      .join(\"\\n\");\n    const result = await this.chain(prompt).call(\n      {\n        topic,\n        related_statements: relatedStatements,\n      },\n      runManager?.getChild(\"reflection_insights\")\n    );\n    return GenerativeAgentMemoryChain.parseList(result.output); // added output\n  }\n\n  /**\n   * Method that parses a newline-separated string into a list of strings.\n   * @param text The newline-separated string to parse.\n   * @returns An array of strings.\n   */\n  static parseList(text: string): string[] {\n    // parse a newine seperates string into a list of strings\n    return text.split(\"\\n\").map((s) => s.trim());\n  }\n\n  // TODO: Mock \"now\" to simulate different times\n  /**\n   * Method that fetches memories related to a given observation.\n   * @param observation The observation to fetch memories for.\n   * @param _now The current date.\n   * @param runManager The CallbackManagerForChainRun to use for fetching memories.\n   * @returns An array of Document instances representing the fetched memories.\n   */\n  async fetchMemories(\n    observation: string,\n    _now?: Date,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<Document[]> {\n    return this.memoryRetriever.invoke(\n      observation,\n      runManager?.getChild(\"memory_retriever\")\n    );\n  }\n}\n\n/**\n * Class that manages the memory of a generative agent in LangChain. It\n * extends the `BaseMemory` class and has methods for adding a memory,\n * formatting memories, getting memories until a token limit is reached,\n * loading memory variables, saving the context of a model run to memory,\n * and clearing memory contents.\n * @example\n * ```typescript\n * const createNewMemoryRetriever = async () => {\n *   const vectorStore = new MemoryVectorStore(new OpenAIEmbeddings());\n *   const retriever = new TimeWeightedVectorStoreRetriever({\n *     vectorStore,\n *     otherScoreKeys: [\"importance\"],\n *     k: 15,\n *   });\n *   return retriever;\n * };\n * const tommiesMemory = new GenerativeAgentMemory(\n *   llm,\n *   await createNewMemoryRetriever(),\n *   { reflectionThreshold: 8 },\n * );\n * const summary = await tommiesMemory.getSummary();\n * ```\n */\nexport class GenerativeAgentMemory extends BaseMemory {\n  llm: BaseLanguageModelInterface;\n\n  memoryRetriever: TimeWeightedVectorStoreRetriever;\n\n  verbose: boolean;\n\n  reflectionThreshold?: number;\n\n  private maxTokensLimit = 1200;\n\n  queriesKey = \"queries\";\n\n  mostRecentMemoriesTokenKey = \"recent_memories_token\";\n\n  addMemoryKey = \"addMemory\";\n\n  relevantMemoriesKey = \"relevant_memories\";\n\n  relevantMemoriesSimpleKey = \"relevant_memories_simple\";\n\n  mostRecentMemoriesKey = \"most_recent_memories\";\n\n  nowKey = \"now\";\n\n  memoryChain: GenerativeAgentMemoryChain;\n\n  constructor(\n    llm: BaseLanguageModelInterface,\n    memoryRetriever: TimeWeightedVectorStoreRetriever,\n    config?: GenerativeAgentMemoryConfig\n  ) {\n    super();\n    this.llm = llm;\n    this.memoryRetriever = memoryRetriever;\n    this.verbose = config?.verbose ?? this.verbose;\n    this.reflectionThreshold =\n      config?.reflectionThreshold ?? this.reflectionThreshold;\n    this.maxTokensLimit = config?.maxTokensLimit ?? this.maxTokensLimit;\n    this.memoryChain = new GenerativeAgentMemoryChain(llm, memoryRetriever, {\n      reflectionThreshold: config?.reflectionThreshold,\n      importanceWeight: config?.importanceWeight,\n    });\n  }\n\n  /**\n   * Method that returns the key for relevant memories.\n   * @returns The key for relevant memories as a string.\n   */\n  getRelevantMemoriesKey(): string {\n    return this.relevantMemoriesKey;\n  }\n\n  /**\n   * Method that returns the key for the most recent memories token.\n   * @returns The key for the most recent memories token as a string.\n   */\n  getMostRecentMemoriesTokenKey(): string {\n    return this.mostRecentMemoriesTokenKey;\n  }\n\n  /**\n   * Method that returns the key for adding a memory.\n   * @returns The key for adding a memory as a string.\n   */\n  getAddMemoryKey(): string {\n    return this.addMemoryKey;\n  }\n\n  /**\n   * Method that returns the key for the current time.\n   * @returns The key for the current time as a string.\n   */\n  getCurrentTimeKey(): string {\n    return this.nowKey;\n  }\n\n  get memoryKeys(): string[] {\n    // Return an array of memory keys\n    return [this.relevantMemoriesKey, this.mostRecentMemoriesKey];\n  }\n\n  /**\n   * Method that adds a memory to the agent's memory.\n   * @param memoryContent The content of the memory to add.\n   * @param now The current date.\n   * @param metadata The metadata for the memory.\n   * @param callbacks The Callbacks to use for adding the memory.\n   * @returns The result of the memory addition.\n   */\n  async addMemory(\n    memoryContent: string,\n    now?: Date,\n    metadata?: Record<string, unknown>,\n    callbacks?: Callbacks\n  ) {\n    return this.memoryChain.call(\n      { memory_content: memoryContent, now, memory_metadata: metadata },\n      callbacks\n    );\n  }\n\n  /**\n   * Method that formats the given relevant memories in detail.\n   * @param relevantMemories The relevant memories to format.\n   * @returns The formatted memories as a string.\n   */\n  formatMemoriesDetail(relevantMemories: Document[]): string {\n    if (!relevantMemories.length) {\n      return \"No relevant information.\";\n    }\n    const contentStrings = new Set();\n    const content = [];\n    for (const memory of relevantMemories) {\n      if (memory.pageContent in contentStrings) {\n        continue;\n      }\n      contentStrings.add(memory.pageContent);\n      const createdTime = memory.metadata.created_at.toLocaleString(\"en-US\", {\n        month: \"long\",\n        day: \"numeric\",\n        year: \"numeric\",\n        hour: \"numeric\",\n        minute: \"numeric\",\n        hour12: true,\n      });\n      content.push(`${createdTime}: ${memory.pageContent.trim()}`);\n    }\n    const joinedContent = content.map((mem) => `${mem}`).join(\"\\n\");\n    return joinedContent;\n  }\n\n  /**\n   * Method that formats the given relevant memories in a simple manner.\n   * @param relevantMemories The relevant memories to format.\n   * @returns The formatted memories as a string.\n   */\n  formatMemoriesSimple(relevantMemories: Document[]): string {\n    const joinedContent = relevantMemories\n      .map((mem) => `${mem.pageContent}`)\n      .join(\"; \");\n    return joinedContent;\n  }\n\n  /**\n   * Method that retrieves memories until a token limit is reached.\n   * @param consumedTokens The number of tokens consumed so far.\n   * @returns The memories as a string.\n   */\n  async getMemoriesUntilLimit(consumedTokens: number): Promise<string> {\n    // reduce the number of tokens in the documents\n    const result = [];\n    for (const doc of this.memoryRetriever\n      .getMemoryStream()\n      .slice()\n      .reverse()) {\n      if (consumedTokens >= this.maxTokensLimit) {\n        if (this.verbose) {\n          console.log(\"Exceeding max tokens for LLM, filtering memories\");\n        }\n        break;\n      }\n      // eslint-disable-next-line no-param-reassign\n      consumedTokens += await this.llm.getNumTokens(doc.pageContent);\n      if (consumedTokens < this.maxTokensLimit) {\n        result.push(doc);\n      }\n    }\n    return this.formatMemoriesSimple(result);\n  }\n\n  get memoryVariables(): string[] {\n    // input keys this memory class will load dynamically\n    return [];\n  }\n\n  /**\n   * Method that loads memory variables based on the given inputs.\n   * @param inputs The inputs to use for loading memory variables.\n   * @returns An object containing the loaded memory variables.\n   */\n  async loadMemoryVariables(\n    inputs: InputValues\n  ): Promise<Record<string, string>> {\n    const queries = inputs[this.queriesKey];\n    const now = inputs[this.nowKey];\n    if (queries !== undefined) {\n      const relevantMemories = (\n        await Promise.all(\n          queries.map((query: string) =>\n            this.memoryChain.fetchMemories(query, now)\n          )\n        )\n      ).flat();\n      return {\n        [this.relevantMemoriesKey]: this.formatMemoriesDetail(relevantMemories),\n        [this.relevantMemoriesSimpleKey]:\n          this.formatMemoriesSimple(relevantMemories),\n      };\n    }\n    const mostRecentMemoriesToken = inputs[this.mostRecentMemoriesTokenKey];\n    if (mostRecentMemoriesToken !== undefined) {\n      return {\n        [this.mostRecentMemoriesKey]: await this.getMemoriesUntilLimit(\n          mostRecentMemoriesToken\n        ),\n      };\n    }\n    return {};\n  }\n\n  /**\n   * Method that saves the context of a model run to memory.\n   * @param _inputs The inputs of the model run.\n   * @param outputs The outputs of the model run.\n   * @returns Nothing.\n   */\n  async saveContext(\n    _inputs: InputValues,\n    outputs: OutputValues\n  ): Promise<void> {\n    // save the context of this model run to memory\n    const mem = outputs[this.addMemoryKey];\n    const now = outputs[this.nowKey];\n    if (mem) {\n      await this.addMemory(mem, now, {});\n    }\n  }\n\n  /**\n   * Method that clears the memory contents.\n   * @returns Nothing.\n   */\n  clear(): void {\n    // TODO: clear memory contents\n  }\n}\n"],"mappings":"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"}