{"version":3,"file":"index.js","names":["input: ChatAgentInput","tools: ToolInterface[]","_fields?: OutputParserArgs","steps: AgentStep[]","args?: ChatCreatePromptArgs","llm: BaseLanguageModelInterface","args?: ChatCreatePromptArgs & AgentArgs"],"sources":["../../../src/agents/chat/index.ts"],"sourcesContent":["import type { BaseLanguageModelInterface } from \"@langchain/core/language_models/base\";\nimport type { ToolInterface } from \"@langchain/core/tools\";\nimport {\n  ChatPromptTemplate,\n  HumanMessagePromptTemplate,\n  SystemMessagePromptTemplate,\n} from \"@langchain/core/prompts\";\nimport type { AgentStep } from \"@langchain/core/agents\";\nimport { LLMChain } from \"../../chains/llm_chain.js\";\nimport { Optional } from \"../../types/type-utils.js\";\nimport { Agent, AgentArgs, OutputParserArgs } from \"../agent.js\";\nimport { AgentInput } from \"../types.js\";\nimport { ChatAgentOutputParser } from \"./outputParser.js\";\nimport { FORMAT_INSTRUCTIONS, PREFIX, SUFFIX } from \"./prompt.js\";\n\nconst DEFAULT_HUMAN_MESSAGE_TEMPLATE = \"{input}\\n\\n{agent_scratchpad}\";\n\n/**\n * Interface for arguments used to create a chat prompt.\n */\nexport interface ChatCreatePromptArgs {\n  /** String to put after the list of tools. */\n  suffix?: string;\n  /** String to put before the list of tools. */\n  prefix?: string;\n  /** String to use directly as the human message template. */\n  humanMessageTemplate?: string;\n  /** Formattable string to use as the instructions template. */\n  formatInstructions?: string;\n  /** List of input variables the final prompt will expect. */\n  inputVariables?: string[];\n}\n\n/**\n * Type for input data for creating a ChatAgent, extending AgentInput with\n * optional 'outputParser'.\n */\nexport type ChatAgentInput = Optional<AgentInput, \"outputParser\">;\n\n/**\n * Agent for the MRKL chain.\n * @augments Agent\n */\nexport class ChatAgent extends Agent {\n  static lc_name() {\n    return \"ChatAgent\";\n  }\n\n  lc_namespace = [\"langchain\", \"agents\", \"chat\"];\n\n  declare ToolType: ToolInterface;\n\n  constructor(input: ChatAgentInput) {\n    const outputParser =\n      input?.outputParser ?? ChatAgent.getDefaultOutputParser();\n    super({ ...input, outputParser });\n  }\n\n  _agentType() {\n    return \"chat-zero-shot-react-description\" as const;\n  }\n\n  observationPrefix() {\n    return \"Observation: \";\n  }\n\n  llmPrefix() {\n    return \"Thought:\";\n  }\n\n  _stop(): string[] {\n    return [\"Observation:\"];\n  }\n\n  /**\n   * Validates that all tools have descriptions. Throws an error if a tool\n   * without a description is found.\n   * @param tools Array of Tool instances to validate.\n   * @returns void\n   */\n  static validateTools(tools: ToolInterface[]) {\n    const descriptionlessTool = tools.find((tool) => !tool.description);\n    if (descriptionlessTool) {\n      const msg =\n        `Got a tool ${descriptionlessTool.name} without a description.` +\n        ` This agent requires descriptions for all tools.`;\n      throw new Error(msg);\n    }\n  }\n\n  /**\n   * Returns a default output parser for the ChatAgent.\n   * @param _fields Optional OutputParserArgs to customize the output parser.\n   * @returns ChatAgentOutputParser instance\n   */\n  static getDefaultOutputParser(_fields?: OutputParserArgs) {\n    return new ChatAgentOutputParser();\n  }\n\n  /**\n   * Constructs the agent's scratchpad, which is a string representation of\n   * the agent's previous steps.\n   * @param steps Array of AgentStep instances representing the agent's previous steps.\n   * @returns Promise resolving to a string representing the agent's scratchpad.\n   */\n  async constructScratchPad(steps: AgentStep[]): Promise<string> {\n    const agentScratchpad = await super.constructScratchPad(steps);\n    if (agentScratchpad) {\n      return `This was your previous work (but I haven't seen any of it! I only see what you return as final answer):\\n${agentScratchpad}`;\n    }\n    return agentScratchpad;\n  }\n\n  /**\n   * Create prompt in the style of the zero shot agent.\n   *\n   * @param tools - List of tools the agent will have access to, used to format the prompt.\n   * @param args - Arguments to create the prompt with.\n   * @param args.suffix - String to put after the list of tools.\n   * @param args.prefix - String to put before the list of tools.\n   * @param args.humanMessageTemplate - String to use directly as the human message template\n   * @param args.formatInstructions - Formattable string to use as the instructions template\n   */\n  static createPrompt(tools: ToolInterface[], args?: ChatCreatePromptArgs) {\n    const {\n      prefix = PREFIX,\n      suffix = SUFFIX,\n      humanMessageTemplate = DEFAULT_HUMAN_MESSAGE_TEMPLATE,\n      formatInstructions = FORMAT_INSTRUCTIONS,\n    } = args ?? {};\n    const toolStrings = tools\n      .map((tool) => `${tool.name}: ${tool.description}`)\n      .join(\"\\n\");\n    const template = [prefix, toolStrings, formatInstructions, suffix].join(\n      \"\\n\\n\"\n    );\n    const messages = [\n      SystemMessagePromptTemplate.fromTemplate(template),\n      HumanMessagePromptTemplate.fromTemplate(humanMessageTemplate),\n    ];\n    return ChatPromptTemplate.fromMessages(messages);\n  }\n\n  /**\n   * Creates a ChatAgent instance using a language model, tools, and\n   * optional arguments.\n   * @param llm BaseLanguageModelInterface instance to use in the agent.\n   * @param tools Array of Tool instances to include in the agent.\n   * @param args Optional arguments to customize the agent and prompt.\n   * @returns ChatAgent instance\n   */\n  static fromLLMAndTools(\n    llm: BaseLanguageModelInterface,\n    tools: ToolInterface[],\n    args?: ChatCreatePromptArgs & AgentArgs\n  ) {\n    ChatAgent.validateTools(tools);\n    const prompt = ChatAgent.createPrompt(tools, args);\n    const chain = new LLMChain({\n      prompt,\n      llm,\n      callbacks: args?.callbacks ?? args?.callbackManager,\n    });\n    const outputParser =\n      args?.outputParser ?? ChatAgent.getDefaultOutputParser();\n\n    return new ChatAgent({\n      llmChain: chain,\n      outputParser,\n      allowedTools: tools.map((t) => t.name),\n    });\n  }\n}\n"],"mappings":";;;;;;;AAeA,MAAM,iCAAiC;;;;;AA4BvC,IAAa,YAAb,MAAa,kBAAkB,MAAM;CACnC,OAAO,UAAU;AACf,SAAO;CACR;CAED,eAAe;EAAC;EAAa;EAAU;CAAO;CAI9C,YAAYA,OAAuB;EACjC,MAAM,eACJ,OAAO,gBAAgB,UAAU,wBAAwB;EAC3D,MAAM;GAAE,GAAG;GAAO;EAAc,EAAC;CAClC;CAED,aAAa;AACX,SAAO;CACR;CAED,oBAAoB;AAClB,SAAO;CACR;CAED,YAAY;AACV,SAAO;CACR;CAED,QAAkB;AAChB,SAAO,CAAC,cAAe;CACxB;;;;;;;CAQD,OAAO,cAAcC,OAAwB;EAC3C,MAAM,sBAAsB,MAAM,KAAK,CAAC,SAAS,CAAC,KAAK,YAAY;AACnE,MAAI,qBAAqB;GACvB,MAAM,MACJ,CAAC,WAAW,EAAE,oBAAoB,KAAK,uEAAuB,CACZ;AACpD,SAAM,IAAI,MAAM;EACjB;CACF;;;;;;CAOD,OAAO,uBAAuBC,SAA4B;AACxD,SAAO,IAAI;CACZ;;;;;;;CAQD,MAAM,oBAAoBC,OAAqC;EAC7D,MAAM,kBAAkB,MAAM,MAAM,oBAAoB,MAAM;AAC9D,MAAI,gBACF,QAAO,CAAC,yGAAyG,EAAE,iBAAiB;AAEtI,SAAO;CACR;;;;;;;;;;;CAYD,OAAO,aAAaF,OAAwBG,MAA6B;EACvE,MAAM,EACJ,SAAS,QACT,SAAS,QACT,uBAAuB,gCACvB,qBAAqB,qBACtB,GAAG,QAAQ,CAAE;EACd,MAAM,cAAc,MACjB,IAAI,CAAC,SAAS,GAAG,KAAK,KAAK,EAAE,EAAE,KAAK,aAAa,CAAC,CAClD,KAAK,KAAK;EACb,MAAM,WAAW;GAAC;GAAQ;GAAa;GAAoB;EAAO,EAAC,KACjE,OACD;EACD,MAAM,WAAW,CACf,4BAA4B,aAAa,SAAS,EAClD,2BAA2B,aAAa,qBAAqB,AAC9D;AACD,SAAO,mBAAmB,aAAa,SAAS;CACjD;;;;;;;;;CAUD,OAAO,gBACLC,KACAJ,OACAK,MACA;EACA,UAAU,cAAc,MAAM;EAC9B,MAAM,SAAS,UAAU,aAAa,OAAO,KAAK;EAClD,MAAM,QAAQ,IAAI,SAAS;GACzB;GACA;GACA,WAAW,MAAM,aAAa,MAAM;EACrC;EACD,MAAM,eACJ,MAAM,gBAAgB,UAAU,wBAAwB;AAE1D,SAAO,IAAI,UAAU;GACnB,UAAU;GACV;GACA,cAAc,MAAM,IAAI,CAAC,MAAM,EAAE,KAAK;EACvC;CACF;AACF"}