{"version":3,"file":"index.js","names":[],"sources":["../../../../../../../../../node_modules/.pnpm/p-queue@6.6.2/node_modules/p-queue/dist/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst EventEmitter = require(\"eventemitter3\");\nconst p_timeout_1 = require(\"p-timeout\");\nconst priority_queue_1 = require(\"./priority-queue\");\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst empty = () => { };\nconst timeoutError = new p_timeout_1.TimeoutError();\n/**\nPromise queue with concurrency control.\n*/\nclass PQueue extends EventEmitter {\n    constructor(options) {\n        var _a, _b, _c, _d;\n        super();\n        this._intervalCount = 0;\n        this._intervalEnd = 0;\n        this._pendingCount = 0;\n        this._resolveEmpty = empty;\n        this._resolveIdle = empty;\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options);\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''}\\` (${typeof options.interval})`);\n        }\n        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;\n        this._intervalCap = options.intervalCap;\n        this._interval = options.interval;\n        this._queue = new options.queueClass();\n        this._queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this._timeout = options.timeout;\n        this._throwOnTimeout = options.throwOnTimeout === true;\n        this._isPaused = options.autoStart === false;\n    }\n    get _doesIntervalAllowAnother() {\n        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n    }\n    get _doesConcurrentAllowAnother() {\n        return this._pendingCount < this._concurrency;\n    }\n    _next() {\n        this._pendingCount--;\n        this._tryToStartAnother();\n        this.emit('next');\n    }\n    _resolvePromises() {\n        this._resolveEmpty();\n        this._resolveEmpty = empty;\n        if (this._pendingCount === 0) {\n            this._resolveIdle();\n            this._resolveIdle = empty;\n            this.emit('idle');\n        }\n    }\n    _onResumeInterval() {\n        this._onInterval();\n        this._initializeIntervalIfNeeded();\n        this._timeoutId = undefined;\n    }\n    _isIntervalPaused() {\n        const now = Date.now();\n        if (this._intervalId === undefined) {\n            const delay = this._intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this._intervalCount = (this._carryoverConcurrencyCount) ? this._pendingCount : 0;\n            }\n            else {\n                // Act as the interval is pending\n                if (this._timeoutId === undefined) {\n                    this._timeoutId = setTimeout(() => {\n                        this._onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _tryToStartAnother() {\n        if (this._queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this._intervalId) {\n                clearInterval(this._intervalId);\n            }\n            this._intervalId = undefined;\n            this._resolvePromises();\n            return false;\n        }\n        if (!this._isPaused) {\n            const canInitializeInterval = !this._isIntervalPaused();\n            if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n                const job = this._queue.dequeue();\n                if (!job) {\n                    return false;\n                }\n                this.emit('active');\n                job();\n                if (canInitializeInterval) {\n                    this._initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _initializeIntervalIfNeeded() {\n        if (this._isIntervalIgnored || this._intervalId !== undefined) {\n            return;\n        }\n        this._intervalId = setInterval(() => {\n            this._onInterval();\n        }, this._interval);\n        this._intervalEnd = Date.now() + this._interval;\n    }\n    _onInterval() {\n        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {\n            clearInterval(this._intervalId);\n            this._intervalId = undefined;\n        }\n        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n        this._processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    _processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this._tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this._concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this._concurrency = newConcurrency;\n        this._processQueue();\n    }\n    /**\n    Adds a sync or async task to the queue. Always returns a promise.\n    */\n    async add(fn, options = {}) {\n        return new Promise((resolve, reject) => {\n            const run = async () => {\n                this._pendingCount++;\n                this._intervalCount++;\n                try {\n                    const operation = (this._timeout === undefined && options.timeout === undefined) ? fn() : p_timeout_1.default(Promise.resolve(fn()), (options.timeout === undefined ? this._timeout : options.timeout), () => {\n                        if (options.throwOnTimeout === undefined ? this._throwOnTimeout : options.throwOnTimeout) {\n                            reject(timeoutError);\n                        }\n                        return undefined;\n                    });\n                    resolve(await operation);\n                }\n                catch (error) {\n                    reject(error);\n                }\n                this._next();\n            };\n            this._queue.enqueue(run, options);\n            this._tryToStartAnother();\n            this.emit('add');\n        });\n    }\n    /**\n    Same as `.add()`, but accepts an array of sync or async functions.\n\n    @returns A promise that resolves when all functions are resolved.\n    */\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this._isPaused) {\n            return this;\n        }\n        this._isPaused = false;\n        this._processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this._isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this._queue = new this._queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveEmpty;\n            this._resolveEmpty = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this._pendingCount === 0 && this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveIdle;\n            this._resolveIdle = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    Size of the queue.\n    */\n    get size() {\n        return this._queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        return this._queue.filter(options).length;\n    }\n    /**\n    Number of pending promises.\n    */\n    get pending() {\n        return this._pendingCount;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this._isPaused;\n    }\n    get timeout() {\n        return this._timeout;\n    }\n    /**\n    Set the timeout for future operations.\n    */\n    set timeout(milliseconds) {\n        this._timeout = milliseconds;\n    }\n}\nexports.default = PQueue;\n"],"x_google_ignoreList":[0],"mappings":"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"}