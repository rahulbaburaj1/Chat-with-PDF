{"version":3,"file":"base.d.cts","names":["ExpressionNode","Program","ExpressionStatement","CallExpression","StringLiteral","NumericLiteral","BooleanLiteral","Identifier","ObjectExpression","ArrayExpression","PropertyAssignment","MemberExpression","ParseFunction","NodeHandler","Promise","ASTParser"],"sources":["../../../src/output_parsers/expression_type_handlers/base.d.ts"],"sourcesContent":["import type { ExpressionNode, Program, ExpressionStatement, CallExpression, StringLiteral, NumericLiteral, BooleanLiteral, Identifier, ObjectExpression, ArrayExpression, PropertyAssignment, MemberExpression, ParseFunction } from \"../../types/expression-parser.js\";\n/**\n * Abstract class for handling nodes in an expression language. Subclasses\n * must implement the `accepts` and `handle` methods.\n */\nexport declare abstract class NodeHandler {\n    protected parentHandler?: NodeHandler | undefined;\n    constructor(parentHandler?: NodeHandler | undefined);\n    /**\n     * Determines whether the given node is acceptable.\n     * @param node The node to be checked.\n     * @returns A Promise that resolves to either the node itself or a boolean indicating whether the node is acceptable.\n     */\n    abstract accepts(node: ExpressionNode): Promise<ExpressionNode | boolean>;\n    /**\n     * Handles the given node. The specifics of how the node is handled are\n     * determined by the subclass implementation.\n     * @param node The node to be handled.\n     * @returns A Promise that resolves to the result of handling the node.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    abstract handle(node: ExpressionNode): Promise<any>;\n}\n/**\n * Utility class for parsing Abstract Syntax Trees (ASTs). Contains\n * methods for identifying the type of a given node and a method for\n * importing and generating a parser using the Peggy library.\n */\nexport declare class ASTParser {\n    static astParseInstance: ParseFunction;\n    /**\n     * Imports and generates a parser using the Peggy library.\n     * @returns A Promise that resolves to the parser instance.\n     */\n    static importASTParser(): Promise<ParseFunction>;\n    /**\n     * Checks if the given node is a Program node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is a Program node.\n     */\n    static isProgram(node: ExpressionNode): node is Program;\n    /**\n     * Checks if the given node is an ExpressionStatement node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is an ExpressionStatement node.\n     */\n    static isExpressionStatement(node: ExpressionNode): node is ExpressionStatement;\n    /**\n     * Checks if the given node is a CallExpression node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is a CallExpression node.\n     */\n    static isCallExpression(node: ExpressionNode): node is CallExpression;\n    /**\n     * Checks if the given node is a StringLiteral node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is a StringLiteral node.\n     */\n    static isStringLiteral(node: ExpressionNode): node is StringLiteral;\n    /**\n     * Checks if the given node is a NumericLiteral node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is a NumericLiteral node.\n     */\n    static isNumericLiteral(node: ExpressionNode): node is NumericLiteral;\n    /**\n     * Checks if the given node is a BooleanLiteral node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is a BooleanLiteral node.\n     */\n    static isBooleanLiteral(node: ExpressionNode): node is BooleanLiteral;\n    /**\n     * Checks if the given node is an Identifier node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is an Identifier node.\n     */\n    static isIdentifier(node: ExpressionNode): node is Identifier;\n    /**\n     * Checks if the given node is an ObjectExpression node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is an ObjectExpression node.\n     */\n    static isObjectExpression(node: ExpressionNode): node is ObjectExpression;\n    /**\n     * Checks if the given node is an ArrayExpression node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is an ArrayExpression node.\n     */\n    static isArrayExpression(node: ExpressionNode): node is ArrayExpression;\n    /**\n     * Checks if the given node is a PropertyAssignment node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is a PropertyAssignment node.\n     */\n    static isPropertyAssignment(node: ExpressionNode): node is PropertyAssignment;\n    /**\n     * Checks if the given node is a MemberExpression node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is a MemberExpression node.\n     */\n    static isMemberExpression(node: ExpressionNode): node is MemberExpression;\n}\n"],"mappings":";;;;;;AAKA;;AAC8Ba,uBADAA,WAAAA,CACAA;EAAW,UACTA,aAAAA,CAAAA,EADFA,WACEA,GAAAA,SAAAA;EAAW,WAMhBb,CAAAA,aAAAA,CAAAA,EANKa,WAMLb,GAAAA,SAAAA;EAAc;;;;AAQS;EAO7Be,SAAAA,OAAS,CAAA,IAAA,EAfHf,cAeG,CAAA,EAfcc,OAed,CAfsBd,cAetB,GAAA,OAAA,CAAA;EAAA;;;;;;EAY6B;EAMN,SAAWE,MAAAA,CAAAA,IAAAA,EAzBtCF,cAyBsCE,CAAAA,EAzBrBY,OAyBqBZ,CAAAA,GAAAA,CAAAA;;;;;;;AAwB9BF,cA1Cbe,SAAAA,CA0Caf;EAAc,OAAWM,gBAAAA,EAzC9BM,aAyC8BN;EAAc;;;;EAYI,OAM1CN,eAAAA,CAAAA,CAAAA,EAtDLc,OAsDKd,CAtDGY,aAsDHZ,CAAAA;EAAc;;;;;EAY4B,OAAA,SAAA,CAAA,IAAA,EA5DlDA,cA4DkD,CAAA,EAAA,IAAA,IA5DzBC,OA4DyB;;;;;;qCAtDtCD,yBAAyBE;;;;;;gCAM9BF,yBAAyBG;;;;;;+BAM1BH,yBAAyBI;;;;;;gCAMxBJ,yBAAyBK;;;;;;gCAMzBL,yBAAyBM;;;;;;4BAM7BN,yBAAyBO;;;;;;kCAMnBP,yBAAyBQ;;;;;;iCAM1BR,yBAAyBS;;;;;;oCAMtBT,yBAAyBU;;;;;;kCAM3BV,yBAAyBW"}