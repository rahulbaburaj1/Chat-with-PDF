{"version":3,"file":"expression.js","names":["text: string"],"sources":["../../src/output_parsers/expression.ts"],"sourcesContent":["import { BaseOutputParser } from \"@langchain/core/output_parsers\";\nimport { MasterHandler } from \"./expression_type_handlers/factory.js\";\nimport { ParsedType } from \"./expression_type_handlers/types.js\";\nimport { ASTParser } from \"./expression_type_handlers/base.js\";\nimport type { ExpressionNode } from \"../types/expression-parser.js\";\n\nexport type ParseFunction = Awaited<\n  ReturnType<typeof ASTParser.importASTParser>\n>;\n\n/**\n * We need to be able to handle the following cases:\n * ExpressionStatement\n *  CallExpression\n *      Identifier | MemberExpression\n *      ExpressionLiterals: [\n *          CallExpression\n *          StringLiteral\n *          NumericLiteral\n *          ArrayLiteralExpression\n *              ExpressionLiterals\n *          ObjectLiteralExpression\n *              PropertyAssignment\n *                  Identifier\n *                  ExpressionLiterals\n *      ]\n */\n\nexport class ExpressionParser extends BaseOutputParser<ParsedType> {\n  lc_namespace = [\"langchain\", \"output_parsers\", \"expression\"];\n\n  parser: ParseFunction;\n\n  /**\n   * We should separate loading the parser into its own function\n   * because loading the grammar takes some time. If there are\n   * multiple concurrent parse calls, it's faster to just wait\n   * for building the parser once and then use it for all\n   * subsequent calls. See expression.test.ts for an example.\n   */\n  async ensureParser() {\n    if (!this.parser) {\n      this.parser = await ASTParser.importASTParser();\n    }\n  }\n\n  /**\n   * Parses the given text. It first ensures the parser is loaded, then\n   * tries to parse the text. If the parsing fails, it throws an error. If\n   * the parsing is successful, it returns the parsed expression.\n   * @param text The text to be parsed.\n   * @returns The parsed expression\n   */\n  async parse(text: string) {\n    await this.ensureParser();\n\n    try {\n      const program = this.parser(text);\n\n      const node = program.body;\n      if (!ASTParser.isExpressionStatement(node)) {\n        throw new Error(\n          `Expected ExpressionStatement, got ${(node as ExpressionNode).type}`\n        );\n      }\n\n      const { expression: expressionStatement } = node;\n      if (!ASTParser.isCallExpression(expressionStatement)) {\n        throw new Error(\"Expected CallExpression\");\n      }\n      const masterHandler = MasterHandler.createMasterHandler();\n      return await masterHandler.handle(expressionStatement);\n    } catch (err) {\n      throw new Error(`Error parsing ${err}: ${text}`);\n    }\n  }\n\n  /**\n   * This method is currently empty, but it could be used to provide\n   * instructions on the format of the input text.\n   * @returns string\n   */\n  getFormatInstructions(): string {\n    return \"\";\n  }\n}\n\nexport * from \"./expression_type_handlers/types.js\";\n\nexport { MasterHandler } from \"./expression_type_handlers/factory.js\";\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,IAAa,mBAAb,cAAsC,iBAA6B;CACjE,eAAe;EAAC;EAAa;EAAkB;CAAa;CAE5D;;;;;;;;CASA,MAAM,eAAe;AACnB,MAAI,CAAC,KAAK,QACR,KAAK,SAAS,MAAM,UAAU,iBAAiB;CAElD;;;;;;;;CASD,MAAM,MAAMA,MAAc;EACxB,MAAM,KAAK,cAAc;AAEzB,MAAI;GACF,MAAM,UAAU,KAAK,OAAO,KAAK;GAEjC,MAAM,OAAO,QAAQ;AACrB,OAAI,CAAC,UAAU,sBAAsB,KAAK,CACxC,OAAM,IAAI,MACR,CAAC,kCAAkC,EAAG,KAAwB,MAAM;GAIxE,MAAM,EAAE,YAAY,qBAAqB,GAAG;AAC5C,OAAI,CAAC,UAAU,iBAAiB,oBAAoB,CAClD,OAAM,IAAI,MAAM;GAElB,MAAM,gBAAgB,cAAc,qBAAqB;AACzD,UAAO,MAAM,cAAc,OAAO,oBAAoB;EACvD,SAAQ,KAAK;AACZ,SAAM,IAAI,MAAM,CAAC,cAAc,EAAE,IAAI,EAAE,EAAE,MAAM;EAChD;CACF;;;;;;CAOD,wBAAgC;AAC9B,SAAO;CACR;AACF"}