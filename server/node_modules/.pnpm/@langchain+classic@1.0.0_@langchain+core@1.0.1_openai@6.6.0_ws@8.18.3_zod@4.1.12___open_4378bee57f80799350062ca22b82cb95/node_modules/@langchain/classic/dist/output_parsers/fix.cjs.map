{"version":3,"file":"fix.cjs","names":["x: LLMChain | Runnable<OutputFixingParserRetryInput, T>","BaseOutputParser","llm: BaseLanguageModelInterface","parser: BaseOutputParser<T>","fields?: {\n      prompt?: BasePromptTemplate;\n    }","NAIVE_FIX_PROMPT","LLMChain","completion: string","callbacks?: Callbacks","OutputParserException","newCompletion: string"],"sources":["../../src/output_parsers/fix.ts"],"sourcesContent":["import type { BaseLanguageModelInterface } from \"@langchain/core/language_models/base\";\nimport { Callbacks } from \"@langchain/core/callbacks/manager\";\nimport {\n  BaseOutputParser,\n  OutputParserException,\n} from \"@langchain/core/output_parsers\";\nimport { BasePromptTemplate } from \"@langchain/core/prompts\";\nimport { Runnable } from \"@langchain/core/runnables\";\nimport { LLMChain } from \"../chains/llm_chain.js\";\nimport { NAIVE_FIX_PROMPT } from \"./prompts.js\";\n\ninterface OutputFixingParserRetryInput {\n  instructions: string;\n  completion: string;\n  error: OutputParserException;\n}\n\nfunction isLLMChain<T>(\n  x: LLMChain | Runnable<OutputFixingParserRetryInput, T>\n): x is LLMChain {\n  return (\n    (x as LLMChain).prompt !== undefined && (x as LLMChain).llm !== undefined\n  );\n}\n\n/**\n * Class that extends the BaseOutputParser to handle situations where the\n * initial parsing attempt fails. It contains a retryChain for retrying\n * the parsing process in case of a failure.\n */\nexport class OutputFixingParser<T> extends BaseOutputParser<T> {\n  static lc_name() {\n    return \"OutputFixingParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"fix\"];\n\n  lc_serializable = true;\n\n  parser: BaseOutputParser<T>;\n\n  retryChain: LLMChain | Runnable<OutputFixingParserRetryInput, T>;\n\n  /**\n   * Static method to create a new instance of OutputFixingParser using a\n   * given language model, parser, and optional fields.\n   * @param llm The language model to be used.\n   * @param parser The parser to be used.\n   * @param fields Optional fields which may contain a prompt.\n   * @returns A new instance of OutputFixingParser.\n   */\n  static fromLLM<T>(\n    llm: BaseLanguageModelInterface,\n    parser: BaseOutputParser<T>,\n    fields?: {\n      prompt?: BasePromptTemplate;\n    }\n  ) {\n    const prompt = fields?.prompt ?? NAIVE_FIX_PROMPT;\n    const chain = new LLMChain({ llm, prompt });\n    return new OutputFixingParser<T>({ parser, retryChain: chain });\n  }\n\n  constructor({\n    parser,\n    retryChain,\n  }: {\n    parser: BaseOutputParser<T>;\n    retryChain: LLMChain | Runnable<OutputFixingParserRetryInput, T>;\n  }) {\n    super(...arguments);\n    this.parser = parser;\n    this.retryChain = retryChain;\n  }\n\n  /**\n   * Method to parse the completion using the parser. If the initial parsing\n   * fails, it uses the retryChain to attempt to fix the output and retry\n   * the parsing process.\n   * @param completion The completion to be parsed.\n   * @param callbacks Optional callbacks to be used during parsing.\n   * @returns The parsed output.\n   */\n  async parse(completion: string, callbacks?: Callbacks) {\n    try {\n      return await this.parser.parse(completion, callbacks);\n    } catch (e) {\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      if (e instanceof OutputParserException) {\n        const retryInput = {\n          instructions: this.parser.getFormatInstructions(),\n          completion,\n          error: e,\n        };\n\n        if (isLLMChain(this.retryChain)) {\n          const result = await this.retryChain.call(retryInput, callbacks);\n          const newCompletion: string = result[this.retryChain.outputKey];\n          return this.parser.parse(newCompletion, callbacks);\n        } else {\n          const result = await this.retryChain.invoke(retryInput, {\n            callbacks,\n          });\n          return result;\n        }\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Method to get the format instructions for the parser.\n   * @returns The format instructions for the parser.\n   */\n  getFormatInstructions() {\n    return this.parser.getFormatInstructions();\n  }\n}\n"],"mappings":";;;;;;AAiBA,SAAS,WACPA,GACe;AACf,QACG,EAAe,WAAW,UAAc,EAAe,QAAQ;AAEnE;;;;;;AAOD,IAAa,qBAAb,MAAa,2BAA8BC,iDAAoB;CAC7D,OAAO,UAAU;AACf,SAAO;CACR;CAED,eAAe;EAAC;EAAa;EAAkB;CAAM;CAErD,kBAAkB;CAElB;CAEA;;;;;;;;;CAUA,OAAO,QACLC,KACAC,QACAC,QAGA;EACA,MAAM,SAAS,QAAQ,UAAUC;EACjC,MAAM,QAAQ,IAAIC,2BAAS;GAAE;GAAK;EAAQ;AAC1C,SAAO,IAAI,mBAAsB;GAAE;GAAQ,YAAY;EAAO;CAC/D;CAED,YAAY,EACV,QACA,YAID,EAAE;EACD,MAAM,GAAG,UAAU;EACnB,KAAK,SAAS;EACd,KAAK,aAAa;CACnB;;;;;;;;;CAUD,MAAM,MAAMC,YAAoBC,WAAuB;AACrD,MAAI;AACF,UAAO,MAAM,KAAK,OAAO,MAAM,YAAY,UAAU;EACtD,SAAQ,GAAG;AAEV,OAAI,aAAaC,uDAAuB;IACtC,MAAM,aAAa;KACjB,cAAc,KAAK,OAAO,uBAAuB;KACjD;KACA,OAAO;IACR;AAED,QAAI,WAAW,KAAK,WAAW,EAAE;KAC/B,MAAM,SAAS,MAAM,KAAK,WAAW,KAAK,YAAY,UAAU;KAChE,MAAMC,gBAAwB,OAAO,KAAK,WAAW;AACrD,YAAO,KAAK,OAAO,MAAM,eAAe,UAAU;IACnD,OAAM;KACL,MAAM,SAAS,MAAM,KAAK,WAAW,OAAO,YAAY,EACtD,UACD,EAAC;AACF,YAAO;IACR;GACF;AACD,SAAM;EACP;CACF;;;;;CAMD,wBAAwB;AACtB,SAAO,KAAK,OAAO,uBAAuB;CAC3C;AACF"}