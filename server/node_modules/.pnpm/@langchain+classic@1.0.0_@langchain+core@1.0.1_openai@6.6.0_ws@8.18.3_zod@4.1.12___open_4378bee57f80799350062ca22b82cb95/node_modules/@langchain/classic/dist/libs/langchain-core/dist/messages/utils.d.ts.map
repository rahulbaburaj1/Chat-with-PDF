{"version":3,"file":"utils.d.ts","names":["BaseMessage","BaseMessageLike","StoredMessage","ToolMessage","AIMessage","AIMessageChunk","ChatMessage","ChatMessageChunk","FunctionMessage","FunctionMessageChunk","HumanMessage","HumanMessageChunk","SystemMessage","SystemMessageChunk","MessageStructure","$Expand","T","U","K","$KnownKeys","$HasIndexSignature","$OnlyIndexSignatures","$MergeObjects","Record","$MergeDiscriminatedUnion","Key","PropertyKey","A","B","Extract","Constructor","iife","coerceMessageLikeToMessage","getBufferString","mapStoredMessageToChatMessage","mapStoredMessagesToChatMessages","mapChatMessagesToStoredMessages","convertToChunk"],"sources":["../../../../../../langchain-core/dist/messages/utils.d.ts"],"sourcesContent":["import { BaseMessage, BaseMessageLike, StoredMessage } from \"./base.js\";\nimport { ToolMessage } from \"./tool.js\";\nimport { AIMessage, AIMessageChunk } from \"./ai.js\";\nimport { ChatMessage, ChatMessageChunk } from \"./chat.js\";\nimport { FunctionMessage, FunctionMessageChunk } from \"./function.js\";\nimport { HumanMessage, HumanMessageChunk } from \"./human.js\";\nimport { SystemMessage, SystemMessageChunk } from \"./system.js\";\nimport { MessageStructure } from \"./message.js\";\n\n//#region src/messages/utils.d.ts\ntype $Expand<T> = T extends infer U ? { [K in keyof U]: U[K] } : never;\n/**\n * Extracts the explicitly declared keys from a type T.\n *\n * @template T - The type to extract keys from\n * @returns A union of keys that are not string, number, or symbol\n */\ntype $KnownKeys<T> = { [K in keyof T]: string extends K ? never : number extends K ? never : symbol extends K ? never : K }[keyof T];\n/**\n * Detects if T has an index signature.\n *\n * @template T - The type to check for index signatures\n * @returns True if T has an index signature, false otherwise\n */\ntype $HasIndexSignature<T> = string extends keyof T ? true : number extends keyof T ? true : symbol extends keyof T ? true : false;\n/**\n * Detects if T has an index signature and no known keys.\n *\n * @template T - The type to check for index signatures and no known keys\n * @returns True if T has an index signature and no known keys, false otherwise\n */\ntype $OnlyIndexSignatures<T> = $HasIndexSignature<T> extends true ? [$KnownKeys<T>] extends [never] ? true : false : false;\n/**\n * Recursively merges two object types T and U, with U taking precedence over T.\n *\n * This utility type performs a deep merge of two object types:\n * - For keys that exist in both T and U:\n *   - If both values are objects (Record<string, unknown>), recursively merge them\n *   - Otherwise, U's value takes precedence\n * - For keys that exist only in T, use T's value\n * - For keys that exist only in U, use U's value\n *\n * @template T - The first object type to merge\n * @template U - The second object type to merge (takes precedence over T)\n *\n * @example\n * ```ts\n * type ObjectA = {\n *   shared: { a: string; b: number };\n *   onlyInA: boolean;\n * };\n *\n * type ObjectB = {\n *   shared: { b: string; c: Date };\n *   onlyInB: symbol;\n * };\n *\n * type Merged = $MergeObjects<ObjectA, ObjectB>;\n * // Result: {\n * //   shared: { a: string; b: string; c: Date };\n * //   onlyInA: boolean;\n * //   onlyInB: symbol;\n * // }\n * ```\n */\ntype $MergeObjects<T, U> =\n// If U is purely index-signature based, prefer U as a whole\n$OnlyIndexSignatures<U> extends true ? U : $OnlyIndexSignatures<T> extends true ? U : { [K in keyof T | keyof U]: K extends keyof T ? K extends keyof U ? T[K] extends Record<string, unknown> ? U[K] extends Record<string, unknown> ? $MergeObjects<T[K], U[K]> : U[K] : U[K] : T[K] : K extends keyof U ? U[K] : never };\n/**\n * Merges two discriminated unions A and B based on a discriminator key (defaults to \"type\").\n * For each possible value of the discriminator across both unions:\n * - If B has a member with that discriminator value, use B's member\n * - Otherwise use A's member with that discriminator value\n * This effectively merges the unions while giving B's members precedence over A's members.\n *\n * @template A - First discriminated union type that extends Record<Key, PropertyKey>\n * @template B - Second discriminated union type that extends Record<Key, PropertyKey>\n * @template Key - The discriminator key property, defaults to \"type\"\n */\ntype $MergeDiscriminatedUnion<A extends Record<Key, PropertyKey>, B extends Record<Key, PropertyKey>, Key extends PropertyKey = \"type\"> = { [T in A[Key] | B[Key]]: [Extract<B, Record<Key, T>>] extends [never] // Check if B has a member with this discriminator value\n? Extract<A, Record<Key, T>> : [Extract<A, Record<Key, T>>] extends [never] ? Extract<B, Record<Key, T>> : $MergeObjects<Extract<A, Record<Key, T>>, Extract<B, Record<Key, T>>> }[A[Key] | B[Key]];\ntype Constructor<T> = new (...args: unknown[]) => T;\n/**\n * Immediately-invoked function expression.\n *\n * @param fn - The function to execute\n * @returns The result of the function\n */\ndeclare const iife: <T>(fn: () => T) => T;\ndeclare function coerceMessageLikeToMessage(messageLike: BaseMessageLike): BaseMessage;\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\ndeclare function getBufferString(messages: BaseMessage[], humanPrefix?: string, aiPrefix?: string): string;\ndeclare function mapStoredMessageToChatMessage(message: StoredMessage): AIMessage<MessageStructure> | ChatMessage<MessageStructure> | FunctionMessage<MessageStructure> | HumanMessage<MessageStructure> | SystemMessage<MessageStructure> | ToolMessage<MessageStructure>;\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\ndeclare function mapStoredMessagesToChatMessages(messages: StoredMessage[]): BaseMessage[];\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\ndeclare function mapChatMessagesToStoredMessages(messages: BaseMessage[]): StoredMessage[];\ndeclare function convertToChunk(message: BaseMessage): AIMessageChunk<MessageStructure> | ChatMessageChunk<MessageStructure> | FunctionMessageChunk<MessageStructure> | HumanMessageChunk<MessageStructure> | SystemMessageChunk<MessageStructure>;\n//#endregion\nexport { $Expand, $MergeDiscriminatedUnion, $MergeObjects, Constructor, coerceMessageLikeToMessage, convertToChunk, getBufferString, iife, mapChatMessagesToStoredMessages, mapStoredMessageToChatMessage, mapStoredMessagesToChatMessages };\n//# sourceMappingURL=utils.d.ts.map"],"mappings":"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"}