{"version":3,"file":"vectorstores.d.cts","names":["QdrantClient","Schemas","QdrantSchemas","EmbeddingsInterface","MaxMarginalRelevanceSearchOptions","VectorStore","Document","QdrantLibArgs","Record","QdrantAddDocumentOptions","QdrantDeleteParams","QdrantFilter","QdrantCondition","QdrantVectorStore","Promise"],"sources":["../src/vectorstores.d.ts"],"sourcesContent":["import { QdrantClient } from \"@qdrant/js-client-rest\";\nimport type { Schemas as QdrantSchemas } from \"@qdrant/js-client-rest\";\nimport type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { type MaxMarginalRelevanceSearchOptions, VectorStore } from \"@langchain/core/vectorstores\";\nimport { Document } from \"@langchain/core/documents\";\n/**\n * Interface for the arguments that can be passed to the\n * `QdrantVectorStore` constructor. It includes options for specifying a\n * `QdrantClient` instance, the URL and API key for a Qdrant database, and\n * the name and configuration for a collection.\n */\nexport interface QdrantLibArgs {\n    client?: QdrantClient;\n    url?: string;\n    apiKey?: string;\n    collectionName?: string;\n    collectionConfig?: QdrantSchemas[\"CreateCollection\"];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    customPayload?: Record<string, any>[];\n    contentPayloadKey?: string;\n    metadataPayloadKey?: string;\n}\nexport type QdrantAddDocumentOptions = {\n    ids?: string[];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    customPayload?: Record<string, any>[];\n};\n/**\n * Type that defines the parameters for the delete operation in the\n * QdrantStore class. It includes ids, filter and shard key.\n */\nexport type QdrantDeleteParams = {\n    ids: string[];\n    shardKey?: string;\n    filter?: never;\n} | {\n    filter: object;\n    shardKey?: string;\n    ids?: never;\n};\nexport type QdrantFilter = QdrantSchemas[\"Filter\"];\nexport type QdrantCondition = QdrantSchemas[\"FieldCondition\"];\n/**\n * Class that extends the `VectorStore` base class to interact with a\n * Qdrant database. It includes methods for adding documents and vectors\n * to the Qdrant database, searching for similar vectors, and ensuring the\n * existence of a collection in the database.\n */\nexport declare class QdrantVectorStore extends VectorStore {\n    FilterType: QdrantFilter;\n    get lc_secrets(): {\n        [key: string]: string;\n    };\n    client: QdrantClient;\n    collectionName: string;\n    collectionConfig?: QdrantSchemas[\"CreateCollection\"];\n    contentPayloadKey: string;\n    metadataPayloadKey: string;\n    _vectorstoreType(): string;\n    constructor(embeddings: EmbeddingsInterface, args: QdrantLibArgs);\n    /**\n     * Method to add documents to the Qdrant database. It generates vectors\n     * from the documents using the `Embeddings` instance and then adds the\n     * vectors to the database.\n     * @param documents Array of `Document` instances to be added to the Qdrant database.\n     * @param documentOptions Optional `QdrantAddDocumentOptions` which has a list of JSON objects for extra querying\n     * @returns Promise that resolves when the documents have been added to the database.\n     */\n    addDocuments(documents: Document[], documentOptions?: QdrantAddDocumentOptions): Promise<void>;\n    /**\n     * Method to add vectors to the Qdrant database. Each vector is associated\n     * with a document, which is stored as the payload for a point in the\n     * database.\n     * @param vectors Array of vectors to be added to the Qdrant database.\n     * @param documents Array of `Document` instances associated with the vectors.\n     * @param documentOptions Optional `QdrantAddDocumentOptions` which has a list of JSON objects for extra querying\n     * @returns Promise that resolves when the vectors have been added to the database.\n     */\n    addVectors(vectors: number[][], documents: Document[], documentOptions?: QdrantAddDocumentOptions): Promise<void>;\n    /**\n     * Method that deletes points from the Qdrant database.\n     * @param params Parameters for the delete operation.\n     * @returns Promise that resolves when the delete operation is complete.\n     */\n    delete(params: QdrantDeleteParams): Promise<void>;\n    /**\n     * Method to search for vectors in the Qdrant database that are similar to\n     * a given query vector. The search results include the score and payload\n     * (metadata and content) for each similar vector.\n     * @param query Query vector to search for similar vectors in the Qdrant database.\n     * @param k Optional number of similar vectors to return. If not specified, all similar vectors are returned.\n     * @param filter Optional filter to apply to the search results.\n     * @returns Promise that resolves with an array of tuples, where each tuple includes a `Document` instance and a score for a similar vector.\n     */\n    similaritySearchVectorWithScore(query: number[], k?: number, filter?: this[\"FilterType\"]): Promise<[Document, number][]>;\n    /**\n     * Return documents selected using the maximal marginal relevance.\n     * Maximal marginal relevance optimizes for similarity to the query AND diversity\n     * among selected documents.\n     *\n     * @param {string} query - Text to look up documents similar to.\n     * @param {number} options.k - Number of documents to return.\n     * @param {number} options.fetchK - Number of documents to fetch before passing to the MMR algorithm. Defaults to 20.\n     * @param {number} options.lambda - Number between 0 and 1 that determines the degree of diversity among the results,\n     *                 where 0 corresponds to maximum diversity and 1 to minimum diversity.\n     * @param {this[\"FilterType\"]} options.filter - Optional filter to apply to the search results.\n     *\n     * @returns {Promise<Document[]>} - List of documents selected by maximal marginal relevance.\n     */\n    maxMarginalRelevanceSearch(query: string, options: MaxMarginalRelevanceSearchOptions<this[\"FilterType\"]>): Promise<Document[]>;\n    /**\n     * Method to ensure the existence of a collection in the Qdrant database.\n     * If the collection does not exist, it is created.\n     * @returns Promise that resolves when the existence of the collection has been ensured.\n     */\n    ensureCollection(): Promise<void>;\n    /**\n     * Static method to create a `QdrantVectorStore` instance from texts. Each\n     * text is associated with metadata and converted to a `Document`\n     * instance, which is then added to the Qdrant database.\n     * @param texts Array of texts to be converted to `Document` instances and added to the Qdrant database.\n     * @param metadatas Array or single object of metadata to be associated with the texts.\n     * @param embeddings `Embeddings` instance used to generate vectors from the texts.\n     * @param dbConfig `QdrantLibArgs` instance specifying the configuration for the Qdrant database.\n     * @returns Promise that resolves with a new `QdrantVectorStore` instance.\n     */\n    static fromTexts(texts: string[], metadatas: object[] | object, embeddings: EmbeddingsInterface, dbConfig: QdrantLibArgs): Promise<QdrantVectorStore>;\n    /**\n     * Static method to create a `QdrantVectorStore` instance from `Document`\n     * instances. The documents are added to the Qdrant database.\n     * @param docs Array of `Document` instances to be added to the Qdrant database.\n     * @param embeddings `Embeddings` instance used to generate vectors from the documents.\n     * @param dbConfig `QdrantLibArgs` instance specifying the configuration for the Qdrant database.\n     * @returns Promise that resolves with a new `QdrantVectorStore` instance.\n     */\n    static fromDocuments(docs: Document[], embeddings: EmbeddingsInterface, dbConfig: QdrantLibArgs): Promise<QdrantVectorStore>;\n    /**\n     * Static method to create a `QdrantVectorStore` instance from an existing\n     * collection in the Qdrant database.\n     * @param embeddings `Embeddings` instance used to generate vectors from the documents in the collection.\n     * @param dbConfig `QdrantLibArgs` instance specifying the configuration for the Qdrant database.\n     * @returns Promise that resolves with a new `QdrantVectorStore` instance.\n     */\n    static fromExistingCollection(embeddings: EmbeddingsInterface, dbConfig: QdrantLibArgs): Promise<QdrantVectorStore>;\n}\n"],"mappings":";;;;;;;;AAWA;;;;;AAO0B,UAPTO,aAAAA,CAOS;EAIdE,MAAAA,CAAAA,EAVCT,YAUDS;EASAC,GAAAA,CAAAA,EAAAA,MAAAA;EASAC,MAAAA,CAAAA,EAAAA,MAAY;EACZC,cAAAA,CAAAA,EAAAA,MAAe;EAONC,gBAAAA,CAAAA,EAhCEX,OAgCe,CAAA,kBAAA,CAAA;EAAA;EAAA,aACtBS,CAAAA,EA/BIH,MA+BJG,CAAAA,MAAAA,EAAAA,GAAAA,CAAAA,EAAAA;EAAY,iBAIhBX,CAAAA,EAAAA,MAAAA;EAAY,kBAEDE,CAAAA,EAAAA,MAAAA;;AAIgCK,KArC3CE,wBAAAA,GAqC2CF;EAAa,GASxCD,CAAAA,EAAAA,MAAAA,EAAAA;EAAQ;EAA8C,aAAGQ,CAAAA,EA3CjEN,MA2CiEM,CAAAA,MAAAA,EAAAA,GAAAA,CAAAA,EAAAA;CAAO;;;;;AA0BYR,KA/D5FI,kBAAAA,GA+D4FJ;EAAQ,GAAjBQ,EAAAA,MAAAA,EAAAA;EAAO,QAe/CV,CAAAA,EAAAA,MAAAA;EAAiC,MAA+BE,CAAAA,EAAAA,KAAAA;CAAQ,GAAA;EAAT,MAM9FQ,EAAAA,MAAAA;EAAO,QAWiDX,CAAAA,EAAAA,MAAAA;EAAmB,GAAYI,CAAAA,EAAAA,KAAAA;CAAa;AAAGO,KAtFnHH,YAAAA,GAAeT,OAsFoGY,CAAAA,QAAAA,CAAAA;AAShGR,KA9FnBM,eAAAA,GAAkBV,OA8FCI,CAAAA,gBAAAA,CAAAA;;;;;;;AAQsEO,cA/FhFA,iBAAAA,SAA0BR,WAAAA,CA+FsDQ;EAAiB,UAAzBC,EA9F7EH,YA8F6EG;EAAO,IA/FrDT,UAAAA,CAAAA,CAAAA,EAAAA;IAAW,CAAA,GAAA,EAAA,MAAA,CAAA,EAAA,MAAA;;UAK9CL;;qBAEWE;;;;0BAIKC,2BAA2BI;;;;;;;;;0BAS3BD,8BAA8BG,2BAA2BK;;;;;;;;;;6CAUtCR,8BAA8BG,2BAA2BK;;;;;;iBAMrFJ,qBAAqBI;;;;;;;;;;6FAUuDA,SAASR;;;;;;;;;;;;;;;qDAejDF,wDAAwDU,QAAQR;;;;;;sBAM/FQ;;;;;;;;;;;8EAWwDX,+BAA+BI,gBAAgBO,QAAQD;;;;;;;;;6BASxGP,wBAAwBH,+BAA+BI,gBAAgBO,QAAQD;;;;;;;;4CAQhEV,+BAA+BI,gBAAgBO,QAAQD"}