{"version":3,"file":"vectorstores.cjs","names":["VectorStore","embeddings: EmbeddingsInterface","args: QdrantLibArgs","QdrantClient","documents: Document[]","documentOptions?: QdrantAddDocumentOptions","vectors: number[][]","e: any","params: QdrantDeleteParams","query: number[]","k?: number","filter?: this[\"FilterType\"]","result: [Document, number][]","Document","query: string","options: MaxMarginalRelevanceSearchOptions<this[\"FilterType\"]>","texts: string[]","metadatas: object[] | object","dbConfig: QdrantLibArgs","docs: Document[]"],"sources":["../src/vectorstores.ts"],"sourcesContent":["import { QdrantClient } from \"@qdrant/js-client-rest\";\nimport type { Schemas as QdrantSchemas } from \"@qdrant/js-client-rest\";\nimport { v4 as uuid } from \"uuid\";\nimport type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport {\n  type MaxMarginalRelevanceSearchOptions,\n  VectorStore,\n} from \"@langchain/core/vectorstores\";\nimport { Document } from \"@langchain/core/documents\";\nimport { getEnvironmentVariable } from \"@langchain/core/utils/env\";\n\nconst CONTENT_KEY = \"content\";\nconst METADATA_KEY = \"metadata\";\n\n/**\n * Interface for the arguments that can be passed to the\n * `QdrantVectorStore` constructor. It includes options for specifying a\n * `QdrantClient` instance, the URL and API key for a Qdrant database, and\n * the name and configuration for a collection.\n */\nexport interface QdrantLibArgs {\n  client?: QdrantClient;\n  url?: string;\n  apiKey?: string;\n  collectionName?: string;\n  collectionConfig?: QdrantSchemas[\"CreateCollection\"];\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  customPayload?: Record<string, any>[];\n  contentPayloadKey?: string;\n  metadataPayloadKey?: string;\n}\n\nexport type QdrantAddDocumentOptions = {\n  ids?: string[];\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  customPayload?: Record<string, any>[];\n};\n\n/**\n * Type that defines the parameters for the delete operation in the\n * QdrantStore class. It includes ids, filter and shard key.\n */\nexport type QdrantDeleteParams =\n  | { ids: string[]; shardKey?: string; filter?: never }\n  | { filter: object; shardKey?: string; ids?: never };\n\nexport type QdrantFilter = QdrantSchemas[\"Filter\"];\n\nexport type QdrantCondition = QdrantSchemas[\"FieldCondition\"];\n\n/**\n * Type for the response returned by a search operation in the Qdrant\n * database. It includes the score and payload (metadata and content) for\n * each point (document) in the search results.\n */\ntype QdrantSearchResponse = QdrantSchemas[\"ScoredPoint\"] & {\n  payload: {\n    metadata: object;\n    content: string;\n  };\n};\n\n/**\n * Class that extends the `VectorStore` base class to interact with a\n * Qdrant database. It includes methods for adding documents and vectors\n * to the Qdrant database, searching for similar vectors, and ensuring the\n * existence of a collection in the database.\n */\nexport class QdrantVectorStore extends VectorStore {\n  declare FilterType: QdrantFilter;\n\n  get lc_secrets(): { [key: string]: string } {\n    return {\n      apiKey: \"QDRANT_API_KEY\",\n      url: \"QDRANT_URL\",\n    };\n  }\n\n  client: QdrantClient;\n\n  collectionName: string;\n\n  collectionConfig?: QdrantSchemas[\"CreateCollection\"];\n\n  contentPayloadKey: string;\n\n  metadataPayloadKey: string;\n\n  _vectorstoreType(): string {\n    return \"qdrant\";\n  }\n\n  constructor(embeddings: EmbeddingsInterface, args: QdrantLibArgs) {\n    super(embeddings, args);\n\n    const url = args.url ?? getEnvironmentVariable(\"QDRANT_URL\");\n    const apiKey = args.apiKey ?? getEnvironmentVariable(\"QDRANT_API_KEY\");\n\n    if (!args.client && !url) {\n      throw new Error(\"Qdrant client or url address must be set.\");\n    }\n\n    this.client =\n      args.client ||\n      new QdrantClient({\n        url,\n        apiKey,\n      });\n\n    this.collectionName = args.collectionName ?? \"documents\";\n\n    this.collectionConfig = args.collectionConfig;\n\n    this.contentPayloadKey = args.contentPayloadKey ?? CONTENT_KEY;\n\n    this.metadataPayloadKey = args.metadataPayloadKey ?? METADATA_KEY;\n  }\n\n  /**\n   * Method to add documents to the Qdrant database. It generates vectors\n   * from the documents using the `Embeddings` instance and then adds the\n   * vectors to the database.\n   * @param documents Array of `Document` instances to be added to the Qdrant database.\n   * @param documentOptions Optional `QdrantAddDocumentOptions` which has a list of JSON objects for extra querying\n   * @returns Promise that resolves when the documents have been added to the database.\n   */\n  async addDocuments(\n    documents: Document[],\n    documentOptions?: QdrantAddDocumentOptions\n  ): Promise<void> {\n    const texts = documents.map(({ pageContent }) => pageContent);\n    await this.addVectors(\n      await this.embeddings.embedDocuments(texts),\n      documents,\n      documentOptions\n    );\n  }\n\n  /**\n   * Method to add vectors to the Qdrant database. Each vector is associated\n   * with a document, which is stored as the payload for a point in the\n   * database.\n   * @param vectors Array of vectors to be added to the Qdrant database.\n   * @param documents Array of `Document` instances associated with the vectors.\n   * @param documentOptions Optional `QdrantAddDocumentOptions` which has a list of JSON objects for extra querying\n   * @returns Promise that resolves when the vectors have been added to the database.\n   */\n  async addVectors(\n    vectors: number[][],\n    documents: Document[],\n    documentOptions?: QdrantAddDocumentOptions\n  ): Promise<void> {\n    if (vectors.length === 0) {\n      return;\n    }\n\n    await this.ensureCollection();\n\n    const points = vectors.map((embedding, idx) => ({\n      id: documents[idx].id ?? documentOptions?.ids?.[idx] ?? uuid(),\n      vector: embedding,\n      payload: {\n        [this.contentPayloadKey]: documents[idx].pageContent,\n        [this.metadataPayloadKey]: documents[idx].metadata,\n        customPayload: documentOptions?.customPayload?.[idx],\n      },\n    }));\n\n    try {\n      await this.client.upsert(this.collectionName, {\n        wait: true,\n        points,\n      });\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      const error = new Error(\n        `${e?.status ?? \"Undefined error code\"} ${e?.message}: ${\n          e?.data?.status?.error\n        }`\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Method that deletes points from the Qdrant database.\n   * @param params Parameters for the delete operation.\n   * @returns Promise that resolves when the delete operation is complete.\n   */\n  async delete(params: QdrantDeleteParams): Promise<void> {\n    const { ids, filter, shardKey } = params;\n\n    if (ids) {\n      const batchSize = 1000;\n      for (let i = 0; i < ids.length; i += batchSize) {\n        const batchIds = ids.slice(i, i + batchSize);\n        await this.client.delete(this.collectionName, {\n          wait: true,\n          ordering: \"weak\",\n          points: batchIds,\n          shard_key: shardKey,\n        });\n      }\n    } else if (filter) {\n      await this.client.delete(this.collectionName, {\n        wait: true,\n        ordering: \"weak\",\n        filter,\n        shard_key: shardKey,\n      });\n    } else {\n      throw new Error(\"Either ids or filter must be provided.\");\n    }\n  }\n\n  /**\n   * Method to search for vectors in the Qdrant database that are similar to\n   * a given query vector. The search results include the score and payload\n   * (metadata and content) for each similar vector.\n   * @param query Query vector to search for similar vectors in the Qdrant database.\n   * @param k Optional number of similar vectors to return. If not specified, all similar vectors are returned.\n   * @param filter Optional filter to apply to the search results.\n   * @returns Promise that resolves with an array of tuples, where each tuple includes a `Document` instance and a score for a similar vector.\n   */\n  async similaritySearchVectorWithScore(\n    query: number[],\n    k?: number,\n    filter?: this[\"FilterType\"]\n  ): Promise<[Document, number][]> {\n    if (!query) {\n      return [];\n    }\n\n    await this.ensureCollection();\n\n    const results = (\n      await this.client.query(this.collectionName, {\n        query,\n        limit: k,\n        filter,\n        with_payload: [this.metadataPayloadKey, this.contentPayloadKey],\n        with_vector: false,\n      })\n    ).points;\n\n    const result: [Document, number][] = (\n      results as QdrantSearchResponse[]\n    ).map((res) => [\n      new Document({\n        id: res.id as string,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        metadata: res.payload[this.metadataPayloadKey] as Record<string, any>,\n        pageContent: res.payload[this.contentPayloadKey] as string,\n      }),\n      res.score,\n    ]);\n\n    return result;\n  }\n\n  /**\n   * Return documents selected using the maximal marginal relevance.\n   * Maximal marginal relevance optimizes for similarity to the query AND diversity\n   * among selected documents.\n   *\n   * @param {string} query - Text to look up documents similar to.\n   * @param {number} options.k - Number of documents to return.\n   * @param {number} options.fetchK - Number of documents to fetch before passing to the MMR algorithm. Defaults to 20.\n   * @param {number} options.lambda - Number between 0 and 1 that determines the degree of diversity among the results,\n   *                 where 0 corresponds to maximum diversity and 1 to minimum diversity.\n   * @param {this[\"FilterType\"]} options.filter - Optional filter to apply to the search results.\n   *\n   * @returns {Promise<Document[]>} - List of documents selected by maximal marginal relevance.\n   */\n  async maxMarginalRelevanceSearch(\n    query: string,\n    options: MaxMarginalRelevanceSearchOptions<this[\"FilterType\"]>\n  ): Promise<Document[]> {\n    if (!query) {\n      return [];\n    }\n\n    const queryEmbedding = await this.embeddings.embedQuery(query);\n\n    await this.ensureCollection();\n\n    const results = (\n      await this.client.query(this.collectionName, {\n        query: {\n          nearest: queryEmbedding,\n          mmr: {\n            diversity: options.lambda ?? null,\n            candidates_limit: options?.fetchK ?? 20,\n          },\n        },\n        limit: options.k,\n        filter: options?.filter,\n        with_payload: [this.metadataPayloadKey, this.contentPayloadKey],\n        with_vector: true,\n      })\n    ).points;\n\n    const result = (results as QdrantSearchResponse[]).map(\n      (res) =>\n        new Document({\n          id: res.id as string,\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          metadata: res.payload[this.metadataPayloadKey] as Record<string, any>,\n          pageContent: res.payload[this.contentPayloadKey] as string,\n        })\n    );\n\n    return result;\n  }\n\n  /**\n   * Method to ensure the existence of a collection in the Qdrant database.\n   * If the collection does not exist, it is created.\n   * @returns Promise that resolves when the existence of the collection has been ensured.\n   */\n  async ensureCollection() {\n    const response = await this.client.getCollections();\n\n    const collectionNames = response.collections.map(\n      (collection) => collection.name\n    );\n\n    if (!collectionNames.includes(this.collectionName)) {\n      const collectionConfig = this.collectionConfig ?? {\n        vectors: {\n          size: (await this.embeddings.embedQuery(\"test\")).length,\n          distance: \"Cosine\",\n        },\n      };\n      await this.client.createCollection(this.collectionName, collectionConfig);\n    }\n  }\n\n  /**\n   * Static method to create a `QdrantVectorStore` instance from texts. Each\n   * text is associated with metadata and converted to a `Document`\n   * instance, which is then added to the Qdrant database.\n   * @param texts Array of texts to be converted to `Document` instances and added to the Qdrant database.\n   * @param metadatas Array or single object of metadata to be associated with the texts.\n   * @param embeddings `Embeddings` instance used to generate vectors from the texts.\n   * @param dbConfig `QdrantLibArgs` instance specifying the configuration for the Qdrant database.\n   * @returns Promise that resolves with a new `QdrantVectorStore` instance.\n   */\n  static async fromTexts(\n    texts: string[],\n    metadatas: object[] | object,\n    embeddings: EmbeddingsInterface,\n    dbConfig: QdrantLibArgs\n  ): Promise<QdrantVectorStore> {\n    const docs = [];\n    for (let i = 0; i < texts.length; i += 1) {\n      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;\n      const newDoc = new Document({\n        pageContent: texts[i],\n        metadata,\n      });\n      docs.push(newDoc);\n    }\n    return QdrantVectorStore.fromDocuments(docs, embeddings, dbConfig);\n  }\n\n  /**\n   * Static method to create a `QdrantVectorStore` instance from `Document`\n   * instances. The documents are added to the Qdrant database.\n   * @param docs Array of `Document` instances to be added to the Qdrant database.\n   * @param embeddings `Embeddings` instance used to generate vectors from the documents.\n   * @param dbConfig `QdrantLibArgs` instance specifying the configuration for the Qdrant database.\n   * @returns Promise that resolves with a new `QdrantVectorStore` instance.\n   */\n  static async fromDocuments(\n    docs: Document[],\n    embeddings: EmbeddingsInterface,\n    dbConfig: QdrantLibArgs\n  ): Promise<QdrantVectorStore> {\n    const instance = new this(embeddings, dbConfig);\n    if (dbConfig.customPayload) {\n      const documentOptions = {\n        customPayload: dbConfig?.customPayload,\n      };\n      await instance.addDocuments(docs, documentOptions);\n    } else {\n      await instance.addDocuments(docs);\n    }\n    return instance;\n  }\n\n  /**\n   * Static method to create a `QdrantVectorStore` instance from an existing\n   * collection in the Qdrant database.\n   * @param embeddings `Embeddings` instance used to generate vectors from the documents in the collection.\n   * @param dbConfig `QdrantLibArgs` instance specifying the configuration for the Qdrant database.\n   * @returns Promise that resolves with a new `QdrantVectorStore` instance.\n   */\n  static async fromExistingCollection(\n    embeddings: EmbeddingsInterface,\n    dbConfig: QdrantLibArgs\n  ): Promise<QdrantVectorStore> {\n    const instance = new this(embeddings, dbConfig);\n    await instance.ensureCollection();\n    return instance;\n  }\n}\n"],"mappings":";;;;;;;;AAWA,MAAM,cAAc;AACpB,MAAM,eAAe;;;;;;;AAwDrB,IAAa,oBAAb,MAAa,0BAA0BA,0CAAY;CAGjD,IAAI,aAAwC;AAC1C,SAAO;GACL,QAAQ;GACR,KAAK;EACN;CACF;CAED;CAEA;CAEA;CAEA;CAEA;CAEA,mBAA2B;AACzB,SAAO;CACR;CAED,YAAYC,YAAiCC,MAAqB;EAChE,MAAM,YAAY,KAAK;EAEvB,MAAM,MAAM,KAAK,8DAA8B,aAAa;EAC5D,MAAM,SAAS,KAAK,iEAAiC,iBAAiB;AAEtE,MAAI,CAAC,KAAK,UAAU,CAAC,IACnB,OAAM,IAAI,MAAM;EAGlB,KAAK,SACH,KAAK,UACL,IAAIC,qCAAa;GACf;GACA;EACD;EAEH,KAAK,iBAAiB,KAAK,kBAAkB;EAE7C,KAAK,mBAAmB,KAAK;EAE7B,KAAK,oBAAoB,KAAK,qBAAqB;EAEnD,KAAK,qBAAqB,KAAK,sBAAsB;CACtD;;;;;;;;;CAUD,MAAM,aACJC,WACAC,iBACe;EACf,MAAM,QAAQ,UAAU,IAAI,CAAC,EAAE,aAAa,KAAK,YAAY;EAC7D,MAAM,KAAK,WACT,MAAM,KAAK,WAAW,eAAe,MAAM,EAC3C,WACA,gBACD;CACF;;;;;;;;;;CAWD,MAAM,WACJC,SACAF,WACAC,iBACe;AACf,MAAI,QAAQ,WAAW,EACrB;EAGF,MAAM,KAAK,kBAAkB;EAE7B,MAAM,SAAS,QAAQ,IAAI,CAAC,WAAW,SAAS;GAC9C,IAAI,UAAU,KAAK,MAAM,iBAAiB,MAAM,sBAAc;GAC9D,QAAQ;GACR,SAAS;KACN,KAAK,oBAAoB,UAAU,KAAK;KACxC,KAAK,qBAAqB,UAAU,KAAK;IAC1C,eAAe,iBAAiB,gBAAgB;GACjD;EACF,GAAE;AAEH,MAAI;GACF,MAAM,KAAK,OAAO,OAAO,KAAK,gBAAgB;IAC5C,MAAM;IACN;GACD,EAAC;EAEH,SAAQE,GAAQ;GACf,MAAM,wBAAQ,IAAI,MAChB,GAAG,GAAG,UAAU,uBAAuB,CAAC,EAAE,GAAG,QAAQ,EAAE,EACrD,GAAG,MAAM,QAAQ,OACjB;AAEJ,SAAM;EACP;CACF;;;;;;CAOD,MAAM,OAAOC,QAA2C;EACtD,MAAM,EAAE,KAAK,QAAQ,UAAU,GAAG;AAElC,MAAI,KAAK;GACP,MAAM,YAAY;AAClB,QAAK,IAAI,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK,WAAW;IAC9C,MAAM,WAAW,IAAI,MAAM,GAAG,IAAI,UAAU;IAC5C,MAAM,KAAK,OAAO,OAAO,KAAK,gBAAgB;KAC5C,MAAM;KACN,UAAU;KACV,QAAQ;KACR,WAAW;IACZ,EAAC;GACH;EACF,WAAU,QACT,MAAM,KAAK,OAAO,OAAO,KAAK,gBAAgB;GAC5C,MAAM;GACN,UAAU;GACV;GACA,WAAW;EACZ,EAAC;MAEF,OAAM,IAAI,MAAM;CAEnB;;;;;;;;;;CAWD,MAAM,gCACJC,OACAC,GACAC,QAC+B;AAC/B,MAAI,CAAC,MACH,QAAO,CAAE;EAGX,MAAM,KAAK,kBAAkB;EAE7B,MAAM,WACJ,MAAM,KAAK,OAAO,MAAM,KAAK,gBAAgB;GAC3C;GACA,OAAO;GACP;GACA,cAAc,CAAC,KAAK,oBAAoB,KAAK,iBAAkB;GAC/D,aAAa;EACd,EAAC,EACF;EAEF,MAAMC,SACJ,QACA,IAAI,CAAC,QAAQ,CACb,IAAIC,oCAAS;GACX,IAAI,IAAI;GAER,UAAU,IAAI,QAAQ,KAAK;GAC3B,aAAa,IAAI,QAAQ,KAAK;EAC/B,IACD,IAAI,KACL,EAAC;AAEF,SAAO;CACR;;;;;;;;;;;;;;;CAgBD,MAAM,2BACJC,OACAC,SACqB;AACrB,MAAI,CAAC,MACH,QAAO,CAAE;EAGX,MAAM,iBAAiB,MAAM,KAAK,WAAW,WAAW,MAAM;EAE9D,MAAM,KAAK,kBAAkB;EAE7B,MAAM,WACJ,MAAM,KAAK,OAAO,MAAM,KAAK,gBAAgB;GAC3C,OAAO;IACL,SAAS;IACT,KAAK;KACH,WAAW,QAAQ,UAAU;KAC7B,kBAAkB,SAAS,UAAU;IACtC;GACF;GACD,OAAO,QAAQ;GACf,QAAQ,SAAS;GACjB,cAAc,CAAC,KAAK,oBAAoB,KAAK,iBAAkB;GAC/D,aAAa;EACd,EAAC,EACF;EAEF,MAAM,SAAU,QAAmC,IACjD,CAAC,QACC,IAAIF,oCAAS;GACX,IAAI,IAAI;GAER,UAAU,IAAI,QAAQ,KAAK;GAC3B,aAAa,IAAI,QAAQ,KAAK;EAC/B,GACJ;AAED,SAAO;CACR;;;;;;CAOD,MAAM,mBAAmB;EACvB,MAAM,WAAW,MAAM,KAAK,OAAO,gBAAgB;EAEnD,MAAM,kBAAkB,SAAS,YAAY,IAC3C,CAAC,eAAe,WAAW,KAC5B;AAED,MAAI,CAAC,gBAAgB,SAAS,KAAK,eAAe,EAAE;GAClD,MAAM,mBAAmB,KAAK,oBAAoB,EAChD,SAAS;IACP,OAAO,MAAM,KAAK,WAAW,WAAW,OAAO,EAAE;IACjD,UAAU;GACX,EACF;GACD,MAAM,KAAK,OAAO,iBAAiB,KAAK,gBAAgB,iBAAiB;EAC1E;CACF;;;;;;;;;;;CAYD,aAAa,UACXG,OACAC,WACAhB,YACAiB,UAC4B;EAC5B,MAAM,OAAO,CAAE;AACf,OAAK,IAAI,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,GAAG;GACxC,MAAM,WAAW,MAAM,QAAQ,UAAU,GAAG,UAAU,KAAK;GAC3D,MAAM,SAAS,IAAIL,oCAAS;IAC1B,aAAa,MAAM;IACnB;GACD;GACD,KAAK,KAAK,OAAO;EAClB;AACD,SAAO,kBAAkB,cAAc,MAAM,YAAY,SAAS;CACnE;;;;;;;;;CAUD,aAAa,cACXM,MACAlB,YACAiB,UAC4B;EAC5B,MAAM,WAAW,IAAI,KAAK,YAAY;AACtC,MAAI,SAAS,eAAe;GAC1B,MAAM,kBAAkB,EACtB,eAAe,UAAU,cAC1B;GACD,MAAM,SAAS,aAAa,MAAM,gBAAgB;EACnD,OACC,MAAM,SAAS,aAAa,KAAK;AAEnC,SAAO;CACR;;;;;;;;CASD,aAAa,uBACXjB,YACAiB,UAC4B;EAC5B,MAAM,WAAW,IAAI,KAAK,YAAY;EACtC,MAAM,SAAS,kBAAkB;AACjC,SAAO;CACR;AACF"}