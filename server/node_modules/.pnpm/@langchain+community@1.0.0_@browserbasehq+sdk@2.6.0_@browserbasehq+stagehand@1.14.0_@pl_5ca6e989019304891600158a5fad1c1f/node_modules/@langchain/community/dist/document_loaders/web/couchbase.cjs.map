{"version":3,"file":"couchbase.cjs","names":["BaseDocumentLoader","client: Cluster","query: string","pageContentFields?: string[]","metadataFields?: string[]","documents: Document[]","result: QueryResult","Document"],"sources":["../../../src/document_loaders/web/couchbase.ts"],"sourcesContent":["/* eslint-disable import/no-extraneous-dependencies */\nimport { Cluster, QueryResult } from \"couchbase\";\nimport { Document } from \"@langchain/core/documents\";\nimport {\n  BaseDocumentLoader,\n  DocumentLoader,\n} from \"@langchain/core/document_loaders/base\";\n\n/**\n * loader for couchbase document\n */\nexport class CouchbaseDocumentLoader\n  extends BaseDocumentLoader\n  implements DocumentLoader\n{\n  private cluster: Cluster;\n\n  private query: string;\n\n  private pageContentFields?: string[];\n\n  private metadataFields?: string[];\n\n  /**\n   * construct Couchbase document loader with a requirement for couchbase cluster client\n   * @param client { Cluster } [ couchbase connected client to connect to database ]\n   * @param query { string } [ query to get results from while loading the data ]\n   * @param pageContentFields { Array<string> } [ filters fields of the document and shows these only ]\n   * @param metadataFields { Array<string> } [ metadata fields required ]\n   */\n  constructor(\n    client: Cluster,\n    query: string,\n    pageContentFields?: string[],\n    metadataFields?: string[]\n  ) {\n    super();\n    if (!client) {\n      throw new Error(\"Couchbase client cluster must be provided.\");\n    }\n    this.cluster = client;\n    this.query = query;\n    this.pageContentFields = pageContentFields;\n    this.metadataFields = metadataFields;\n  }\n\n  /**\n   * Function to load document based on query from couchbase\n   * @returns {Promise<Document[]>} [ Returns a promise of all the documents as array ]\n   */\n  async load(): Promise<Document[]> {\n    const documents: Document[] = [];\n    for await (const doc of this.lazyLoad()) {\n      documents.push(doc);\n    }\n    return documents;\n  }\n\n  /**\n   * Function to load documents based on iterator rather than full load\n   * @returns {AsyncIterable<Document>} [ Returns an iterator to fetch documents ]\n   */\n  async *lazyLoad(): AsyncIterable<Document> {\n    // Run SQL++ Query\n    const result: QueryResult = await this.cluster.query(this.query);\n    for await (const row of result.rows) {\n      let { metadataFields, pageContentFields } = this;\n\n      if (!pageContentFields) {\n        pageContentFields = Object.keys(row);\n      }\n\n      if (!metadataFields) {\n        metadataFields = [];\n      }\n\n      const metadata = metadataFields.reduce(\n        (obj, field) => ({ ...obj, [field]: row[field] }),\n        {}\n      );\n\n      const document = pageContentFields\n        .map((k) => `${k}: ${JSON.stringify(row[k])}`)\n        .join(\"\\n\");\n\n      yield new Document({\n        pageContent: document,\n        metadata,\n      });\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;AAWA,IAAa,0BAAb,cACUA,0DAEV;CACE,AAAQ;CAER,AAAQ;CAER,AAAQ;CAER,AAAQ;;;;;;;;CASR,YACEC,QACAC,OACAC,mBACAC,gBACA;EACA,OAAO;AACP,MAAI,CAAC,OACH,OAAM,IAAI,MAAM;EAElB,KAAK,UAAU;EACf,KAAK,QAAQ;EACb,KAAK,oBAAoB;EACzB,KAAK,iBAAiB;CACvB;;;;;CAMD,MAAM,OAA4B;EAChC,MAAMC,YAAwB,CAAE;AAChC,aAAW,MAAM,OAAO,KAAK,UAAU,EACrC,UAAU,KAAK,IAAI;AAErB,SAAO;CACR;;;;;CAMD,OAAO,WAAoC;EAEzC,MAAMC,SAAsB,MAAM,KAAK,QAAQ,MAAM,KAAK,MAAM;AAChE,aAAW,MAAM,OAAO,OAAO,MAAM;GACnC,IAAI,EAAE,gBAAgB,mBAAmB,GAAG;AAE5C,OAAI,CAAC,mBACH,oBAAoB,OAAO,KAAK,IAAI;AAGtC,OAAI,CAAC,gBACH,iBAAiB,CAAE;GAGrB,MAAM,WAAW,eAAe,OAC9B,CAAC,KAAK,WAAW;IAAE,GAAG;KAAM,QAAQ,IAAI;GAAQ,IAChD,CAAE,EACH;GAED,MAAM,WAAW,kBACd,IAAI,CAAC,MAAM,GAAG,EAAE,EAAE,EAAE,KAAK,UAAU,IAAI,GAAG,EAAE,CAAC,CAC7C,KAAK,KAAK;GAEb,MAAM,IAAIC,oCAAS;IACjB,aAAa;IACb;GACD;EACF;CACF;AACF"}