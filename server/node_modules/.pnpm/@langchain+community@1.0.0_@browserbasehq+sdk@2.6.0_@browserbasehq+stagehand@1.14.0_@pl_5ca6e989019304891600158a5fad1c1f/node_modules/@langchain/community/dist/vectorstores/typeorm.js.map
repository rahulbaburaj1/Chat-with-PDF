{"version":3,"file":"typeorm.js","names":["embeddings: EmbeddingsInterface","fields: TypeORMVectorStoreArgs","documents: Document[]","vectors: number[][]","query: number[]","k: number","filter?: this[\"FilterType\"]","texts: string[]","metadatas: object[] | object","dbConfig: TypeORMVectorStoreArgs","docs: Document[]"],"sources":["../../src/vectorstores/typeorm.ts"],"sourcesContent":["import { Metadata } from \"@opensearch-project/opensearch/api/types.js\";\nimport { DataSource, DataSourceOptions, EntitySchema } from \"typeorm\";\nimport type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { VectorStore } from \"@langchain/core/vectorstores\";\nimport { Document } from \"@langchain/core/documents\";\nimport { getEnvironmentVariable } from \"@langchain/core/utils/env\";\n\n/**\n * Interface that defines the arguments required to create a\n * `TypeORMVectorStore` instance. It includes Postgres connection options,\n * table name, filter, and verbosity level.\n */\nexport interface TypeORMVectorStoreArgs {\n  postgresConnectionOptions: DataSourceOptions;\n  tableName?: string;\n  schemaName?: string;\n  filter?: Metadata;\n  verbose?: boolean;\n}\n\n/**\n * Class that extends the `Document` base class and adds an `embedding`\n * property. It represents a document in the vector store.\n */\nexport class TypeORMVectorStoreDocument extends Document {\n  embedding: string;\n}\n\nconst defaultDocumentTableName = \"documents\";\n\n/**\n * Class that provides an interface to a Postgres vector database. It\n * extends the `VectorStore` base class and implements methods for adding\n * documents and vectors, performing similarity searches, and ensuring the\n * existence of a table in the database.\n */\nexport class TypeORMVectorStore extends VectorStore {\n  declare FilterType: Metadata;\n\n  tableName: string;\n\n  schemaName?: string;\n\n  documentEntity: EntitySchema;\n\n  filter?: Metadata;\n\n  appDataSource: DataSource;\n\n  _verbose?: boolean;\n\n  _vectorstoreType(): string {\n    return \"typeorm\";\n  }\n\n  private constructor(\n    embeddings: EmbeddingsInterface,\n    fields: TypeORMVectorStoreArgs\n  ) {\n    super(embeddings, fields);\n    this.tableName = fields.tableName || defaultDocumentTableName;\n    this.schemaName = fields.schemaName;\n    this.filter = fields.filter;\n\n    const TypeORMDocumentEntity = new EntitySchema<TypeORMVectorStoreDocument>({\n      name: fields.tableName ?? defaultDocumentTableName,\n      columns: {\n        id: {\n          generated: \"uuid\",\n          type: \"uuid\",\n          primary: true,\n        },\n        pageContent: {\n          type: String,\n        },\n        metadata: {\n          type: \"jsonb\",\n        },\n        embedding: {\n          type: String,\n        },\n      },\n    });\n    const appDataSource = new DataSource({\n      entities: [TypeORMDocumentEntity],\n      ...fields.postgresConnectionOptions,\n    });\n    this.appDataSource = appDataSource;\n    this.documentEntity = TypeORMDocumentEntity;\n\n    this._verbose =\n      fields.verbose ?? getEnvironmentVariable(\"LANGCHAIN_VERBOSE\") === \"true\";\n  }\n\n  /**\n   * Static method to create a new `TypeORMVectorStore` instance from a\n   * `DataSource`. It initializes the `DataSource` if it is not already\n   * initialized.\n   * @param embeddings Embeddings instance.\n   * @param fields `TypeORMVectorStoreArgs` instance.\n   * @returns A new instance of `TypeORMVectorStore`.\n   */\n  static async fromDataSource(\n    embeddings: EmbeddingsInterface,\n    fields: TypeORMVectorStoreArgs\n  ): Promise<TypeORMVectorStore> {\n    const postgresqlVectorStore = new TypeORMVectorStore(embeddings, fields);\n\n    if (!postgresqlVectorStore.appDataSource.isInitialized) {\n      await postgresqlVectorStore.appDataSource.initialize();\n    }\n\n    return postgresqlVectorStore;\n  }\n\n  /**\n   * Method to add documents to the vector store. It ensures the existence\n   * of the table in the database, converts the documents into vectors, and\n   * adds them to the store.\n   * @param documents Array of `Document` instances.\n   * @returns Promise that resolves when the documents have been added.\n   */\n  async addDocuments(documents: Document[]): Promise<void> {\n    const texts = documents.map(({ pageContent }) => pageContent);\n    // This will create the table if it does not exist. We can call it every time as it doesn't\n    // do anything if the table already exists, and it is not expensive in terms of performance\n    await this.ensureTableInDatabase();\n    return this.addVectors(\n      await this.embeddings.embedDocuments(texts),\n      documents\n    );\n  }\n\n  /**\n   * Method to add vectors to the vector store. It converts the vectors into\n   * rows and inserts them into the database.\n   * @param vectors Array of vectors.\n   * @param documents Array of `Document` instances.\n   * @returns Promise that resolves when the vectors have been added.\n   */\n  async addVectors(vectors: number[][], documents: Document[]): Promise<void> {\n    const rows = vectors.map((embedding, idx) => {\n      const embeddingString = `[${embedding.join(\",\")}]`;\n      const documentRow = {\n        pageContent: documents[idx].pageContent,\n        embedding: embeddingString,\n        metadata: documents[idx].metadata,\n      };\n\n      return documentRow;\n    });\n\n    const documentRepository = this.appDataSource.getRepository(\n      this.documentEntity\n    );\n\n    const chunkSize = 500;\n    for (let i = 0; i < rows.length; i += chunkSize) {\n      const chunk = rows.slice(i, i + chunkSize);\n\n      try {\n        await documentRepository.save(chunk);\n      } catch (e) {\n        console.error(e);\n        throw new Error(`Error inserting: ${chunk[0].pageContent}`);\n      }\n    }\n  }\n\n  /**\n   * Method to perform a similarity search in the vector store. It returns\n   * the `k` most similar documents to the query vector, along with their\n   * similarity scores.\n   * @param query Query vector.\n   * @param k Number of most similar documents to return.\n   * @param filter Optional filter to apply to the search.\n   * @returns Promise that resolves with an array of tuples, each containing a `TypeORMVectorStoreDocument` and its similarity score.\n   */\n  async similaritySearchVectorWithScore(\n    query: number[],\n    k: number,\n    filter?: this[\"FilterType\"]\n  ): Promise<[TypeORMVectorStoreDocument, number][]> {\n    const embeddingString = `[${query.join(\",\")}]`;\n    const _filter = filter ?? \"{}\";\n\n    const queryString = `\n      SELECT *, embedding <=> $1 as \"_distance\"\n      FROM ${this.tableName}\n      WHERE metadata @> $2\n      ORDER BY \"_distance\" ASC\n      LIMIT $3;`;\n\n    const documents = await this.appDataSource.query(queryString, [\n      embeddingString,\n      _filter,\n      k,\n    ]);\n\n    const results = [] as [TypeORMVectorStoreDocument, number][];\n    for (const doc of documents) {\n      if (doc._distance != null && doc.pageContent != null) {\n        const document = new Document(doc) as TypeORMVectorStoreDocument;\n        document.id = doc.id;\n        results.push([document, doc._distance]);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Method to ensure the existence of the table in the database. It creates\n   * the table if it does not already exist.\n   * @returns Promise that resolves when the table has been ensured.\n   */\n  async ensureTableInDatabase(): Promise<void> {\n    await this.appDataSource.query(\"CREATE EXTENSION IF NOT EXISTS vector;\");\n    await this.appDataSource.query(`\n      CREATE TABLE IF NOT EXISTS ${this.getTablePath()} (\n        \"id\" uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,\n        \"pageContent\" text,\n        metadata jsonb,\n        embedding vector\n      );\n    `);\n  }\n\n  private getTablePath() {\n    if (!this.schemaName) return this.tableName;\n\n    return `\"${this.schemaName}\".\"${this.tableName}\"`;\n  }\n\n  /**\n   * Static method to create a new `TypeORMVectorStore` instance from an\n   * array of texts and their metadata. It converts the texts into\n   * `Document` instances and adds them to the store.\n   * @param texts Array of texts.\n   * @param metadatas Array of metadata objects or a single metadata object.\n   * @param embeddings Embeddings instance.\n   * @param dbConfig `TypeORMVectorStoreArgs` instance.\n   * @returns Promise that resolves with a new instance of `TypeORMVectorStore`.\n   */\n  static async fromTexts(\n    texts: string[],\n    metadatas: object[] | object,\n    embeddings: EmbeddingsInterface,\n    dbConfig: TypeORMVectorStoreArgs\n  ): Promise<TypeORMVectorStore> {\n    const docs = [];\n    for (let i = 0; i < texts.length; i += 1) {\n      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;\n      const newDoc = new Document({\n        pageContent: texts[i],\n        metadata,\n      });\n      docs.push(newDoc);\n    }\n\n    return TypeORMVectorStore.fromDocuments(docs, embeddings, dbConfig);\n  }\n\n  /**\n   * Static method to create a new `TypeORMVectorStore` instance from an\n   * array of `Document` instances. It adds the documents to the store.\n   * @param docs Array of `Document` instances.\n   * @param embeddings Embeddings instance.\n   * @param dbConfig `TypeORMVectorStoreArgs` instance.\n   * @returns Promise that resolves with a new instance of `TypeORMVectorStore`.\n   */\n  static async fromDocuments(\n    docs: Document[],\n    embeddings: EmbeddingsInterface,\n    dbConfig: TypeORMVectorStoreArgs\n  ): Promise<TypeORMVectorStore> {\n    const instance = await TypeORMVectorStore.fromDataSource(\n      embeddings,\n      dbConfig\n    );\n    await instance.addDocuments(docs);\n\n    return instance;\n  }\n\n  /**\n   * Static method to create a new `TypeORMVectorStore` instance from an\n   * existing index.\n   * @param embeddings Embeddings instance.\n   * @param dbConfig `TypeORMVectorStoreArgs` instance.\n   * @returns Promise that resolves with a new instance of `TypeORMVectorStore`.\n   */\n  static async fromExistingIndex(\n    embeddings: EmbeddingsInterface,\n    dbConfig: TypeORMVectorStoreArgs\n  ): Promise<TypeORMVectorStore> {\n    const instance = await TypeORMVectorStore.fromDataSource(\n      embeddings,\n      dbConfig\n    );\n    return instance;\n  }\n}\n"],"mappings":"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"}