{"version":3,"file":"bucketmanager.js","names":["ConflictResolutionType","BucketType","StorageBackend","EvictionPolicy","CompressionMode"],"sources":["../../../../../../../../../node_modules/.pnpm/couchbase@4.5.0/node_modules/couchbase/dist/bucketmanager.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BucketManager = exports.BucketSettings = exports.CompressionMode = exports.EvictionPolicy = exports.StorageBackend = exports.BucketType = exports.ConflictResolutionType = void 0;\nconst bindingutilities_1 = require(\"./bindingutilities\");\nconst utilities_1 = require(\"./utilities\");\n/**\n * Represents the various conflict resolution modes which can be used for\n * XDCR synchronization against a bucket.\n *\n * @category Management\n */\nvar ConflictResolutionType;\n(function (ConflictResolutionType) {\n    /**\n     * Indicates that timestamps should be used for conflict resolution.  The most\n     * recently modified document (according to each server, ie: time synchronization\n     * is important) is the one selected to win.\n     */\n    ConflictResolutionType[\"Timestamp\"] = \"lww\";\n    /**\n     * Indicates that the seqno of the document should be used for conflict resolution.\n     */\n    ConflictResolutionType[\"SequenceNumber\"] = \"seqno\";\n    /**\n     * Indicates that custom conflict resolution should be used.\n     *\n     * @experimental This mode is only available in Couchbase Server 7.1 with the\n     * \"developer-preview\" mode enabled.\n     */\n    ConflictResolutionType[\"Custom\"] = \"custom\";\n})(ConflictResolutionType || (exports.ConflictResolutionType = ConflictResolutionType = {}));\n/**\n * Represents the type of a bucket.\n *\n * @category Management\n */\nvar BucketType;\n(function (BucketType) {\n    /**\n     * Indicates the bucket should be a Couchbase bucket.\n     */\n    BucketType[\"Couchbase\"] = \"membase\";\n    /**\n     * Indicates the bucket should be a Memcached bucket.\n     */\n    BucketType[\"Memcached\"] = \"memcached\";\n    /**\n     * Indicates the bucket should be a Ephemeral bucket.\n     */\n    BucketType[\"Ephemeral\"] = \"ephemeral\";\n})(BucketType || (exports.BucketType = BucketType = {}));\n/**\n * Represents the storage backend to use for a bucket.\n *\n * @category Management\n */\nvar StorageBackend;\n(function (StorageBackend) {\n    /**\n     * Indicates the bucket should use the Couchstore storage engine.\n     */\n    StorageBackend[\"Couchstore\"] = \"couchstore\";\n    /**\n     * Indicates the bucket should use the Magma storage engine.\n     */\n    StorageBackend[\"Magma\"] = \"magma\";\n})(StorageBackend || (exports.StorageBackend = StorageBackend = {}));\n/**\n * Represents the eviction policy that should be used for a bucket.\n *\n * @category Management\n */\nvar EvictionPolicy;\n(function (EvictionPolicy) {\n    /**\n     * Indicates that both the document meta-data and value should be evicted.\n     */\n    EvictionPolicy[\"FullEviction\"] = \"fullEviction\";\n    /**\n     * Indicates that only the value of a document should be evicted.\n     */\n    EvictionPolicy[\"ValueOnly\"] = \"valueOnly\";\n    /**\n     * Indicates that the least recently used documents are evicted.\n     */\n    EvictionPolicy[\"NotRecentlyUsed\"] = \"nruEviction\";\n    /**\n     * Indicates that nothing should be evicted.\n     */\n    EvictionPolicy[\"NoEviction\"] = \"noEviction\";\n})(EvictionPolicy || (exports.EvictionPolicy = EvictionPolicy = {}));\n/**\n * Specifies the compression mode that should be used for a bucket.\n *\n * @category Management\n */\nvar CompressionMode;\n(function (CompressionMode) {\n    /**\n     * Indicates that compression should not be used on the server.\n     */\n    CompressionMode[\"Off\"] = \"off\";\n    /**\n     * Indicates that compression should be used passively.  That is that if the\n     * client sends data which is encrypted, it is stored on the server in its\n     * compressed form, but the server does not actively compress documents.\n     */\n    CompressionMode[\"Passive\"] = \"passive\";\n    /**\n     * Indicates that compression should be performed actively.  Even if the\n     * client does not transmit the document in a compressed form.\n     */\n    CompressionMode[\"Active\"] = \"active\";\n})(CompressionMode || (exports.CompressionMode = CompressionMode = {}));\n/**\n * Represents the configured options for a bucket.\n *\n * @category Management\n */\nclass BucketSettings {\n    /**\n     * @internal\n     */\n    constructor(data) {\n        this.name = data.name;\n        this.flushEnabled = data.flushEnabled;\n        this.ramQuotaMB = data.ramQuotaMB;\n        this.numReplicas = data.numReplicas;\n        this.replicaIndexes = data.replicaIndexes;\n        this.bucketType = data.bucketType;\n        this.storageBackend = data.storageBackend;\n        this.evictionPolicy = data.evictionPolicy;\n        this.maxExpiry = data.maxExpiry;\n        this.compressionMode = data.compressionMode;\n        this.minimumDurabilityLevel = data.minimumDurabilityLevel;\n        this.historyRetentionCollectionDefault =\n            data.historyRetentionCollectionDefault;\n        this.historyRetentionDuration = data.historyRetentionDuration;\n        this.historyRetentionBytes = data.historyRetentionBytes;\n    }\n    /**\n     * Same as {@link IBucketSettings.maxExpiry}.\n     *\n     * @deprecated Use {@link IBucketSettings.maxExpiry} instead.\n     */\n    get maxTTL() {\n        var _a;\n        return (_a = this.maxExpiry) !== null && _a !== void 0 ? _a : 0;\n    }\n    set maxTTL(val) {\n        this.maxExpiry = val;\n    }\n    /**\n     * Same as {@link IBucketSettings.evictionPolicy}.\n     *\n     * @deprecated Use {@link IBucketSettings.evictionPolicy} instead.\n     */\n    get ejectionMethod() {\n        return this.evictionPolicy;\n    }\n    set ejectionMethod(val) {\n        this.evictionPolicy = val;\n    }\n    /**\n     * Same as {@link IBucketSettings.minimumDurabilityLevel}, but represented as\n     * the raw server-side configuration string.\n     *\n     * @deprecated Use {@link IBucketSettings.minimumDurabilityLevel} instead.\n     */\n    get durabilityMinLevel() {\n        return (0, utilities_1.duraLevelToNsServerStr)(this.minimumDurabilityLevel);\n    }\n    /**\n     * @internal\n     */\n    static _toCppData(data) {\n        return {\n            name: data.name,\n            bucket_type: (0, bindingutilities_1.bucketTypeToCpp)(data.bucketType),\n            ram_quota_mb: data.ramQuotaMB,\n            max_expiry: data.maxTTL || data.maxExpiry,\n            compression_mode: (0, bindingutilities_1.bucketCompressionModeToCpp)(data.compressionMode),\n            minimum_durability_level: (0, bindingutilities_1.durabilityToCpp)((0, utilities_1.nsServerStrToDuraLevel)(data.durabilityMinLevel)) ||\n                (0, bindingutilities_1.durabilityToCpp)(data.minimumDurabilityLevel),\n            num_replicas: data.numReplicas,\n            replica_indexes: data.replicaIndexes,\n            flush_enabled: data.flushEnabled,\n            eviction_policy: (0, bindingutilities_1.bucketEvictionPolicyToCpp)(data.evictionPolicy),\n            storage_backend: (0, bindingutilities_1.bucketStorageBackendToCpp)(data.storageBackend),\n            history_retention_collection_default: data.historyRetentionCollectionDefault,\n            history_retention_bytes: data.historyRetentionBytes,\n            history_retention_duration: data.historyRetentionDuration,\n        };\n    }\n    /**\n     * @internal\n     */\n    static _fromCppData(data) {\n        return new BucketSettings({\n            name: data.name,\n            flushEnabled: data.flush_enabled,\n            ramQuotaMB: data.ram_quota_mb,\n            numReplicas: data.num_replicas,\n            replicaIndexes: data.replica_indexes,\n            bucketType: (0, bindingutilities_1.bucketTypeFromCpp)(data.bucket_type),\n            storageBackend: (0, bindingutilities_1.bucketStorageBackendFromCpp)(data.storage_backend),\n            evictionPolicy: (0, bindingutilities_1.bucketEvictionPolicyFromCpp)(data.eviction_policy),\n            maxExpiry: data.max_expiry,\n            compressionMode: (0, bindingutilities_1.bucketCompressionModeFromCpp)(data.compression_mode),\n            historyRetentionCollectionDefault: data.history_retention_collection_default,\n            historyRetentionBytes: data.history_retention_bytes,\n            historyRetentionDuration: data.history_retention_duration,\n            minimumDurabilityLevel: (0, bindingutilities_1.durabilityFromCpp)(data.minimum_durability_level),\n            maxTTL: 0,\n            durabilityMinLevel: '',\n            ejectionMethod: '',\n        });\n    }\n}\nexports.BucketSettings = BucketSettings;\n/**\n * We intentionally do not export this class as it is never returned back\n * to the user, but we still need the ability to translate to NS data.\n *\n * @internal\n */\nclass CreateBucketSettings extends BucketSettings {\n    /**\n     * @internal\n     */\n    constructor(data) {\n        super(data);\n        this.conflictResolutionType = data.conflictResolutionType;\n    }\n    /**\n     * @internal\n     */\n    static _toCppData(data) {\n        return {\n            ...BucketSettings._toCppData(data),\n            conflict_resolution_type: (0, bindingutilities_1.bucketConflictResolutionTypeToCpp)(data.conflictResolutionType),\n        };\n    }\n}\n/**\n * BucketManager provides an interface for adding/removing/updating\n * buckets within the cluster.\n *\n * @category Management\n */\nclass BucketManager {\n    /**\n     * @internal\n     */\n    constructor(cluster) {\n        this._cluster = cluster;\n    }\n    /**\n     * Creates a new bucket.\n     *\n     * @param settings The settings to use for the new bucket.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async createBucket(settings, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            const bucketData = CreateBucketSettings._toCppData(settings);\n            this._cluster.conn.managementBucketCreate({\n                bucket: bucketData,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Updates the settings for an existing bucket.\n     *\n     * @param settings The new settings to use for the bucket.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async updateBucket(settings, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            const bucketData = BucketSettings._toCppData(settings);\n            this._cluster.conn.managementBucketUpdate({\n                bucket: bucketData,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Drops an existing bucket.\n     *\n     * @param bucketName The name of the bucket to drop.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async dropBucket(bucketName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementBucketDrop({\n                name: bucketName,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n    /**\n     * Fetches the settings in use for a specified bucket.\n     *\n     * @param bucketName The name of the bucket to fetch settings for.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async getBucket(bucketName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementBucketGet({\n                name: bucketName,\n                timeout: timeout,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                const bucket = BucketSettings._fromCppData(resp.bucket);\n                wrapCallback(null, bucket);\n            });\n        }, callback);\n    }\n    /**\n     * Returns a list of existing buckets in the cluster.\n     *\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async getAllBuckets(options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[0];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementBucketGetAll({\n                timeout: timeout,\n            }, (cppErr, resp) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                const buckets = resp.buckets.map((bucketData) => BucketSettings._fromCppData(bucketData));\n                wrapCallback(null, buckets);\n            });\n        }, callback);\n    }\n    /**\n     * Flushes the bucket, deleting all the existing data that is stored in it.\n     *\n     * @param bucketName The name of the bucket to flush.\n     * @param options Optional parameters for this operation.\n     * @param callback A node-style callback to be invoked after execution.\n     */\n    async flushBucket(bucketName, options, callback) {\n        if (options instanceof Function) {\n            callback = arguments[1];\n            options = undefined;\n        }\n        if (!options) {\n            options = {};\n        }\n        const timeout = options.timeout || this._cluster.managementTimeout;\n        return utilities_1.PromiseHelper.wrap((wrapCallback) => {\n            this._cluster.conn.managementBucketFlush({\n                name: bucketName,\n                timeout: timeout,\n            }, (cppErr) => {\n                const err = (0, bindingutilities_1.errorFromCpp)(cppErr);\n                if (err) {\n                    return wrapCallback(err, null);\n                }\n                wrapCallback(err);\n            });\n        }, callback);\n    }\n}\nexports.BucketManager = BucketManager;\n"],"x_google_ignoreList":[0],"mappings":"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"}