{"version":3,"file":"ibm.js","names":["fields: WatsonxInputEmbeddings & WatsonxAuth","inputs: string[]","textEmbeddingParams: TextEmbeddingsParams","documents: string[]","document: string"],"sources":["../../src/embeddings/ibm.ts"],"sourcesContent":["import { Embeddings } from \"@langchain/core/embeddings\";\nimport {\n  EmbeddingParameters,\n  TextEmbeddingsParams,\n} from \"@ibm-cloud/watsonx-ai/dist/watsonx-ai-ml/vml_v1.js\";\nimport { WatsonXAI } from \"@ibm-cloud/watsonx-ai\";\nimport { AsyncCaller } from \"@langchain/core/utils/async_caller\";\nimport { WatsonxAuth, WatsonxParams } from \"../types/ibm.js\";\nimport { authenticateAndSetInstance } from \"../utils/ibm.js\";\n\nexport interface WatsonxEmbeddingsParams\n  extends Pick<TextEmbeddingsParams, \"headers\"> {\n  truncateInputTokens?: number;\n}\n\nexport interface WatsonxInputEmbeddings\n  extends Omit<WatsonxParams, \"idOrName\"> {\n  truncateInputTokens?: number;\n}\n\nexport class WatsonxEmbeddings\n  extends Embeddings\n  implements WatsonxEmbeddingsParams, WatsonxParams\n{\n  model: string;\n\n  serviceUrl: string;\n\n  version: string;\n\n  spaceId?: string;\n\n  projectId?: string;\n\n  truncateInputTokens?: number;\n\n  maxRetries?: number;\n\n  maxConcurrency?: number;\n\n  private service: WatsonXAI;\n\n  constructor(fields: WatsonxInputEmbeddings & WatsonxAuth) {\n    const superProps = { maxConcurrency: 2, ...fields };\n    super(superProps);\n    this.model = fields.model;\n    this.version = fields.version;\n    this.serviceUrl = fields.serviceUrl;\n    this.truncateInputTokens = fields.truncateInputTokens;\n    this.maxConcurrency = fields.maxConcurrency;\n    this.maxRetries = fields.maxRetries ?? 0;\n    if (fields.projectId && fields.spaceId)\n      throw new Error(\"Maximum 1 id type can be specified per instance\");\n    else if (!fields.projectId && !fields.spaceId)\n      throw new Error(\n        \"No id specified! At least id of 1 type has to be specified\"\n      );\n    this.projectId = fields?.projectId;\n    this.spaceId = fields?.spaceId;\n    this.serviceUrl = fields?.serviceUrl;\n    const {\n      watsonxAIApikey,\n      watsonxAIAuthType,\n      watsonxAIBearerToken,\n      watsonxAIUsername,\n      watsonxAIPassword,\n      watsonxAIUrl,\n      disableSSL,\n      version,\n      serviceUrl,\n    } = fields;\n    const auth = authenticateAndSetInstance({\n      watsonxAIApikey,\n      watsonxAIAuthType,\n      watsonxAIBearerToken,\n      watsonxAIUsername,\n      watsonxAIPassword,\n      watsonxAIUrl,\n      disableSSL,\n      version,\n      serviceUrl,\n    });\n    if (auth) this.service = auth;\n    else throw new Error(\"You have not provided one type of authentication\");\n  }\n\n  scopeId() {\n    if (this.projectId)\n      return { projectId: this.projectId, modelId: this.model };\n    else return { spaceId: this.spaceId, modelId: this.model };\n  }\n\n  invocationParams(): EmbeddingParameters {\n    return {\n      truncate_input_tokens: this.truncateInputTokens,\n    };\n  }\n\n  async listModels() {\n    const listModelParams = {\n      filters: \"function_embedding\",\n    };\n    const caller = new AsyncCaller({\n      maxConcurrency: this.maxConcurrency,\n      maxRetries: this.maxRetries,\n    });\n    const listModels = await caller.call(() =>\n      this.service.listFoundationModelSpecs(listModelParams)\n    );\n    return listModels.result.resources?.map((item) => item.model_id);\n  }\n\n  private async embedSingleText(inputs: string[]) {\n    const textEmbeddingParams: TextEmbeddingsParams = {\n      inputs,\n      ...this.scopeId(),\n      parameters: this.invocationParams(),\n    };\n    const caller = new AsyncCaller({\n      maxConcurrency: this.maxConcurrency,\n      maxRetries: this.maxRetries,\n    });\n    const embeddings = await caller.call(() =>\n      this.service.embedText(textEmbeddingParams)\n    );\n    return embeddings.result.results.map((item) => item.embedding);\n  }\n\n  async embedDocuments(documents: string[]): Promise<number[][]> {\n    const data = await this.embedSingleText(documents);\n    return data;\n  }\n\n  async embedQuery(document: string): Promise<number[]> {\n    const data = await this.embedSingleText([document]);\n    return data[0];\n  }\n}\n"],"mappings":";;;;;;;;AAoBA,IAAa,oBAAb,cACU,WAEV;CACE;CAEA;CAEA;CAEA;CAEA;CAEA;CAEA;CAEA;CAEA,AAAQ;CAER,YAAYA,QAA8C;EACxD,MAAM,aAAa;GAAE,gBAAgB;GAAG,GAAG;EAAQ;EACnD,MAAM,WAAW;EACjB,KAAK,QAAQ,OAAO;EACpB,KAAK,UAAU,OAAO;EACtB,KAAK,aAAa,OAAO;EACzB,KAAK,sBAAsB,OAAO;EAClC,KAAK,iBAAiB,OAAO;EAC7B,KAAK,aAAa,OAAO,cAAc;AACvC,MAAI,OAAO,aAAa,OAAO,QAC7B,OAAM,IAAI,MAAM;WACT,CAAC,OAAO,aAAa,CAAC,OAAO,QACpC,OAAM,IAAI,MACR;EAEJ,KAAK,YAAY,QAAQ;EACzB,KAAK,UAAU,QAAQ;EACvB,KAAK,aAAa,QAAQ;EAC1B,MAAM,EACJ,iBACA,mBACA,sBACA,mBACA,mBACA,cACA,YACA,SACA,YACD,GAAG;EACJ,MAAM,OAAO,2BAA2B;GACtC;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;EACD,EAAC;AACF,MAAI,MAAM,KAAK,UAAU;MACpB,OAAM,IAAI,MAAM;CACtB;CAED,UAAU;AACR,MAAI,KAAK,UACP,QAAO;GAAE,WAAW,KAAK;GAAW,SAAS,KAAK;EAAO;MACtD,QAAO;GAAE,SAAS,KAAK;GAAS,SAAS,KAAK;EAAO;CAC3D;CAED,mBAAwC;AACtC,SAAO,EACL,uBAAuB,KAAK,oBAC7B;CACF;CAED,MAAM,aAAa;EACjB,MAAM,kBAAkB,EACtB,SAAS,qBACV;EACD,MAAM,SAAS,IAAI,YAAY;GAC7B,gBAAgB,KAAK;GACrB,YAAY,KAAK;EAClB;EACD,MAAM,aAAa,MAAM,OAAO,KAAK,MACnC,KAAK,QAAQ,yBAAyB,gBAAgB,CACvD;AACD,SAAO,WAAW,OAAO,WAAW,IAAI,CAAC,SAAS,KAAK,SAAS;CACjE;CAED,MAAc,gBAAgBC,QAAkB;EAC9C,MAAMC,sBAA4C;GAChD;GACA,GAAG,KAAK,SAAS;GACjB,YAAY,KAAK,kBAAkB;EACpC;EACD,MAAM,SAAS,IAAI,YAAY;GAC7B,gBAAgB,KAAK;GACrB,YAAY,KAAK;EAClB;EACD,MAAM,aAAa,MAAM,OAAO,KAAK,MACnC,KAAK,QAAQ,UAAU,oBAAoB,CAC5C;AACD,SAAO,WAAW,OAAO,QAAQ,IAAI,CAAC,SAAS,KAAK,UAAU;CAC/D;CAED,MAAM,eAAeC,WAA0C;EAC7D,MAAM,OAAO,MAAM,KAAK,gBAAgB,UAAU;AAClD,SAAO;CACR;CAED,MAAM,WAAWC,UAAqC;EACpD,MAAM,OAAO,MAAM,KAAK,gBAAgB,CAAC,QAAS,EAAC;AACnD,SAAO,KAAK;CACb;AACF"}